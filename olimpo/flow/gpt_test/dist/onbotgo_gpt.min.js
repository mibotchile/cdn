var Rs = Object.defineProperty;
var ks = (a, r, o) => r in a ? Rs(a, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : a[r] = o;
var k = (a, r, o) => (ks(a, typeof r != "symbol" ? r + "" : r, o), o);
function Bs(a, r) {
  for (var o = 0; o < r.length; o++) {
    const h = r[o];
    if (typeof h != "string" && !Array.isArray(h)) {
      for (const l in h)
        if (l !== "default" && !(l in a)) {
          const d = Object.getOwnPropertyDescriptor(h, l);
          d && Object.defineProperty(a, l, d.get ? d : {
            enumerable: !0,
            get: () => h[l]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }));
}
class Is {
  constructor() {
    k(this, "typography", {
      primary: "'Trebuchet MS', sans-serif"
    });
    k(this, "colors", { primary: "rgb(59, 129, 246)" });
    k(this, "defaultIcon", `
  <svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
  `);
    k(this, "customIcon", "");
  }
}
const ot = new Is();
var Zo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fo(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function Os(a) {
  if (a.__esModule)
    return a;
  var r = a.default;
  if (typeof r == "function") {
    var o = function h() {
      return this instanceof h ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    o.prototype = r.prototype;
  } else
    o = {};
  return Object.defineProperty(o, "__esModule", { value: !0 }), Object.keys(a).forEach(function(h) {
    var l = Object.getOwnPropertyDescriptor(a, h);
    Object.defineProperty(o, h, l.get ? l : {
      enumerable: !0,
      get: function() {
        return a[h];
      }
    });
  }), o;
}
const zs = {}, Ds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: zs
}, Symbol.toStringTag, { value: "Module" })), Uo = /* @__PURE__ */ Os(Ds);
var Ro = new Function("return this")().Promise, Gi = !1;
try {
  Gi = new Function("return (async function(){}).constructor")();
} catch (a) {
  if (!(a instanceof SyntaxError))
    throw a;
}
function jo(a, r) {
  return Object.prototype.hasOwnProperty.call(a, r);
}
function Te(a, r, o) {
  for (var h in r)
    jo(r, h) && (r[h] != null && typeof r[h] == "object" && (h === "storage" || h === "prefixes") && !o ? a[h] = Te(
      /*toObj[key] ||*/
      {},
      r[h]
    ) : a[h] = r[h]);
  return a;
}
function Ns(a, r, o, h) {
  var l, d;
  return typeof r.autoTrim == "string" ? l = d = r.autoTrim : Array.isArray(r.autoTrim) && (l = r.autoTrim[1], d = r.autoTrim[0]), (o || o === !1) && (l = o), (h || h === !1) && (d = h), l === "slurp" && d === "slurp" ? a.trim() : (l === "_" || l === "slurp" ? String.prototype.trimLeft ? a = a.trimLeft() : a = a.replace(/^[\s\uFEFF\xA0]+/, "") : (l === "-" || l === "nl") && (a = a.replace(/^(?:\n|\r|\r\n)/, "")), d === "_" || d === "slurp" ? String.prototype.trimRight ? a = a.trimRight() : a = a.replace(/[\s\uFEFF\xA0]+$/, "") : (d === "-" || d === "nl") && (a = a.replace(/(?:\n|\r|\r\n)$/, "")), a);
}
var oi = (
  /** @class */
  function() {
    function a(r) {
      this.cache = r;
    }
    return a.prototype.define = function(r, o) {
      this.cache[r] = o;
    }, a.prototype.get = function(r) {
      return this.cache[r];
    }, a.prototype.remove = function(r) {
      delete this.cache[r];
    }, a.prototype.reset = function() {
      this.cache = {};
    }, a.prototype.load = function(r) {
      Te(this.cache, r, !0);
    }, a;
  }()
);
function Hs(a, r) {
  Object.setPrototypeOf ? Object.setPrototypeOf(a, r) : a.__proto__ = r;
}
function dt(a) {
  var r = new Error(a);
  return Hs(r, dt.prototype), r;
}
dt.prototype = Object.create(Error.prototype, {
  name: { value: "Squirrelly Error", enumerable: !1 }
});
function Zt(a, r, o) {
  var h = r.slice(0, o).split(/\n/), l = h.length, d = h[l - 1].length + 1;
  throw a += " at line " + l + " col " + d + `:

  ` + r.split(/\n/)[l - 1] + `
  ` + Array(d).join(" ") + "^", dt(a);
}
var Ft = /^async +/, Ge = /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\${)[^\\`])*`/g, Xe = /'(?:\\[\s\w"'\\`]|[^\n\r'\\])*?'/g, Qe = /"(?:\\[\s\w"'\\`]|[^\n\r"\\])*?"/g, ko = /[.*+\-?^${}()|[\]\\]/g;
function Ke(a) {
  return ko.test(a) ? a.replace(ko, "\\$&") : a;
}
function Zs(a, r) {
  r.rmWhitespace && (a = a.replace(/[\r\n]+/g, `
`).replace(/^\s+|\s+$/gm, "")), Ge.lastIndex = 0, Xe.lastIndex = 0, Qe.lastIndex = 0;
  var o = r.prefixes, h = [
    o.h,
    o.b,
    o.i,
    o.r,
    o.c,
    o.e
  ].reduce(function(E, C) {
    return E && C ? E + "|" + Ke(C) : C ? Ke(C) : E;
  }, ""), l = new RegExp("([|()]|=>)|('|\"|`|\\/\\*)|\\s*((\\/)?(-|_)?" + // comments, strings
  Ke(r.tags[1]) + ")", "g"), d = new RegExp("([^]*?)" + Ke(r.tags[0]) + "(-|_)?\\s*(" + h + ")?\\s*", "g"), u = 0, p = !1;
  function g(E, C) {
    var x = { f: [] }, R = 0, Z = "c";
    C === "h" || C === "b" || C === "c" ? Z = "n" : C === "r" && (x.raw = !0, C = "i");
    function S(J) {
      var ee = a.slice(u, J), $ = ee.trim();
      if (Z === "f")
        $ === "safe" ? x.raw = !0 : r.async && Ft.test($) ? ($ = $.replace(Ft, ""), x.f.push([$, "", !0])) : x.f.push([$, ""]);
      else if (Z === "fp")
        x.f[x.f.length - 1][1] += $;
      else if (Z === "err") {
        if ($) {
          var Ut = ee.search(/\S/);
          Zt("invalid syntax", a, u + Ut);
        }
      } else
        x[Z] = $;
      u = J + 1;
    }
    l.lastIndex = u;
    for (var B; (B = l.exec(a)) !== null; ) {
      var G = B[1], F = B[2], V = B[3], rt = B[4], Y = B[5], K = B.index;
      if (G)
        G === "(" ? (R === 0 && (Z === "n" ? (S(K), Z = "p") : Z === "f" && (S(K), Z = "fp")), R++) : G === ")" ? (R--, R === 0 && Z !== "c" && (S(K), Z = "err")) : R === 0 && G === "|" ? (S(K), Z = "f") : G === "=>" && (S(K), u += 1, Z = "res");
      else if (F) {
        if (F === "/*") {
          var vt = a.indexOf("*/", l.lastIndex);
          vt === -1 && Zt("unclosed comment", a, B.index), l.lastIndex = vt + 2;
        } else if (F === "'") {
          Xe.lastIndex = B.index;
          var Q = Xe.exec(a);
          Q ? l.lastIndex = Xe.lastIndex : Zt("unclosed string", a, B.index);
        } else if (F === '"') {
          Qe.lastIndex = B.index;
          var it = Qe.exec(a);
          it ? l.lastIndex = Qe.lastIndex : Zt("unclosed string", a, B.index);
        } else if (F === "`") {
          Ge.lastIndex = B.index;
          var lt = Ge.exec(a);
          lt ? l.lastIndex = Ge.lastIndex : Zt("unclosed string", a, B.index);
        }
      } else if (V)
        return S(K), u = K + B[0].length, d.lastIndex = u, p = Y, rt && C === "h" && (C = "s"), x.t = C, x;
    }
    return Zt("unclosed tag", a, E), x;
  }
  function _(E, C) {
    E.b = [], E.d = [];
    var x = !1, R = [];
    function Z(lt, J) {
      lt && (lt = Ns(
        lt,
        r,
        p,
        // this will only be false on the first str, the next ones will be null or undefined
        J
      ), lt && (lt = lt.replace(/\\|'/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n"), R.push(lt)));
    }
    for (var S; (S = d.exec(a)) !== null; ) {
      var B = S[1], G = S[2], F = S[3] || "", V;
      for (var rt in o)
        if (o[rt] === F) {
          V = rt;
          break;
        }
      Z(B, G), u = S.index + S[0].length, V || Zt("unrecognized tag type: " + F, a, u);
      var Y = g(S.index, V), K = Y.t;
      if (K === "h") {
        var vt = Y.n || "";
        r.async && Ft.test(vt) && (Y.a = !0, Y.n = vt.replace(Ft, "")), Y = _(Y), R.push(Y);
      } else if (K === "c") {
        if (E.n === Y.n)
          return x ? (x.d = R, E.b.push(x)) : E.d = R, E;
        Zt("Helper start and end don't match", a, S.index + S[0].length);
      } else if (K === "b") {
        x ? (x.d = R, E.b.push(x)) : E.d = R;
        var Q = Y.n || "";
        r.async && Ft.test(Q) && (Y.a = !0, Y.n = Q.replace(Ft, "")), x = Y, R = [];
      } else if (K === "s") {
        var it = Y.n || "";
        r.async && Ft.test(it) && (Y.a = !0, Y.n = it.replace(Ft, "")), R.push(Y);
      } else
        R.push(Y);
    }
    if (C)
      Z(a.slice(u, a.length), !1), E.d = R;
    else
      throw dt('unclosed helper "' + E.n + '"');
    return E;
  }
  var y = _({ f: [] }, !0);
  if (r.plugins)
    for (var w = 0; w < r.plugins.length; w++) {
      var P = r.plugins[w];
      P.processAST && (y.d = P.processAST(y.d, r));
    }
  return y.d;
}
function Bo(a, r) {
  var o = Zs(a, r), h = "var tR='';" + (r.useWith ? "with(" + r.varName + "||{}){" : "") + Xt(o, r) + "if(cb){cb(null,tR)} return tR" + (r.useWith ? "}" : "");
  if (r.plugins)
    for (var l = 0; l < r.plugins.length; l++) {
      var d = r.plugins[l];
      d.processFnString && (h = d.processFnString(h, r));
    }
  return h;
}
function ji(a, r) {
  for (var o = 0; o < r.length; o++) {
    var h = r[o][0], l = r[o][1], d = r[o][2];
    a = (d ? "await " : "") + "c.l('F','" + h + "')(" + a, l && (a += "," + l), a += ")";
  }
  return a;
}
function qo(a, r, o, h, l, d) {
  var u = "{exec:" + (l ? "async " : "") + Vo(o, r, a) + ",params:[" + h + "]";
  return d && (u += ",name:'" + d + "'"), l && (u += ",async:true"), u += "}", u;
}
function Fs(a, r) {
  for (var o = "[", h = 0; h < a.length; h++) {
    var l = a[h];
    o += qo(r, l.res || "", l.d, l.p || "", l.a, l.n), h < a.length && (o += ",");
  }
  return o += "]", o;
}
function Vo(a, r, o) {
  return "function(" + r + "){var tR='';" + Xt(a, o) + "return tR}";
}
function Xt(a, r) {
  var o = 0, h = a.length, l = "";
  for (o; o < h; o++) {
    var d = a[o];
    if (typeof d == "string") {
      var u = d;
      l += "tR+='" + u + "';";
    } else {
      var p = d.t, g = d.c || "", _ = d.f, y = d.n || "", w = d.p || "", P = d.res || "", E = d.b, C = !!d.a;
      if (p === "i") {
        r.defaultFilter && (g = "c.l('F','" + r.defaultFilter + "')(" + g + ")");
        var x = ji(g, _);
        !d.raw && r.autoEscape && (x = "c.l('F','e')(" + x + ")"), l += "tR+=" + x + ";";
      } else if (p === "h")
        if (r.storage.nativeHelpers.get(y))
          l += r.storage.nativeHelpers.get(y)(d, r);
        else {
          var R = (C ? "await " : "") + "c.l('H','" + y + "')(" + qo(r, P, d.d, w, C);
          E ? R += "," + Fs(E, r) : R += ",[]", R += ",c)", l += "tR+=" + ji(R, _) + ";";
        }
      else
        p === "s" ? l += "tR+=" + ji((C ? "await " : "") + "c.l('H','" + y + "')({params:[" + w + "]},[],c)", _) + ";" : p === "e" && (l += g + `
`);
    }
  }
  return l;
}
function Kt(a, r, o, h) {
  if (r && r.length > 0)
    throw dt((h ? "Native" : "") + "Helper '" + a + "' doesn't accept blocks");
  if (o && o.length > 0)
    throw dt((h ? "Native" : "") + "Helper '" + a + "' doesn't accept filters");
}
function Yo(a, r, o, h, l) {
  o(a[r], r).then(function(d) {
    h += d, r === a.length - 1 ? l(h) : Yo(a, r + 1, o, h, l);
  });
}
function Wo(a, r, o, h, l, d) {
  h(r[o], a[r[o]]).then(function(u) {
    l += u, o === r.length - 1 ? d(l) : Wo(a, r, o + 1, h, l, d);
  });
}
var Us = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function js(a) {
  return Us[a];
}
function qs(a) {
  var r = String(a);
  return /[&<>"']/.test(r) ? r.replace(/[&<>"']/g, js) : r;
}
var Vs = new oi({}), ln = new oi({
  each: function(a, r) {
    var o = "", h = a.params[0];
    if (Kt("each", r, !1), a.async)
      return new Promise(function(d) {
        Yo(h, 0, a.exec, o, d);
      });
    for (var l = 0; l < h.length; l++)
      o += a.exec(h[l], l);
    return o;
  },
  foreach: function(a, r) {
    var o = a.params[0];
    if (Kt("foreach", r, !1), a.async)
      return new Promise(function(d) {
        Wo(o, Object.keys(o), 0, a.exec, "", d);
      });
    var h = "";
    for (var l in o)
      jo(o, l) && (h += a.exec(l, o[l]));
    return h;
  },
  include: function(a, r, o) {
    Kt("include", r, !1);
    var h = o.storage.templates.get(a.params[0]);
    if (!h)
      throw dt('Could not fetch template "' + a.params[0] + '"');
    return h(a.params[1], o);
  },
  extends: function(a, r, o) {
    var h = a.params[1] || {};
    h.content = a.exec();
    for (var l = 0; l < r.length; l++) {
      var d = r[l];
      h[d.name] = d.exec();
    }
    var u = o.storage.templates.get(a.params[0]);
    if (!u)
      throw dt('Could not fetch template "' + a.params[0] + '"');
    return u(h, o);
  },
  useScope: function(a, r) {
    return Kt("useScope", r, !1), a.exec(a.params[0]);
  }
}), Ys = new oi({
  if: function(a, r) {
    Kt("if", !1, a.f, !0);
    var o = "if(" + a.p + "){" + Xt(a.d, r) + "}";
    if (a.b)
      for (var h = 0; h < a.b.length; h++) {
        var l = a.b[h];
        l.n === "else" ? o += "else{" + Xt(l.d, r) + "}" : l.n === "elif" && (o += "else if(" + l.p + "){" + Xt(l.d, r) + "}");
      }
    return o;
  },
  try: function(a, r) {
    if (Kt("try", !1, a.f, !0), !a.b || a.b.length !== 1 || a.b[0].n !== "catch")
      throw dt("native helper 'try' only accepts 1 block, 'catch'");
    var o = "try{" + Xt(a.d, r) + "}", h = a.b[0];
    return o += "catch" + (h.res ? "(" + h.res + ")" : "") + "{" + Xt(h.d, r) + "}", o;
  },
  block: function(a, r) {
    Kt("block", a.b, a.f, !0);
    var o = "if(!" + r.varName + "[" + a.p + "]){tR+=(" + Vo(a.d, "", r) + ")()}else{tR+=" + r.varName + "[" + a.p + "]}";
    return o;
  }
}), Ws = new oi({ e: qs }), Xi = {
  varName: "it",
  autoTrim: [!1, "nl"],
  autoEscape: !0,
  defaultFilter: !1,
  tags: ["{{", "}}"],
  l: function(a, r) {
    if (a === "H") {
      var o = this.storage.helpers.get(r);
      if (o)
        return o;
      throw dt("Can't find helper '" + r + "'");
    } else if (a === "F") {
      var h = this.storage.filters.get(r);
      if (h)
        return h;
      throw dt("Can't find filter '" + r + "'");
    }
  },
  async: !1,
  storage: {
    helpers: ln,
    nativeHelpers: Ys,
    filters: Ws,
    templates: Vs
  },
  prefixes: {
    h: "@",
    b: "#",
    i: "",
    r: "*",
    c: "/",
    e: "!"
  },
  cache: !1,
  plugins: [],
  useWith: !1
};
Xi.l.bind(Xi);
function ri(a, r) {
  var o = {};
  return Te(o, Xi), r && Te(o, r), a && Te(o, a), o.l.bind(o), o;
}
function cn(a, r) {
  var o = ri(r || {}), h = Function;
  if (o.async)
    if (Gi)
      h = Gi;
    else
      throw dt("This environment doesn't support async/await");
  try {
    return new h(
      o.varName,
      "c",
      // SqrlConfig
      "cb",
      // optional callback
      Bo(a, o)
    );
  } catch (l) {
    throw l instanceof SyntaxError ? dt(`Bad template syntax

` + l.message + `
` + Array(l.message.length + 1).join("=") + `
` + Bo(a, o)) : l;
  }
}
var Qi = Uo, qi = Uo, Gs = /^\uFEFF/;
function Vi(a, r, o) {
  var h = qi.resolve(
    o ? r : qi.dirname(r),
    // returns directory the parent file is in
    a
    // file
  ), l = qi.extname(a);
  return l || (h += ".sqrl"), h;
}
function Xs(a, r) {
  var o, h, l = r.views, d = /^[A-Za-z]+:\\|^\//.exec(a);
  if (d && d.length)
    o = Vi(a.replace(/^\/*/, ""), r.root || "/", !0);
  else if (r.filename && (h = Vi(a, r.filename), Qi.existsSync(h) && (o = h)), o || Array.isArray(l) && l.some(function(u) {
    return h = Vi(a, u, !0), Qi.existsSync(h);
  }) && (o = h), !o)
    throw dt('Could not find the include file "' + a + '"');
  return o;
}
function Go(a) {
  return Qi.readFileSync(a).toString().replace(Gs, "");
}
function Qs(a, r) {
  var o = ri(r), h = Go(a);
  try {
    var l = cn(h, o);
    return o.storage.templates.define(o.filename, l), l;
  } catch {
    throw dt("Loading file: " + a + " failed");
  }
}
function Ks(a) {
  var r = a.filename;
  if (a.cache) {
    var o = a.storage.templates.get(r);
    return o || Qs(r, a);
  }
  return cn(Go(r), a);
}
function Xo(a, r) {
  var o = ri({ filename: Xs(a, r) }, r);
  return Ks(o);
}
function Js(a, r, o) {
  if (r && r.length > 0)
    throw dt("Helper 'includeFile' doesn't accept blocks");
  return Xo(a.params[0], o)(a.params[1], o);
}
function $s(a, r, o) {
  var h = a.params[1] || {};
  h.content = a.exec();
  for (var l = 0; l < r.length; l++) {
    var d = r[l];
    h[d.name] = d.exec();
  }
  return Xo(a.params[0], o)(h, o);
}
function Yi(a, r) {
  var o;
  return r.cache && r.name && r.storage.templates.get(r.name) ? r.storage.templates.get(r.name) : (typeof a == "function" ? o = a : o = cn(a, r), r.cache && r.name && r.storage.templates.define(r.name, o), o);
}
function ta(a, r, o, h) {
  var l = ri(o || {});
  if (l.async) {
    var d;
    if (h)
      try {
        Yi(a, l)(r, l, h);
      } catch (u) {
        return h(u);
      }
    else {
      if (typeof Ro == "function")
        return new Ro(function(u, p) {
          try {
            d = Yi(a, l)(r, l), u(d);
          } catch (g) {
            p(g);
          }
        });
      throw dt("Please provide a callback function, this env doesn't support Promises");
    }
  } else
    return Yi(a, l)(r, l);
}
ln.define("includeFile", Js);
ln.define("extendsFile", $s);
class yt extends HTMLElement {
  setStyles(r) {
    Object.keys(r).forEach((h) => {
      this.style[h] = r[h];
    });
  }
  renderHTML(r, o = {}) {
    return ta(r, { ...o });
  }
  getChild(r) {
    return this.querySelector(r);
  }
}
const ea = '<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 24 24"  fill="currentColor">    <path  fill="currentColor" d="M 12.011719 2 C 6.5057187 2 2.0234844 6.478375 2.0214844 11.984375 C 2.0204844 13.744375 2.4814687 15.462563 3.3554688 16.976562 L 2 22 L 7.2324219 20.763672 C 8.6914219 21.559672 10.333859 21.977516 12.005859 21.978516 L 12.009766 21.978516 C 17.514766 21.978516 21.995047 17.499141 21.998047 11.994141 C 22.000047 9.3251406 20.962172 6.8157344 19.076172 4.9277344 C 17.190172 3.0407344 14.683719 2.001 12.011719 2 z M 12.009766 4 C 14.145766 4.001 16.153109 4.8337969 17.662109 6.3417969 C 19.171109 7.8517969 20.000047 9.8581875 19.998047 11.992188 C 19.996047 16.396187 16.413812 19.978516 12.007812 19.978516 C 10.674812 19.977516 9.3544062 19.642812 8.1914062 19.007812 L 7.5175781 18.640625 L 6.7734375 18.816406 L 4.8046875 19.28125 L 5.2851562 17.496094 L 5.5019531 16.695312 L 5.0878906 15.976562 C 4.3898906 14.768562 4.0204844 13.387375 4.0214844 11.984375 C 4.0234844 7.582375 7.6067656 4 12.009766 4 z M 8.4765625 7.375 C 8.3095625 7.375 8.0395469 7.4375 7.8105469 7.6875 C 7.5815469 7.9365 6.9355469 8.5395781 6.9355469 9.7675781 C 6.9355469 10.995578 7.8300781 12.182609 7.9550781 12.349609 C 8.0790781 12.515609 9.68175 15.115234 12.21875 16.115234 C 14.32675 16.946234 14.754891 16.782234 15.212891 16.740234 C 15.670891 16.699234 16.690438 16.137687 16.898438 15.554688 C 17.106437 14.971687 17.106922 14.470187 17.044922 14.367188 C 16.982922 14.263188 16.816406 14.201172 16.566406 14.076172 C 16.317406 13.951172 15.090328 13.348625 14.861328 13.265625 C 14.632328 13.182625 14.464828 13.140625 14.298828 13.390625 C 14.132828 13.640625 13.655766 14.201187 13.509766 14.367188 C 13.363766 14.534188 13.21875 14.556641 12.96875 14.431641 C 12.71875 14.305641 11.914938 14.041406 10.960938 13.191406 C 10.218937 12.530406 9.7182656 11.714844 9.5722656 11.464844 C 9.4272656 11.215844 9.5585938 11.079078 9.6835938 10.955078 C 9.7955938 10.843078 9.9316406 10.663578 10.056641 10.517578 C 10.180641 10.371578 10.223641 10.267562 10.306641 10.101562 C 10.389641 9.9355625 10.347156 9.7890625 10.285156 9.6640625 C 10.223156 9.5390625 9.737625 8.3065 9.515625 7.8125 C 9.328625 7.3975 9.131125 7.3878594 8.953125 7.3808594 C 8.808125 7.3748594 8.6425625 7.375 8.4765625 7.375 z"/></svg>';
class ia {
  constructor() {
    k(this, "active", !1);
    k(this, "number", "");
    k(this, "position", "br");
    k(this, "msg", "Hola quiero comunicarme para informacion");
  }
}
const St = new ia(), $e = "onbotgo-btn-whatsapp";
class Ki extends yt {
  constructor() {
    super(), this.innerHTML = this.renderHTML(this.html(), {}), this.onclick = () => {
      window.open(
        `https://wa.me/${St.number}?text=${St.msg}`
      );
    };
  }
  html() {
    return `<onbotgo-box>${ea}<onbotgo-box>`;
  }
}
Ki.tag = $e;
const na = (a) => ({
  [$e]: {
    "box-sizing": "border-box",
    position: "absolute",
    "background-color": "#25D366",
    "border-radius": "300px",
    padding: "8px",
    width: "48px",
    display: "flex",
    height: "48px",
    "align-items": "center",
    "justify-content": "center",
    "font-size": "20px",
    color: "white",
    top: a.position.includes("t") ? "20px" : "auto",
    left: a.position.includes("l") ? "20px" : "auto",
    right: a.position.includes("r") ? "20px" : "auto",
    bottom: a.position.includes("b") ? "20px" : "auto",
    transition: "transform .1s linear"
  },
  [`${$e}:hover`]: { transform: "scale(1.1)" },
  [`${$e} > onbotgo-box`]: {
    width: "35px",
    height: "35px",
    display: "grid",
    "font-size": "10px",
    "place-items": "center"
  }
}), oa = "onbotgo-box";
class te extends yt {
  constructor() {
    super(), this.setStyles({
      fontFamily: ot.typography.primary
    });
  }
}
te.tag = oa;
const ti = "onbotgo-bubble";
class un extends yt {
  constructor(r) {
    super(), this.innerHTML = r, this.innerHTML = this.isIconValid(r) ? r : ot.defaultIcon;
  }
  isIconValid(r) {
    var h, l, d, u;
    if (!r)
      return !1;
    const o = new te();
    if (o.innerHTML = r, !["svg", "i", "img"].includes((l = (h = o.children[0]) == null ? void 0 : h.tagName) == null ? void 0 : l.toLowerCase()))
      return console.error(`node is not valid.
 allowed nodes: "svg", "i", "img"`), !1;
    for (let p = 0; p < o.childNodes.length; p++) {
      const g = (u = (d = o.childNodes[p]) == null ? void 0 : d.tagName) == null ? void 0 : u.toLowerCase();
      if (["script"].includes(g))
        return console.error(`Element "<${g}>" is not valid.`), !1;
    }
    return !0;
  }
}
un.tag = ti;
const ra = (a) => ({
  [ti]: {
    display: "grid",
    "place-items": "center",
    width: "48px",
    height: "48px",
    "background-color": a.colors.primary,
    fill: "transparent",
    "border-radius": "100px",
    transition: "transform 0.1s linear"
  },
  [`${ti}:hover`]: {
    transform: "scale(1.1)"
  },
  [`${ti} > svg`]: {
    width: "28px",
    height: "28px",
    stroke: "white",
    "stroke-width": "2px",
    "border-image-width": "2"
  }
}), sa = `{{ @if (it.type === "userMessage") }} {{@if(it.file)}} {{@if(it.fileType\r
==='audio')}}\r
<onbotgo-box\r
  class="from-user onbotgo-message"\r
  style="display: flex; flex-direction: row; gap: 12px"\r
>\r
  <onbotgo-box style="width: 40px; height: 40px"\r
    ><img src="../../../assets/icons/user.svg"\r
  /></onbotgo-box>\r
  <onbotgo-box\r
    style="\r
      width: 32px;\r
      color: white;\r
      background-color: rgba(255, 255, 255, 0.2);\r
      border-radius: 100px;\r
      padding: 8px;\r
      height: 32px;\r
      box-sizing: border-box;\r
    "\r
    id="onbotgo-playAudioMessage"\r
    >{{it.iconPlayPause | safe}}</onbotgo-box\r
  >\r
  <div id="waveform" style="min-width: 100px"></div\r
></onbotgo-box>\r
{{#elif (it.fileType.includes('image'))}}\r
<onbotgo-box\r
  class="from-user onbotgo-message"\r
  style="display: flex; justify-content: center"\r
>\r
</onbotgo-box>\r
{{#else}}\r
<onbotgo-box class="from-user onbotgo-message">{{it.file.name}}</onbotgo-box>\r
{{/if}} {{#else }}\r
<onbotgo-box class="from-user onbotgo-message"></onbotgo-box>\r
{{/if}}{{/if}} {{@if(it.type === "LoadingMessage") }}\r
<onbotgo-box class="loading-api-message onbotgo-message">\r
  <onbotgo-box class="dot"></onbotgo-box>\r
  <onbotgo-box class="dot"></onbotgo-box>\r
  <onbotgo-box class="dot"></onbotgo-box>\r
  <onbotgo-box class="bg-semi-transp"></onbotgo-box>\r
</onbotgo-box>\r
{{/if}} {{@if((it.type === "apiMessage") ) }} {{@if(it.file)}} {{@if(it.fileType\r
=== 'audio')}}\r
<onbotgo-box\r
  class="from-chatbot onbotgo-message"\r
  style="display: flex; flex-direction: row; gap: 12px"\r
>\r
  <onbotgo-box\r
    style="\r
      width: 32px;\r
      color: white;\r
      background-color: rgba(255, 255, 255, 0.2);\r
      border-radius: 100px;\r
      padding: 8px;\r
      height: 32px;\r
      box-sizing: border-box;\r
    "\r
    id="onbotgo-playAudioMessage"\r
    >{{it.iconPlayPause | safe}}</onbotgo-box\r
  >\r
  <div id="waveform" style="min-width: 100px"></div\r
></onbotgo-box>\r
{{#elif(it.fileType.includes('image'))}}\r
\r
<onbotgo-box\r
  class="from-chatbot onbotgo-message"\r
  style="display: flex; justify-content: center"\r
>\r
</onbotgo-box>\r
{{#else}}\r
<onbotgo-box class="from-chatbot onbotgo-message"\r
  >{{it.file.name}}\r
</onbotgo-box>\r
{{/if}} {{#else}}\r
<onbotgo-box class="from-chatbot onbotgo-message">\r
  <onbotgo-box class="bg-semi-transp"></onbotgo-box>\r
</onbotgo-box>\r
{{ /if}} {{/if}} {{@if(it.type === "address" && it.render_map === 'background')\r
}}\r
<onbotgo-box class="from-chatbot onbotgo-message">\r
  <onbotgo-box class="bg-semi-transp"></onbotgo-box>\r
</onbotgo-box>\r
{{/if}}\r
`;
var aa = globalThis && globalThis.__awaiter || function(a, r, o, h) {
  function l(d) {
    return d instanceof o ? d : new o(function(u) {
      u(d);
    });
  }
  return new (o || (o = Promise))(function(d, u) {
    function p(y) {
      try {
        _(h.next(y));
      } catch (w) {
        u(w);
      }
    }
    function g(y) {
      try {
        _(h.throw(y));
      } catch (w) {
        u(w);
      }
    }
    function _(y) {
      y.done ? d(y.value) : l(y.value).then(p, g);
    }
    _((h = h.apply(a, r || [])).next());
  });
};
function ha(a, r) {
  return aa(this, void 0, void 0, function* () {
    const o = new AudioContext({ sampleRate: r });
    return o.decodeAudioData(a).finally(() => o.close());
  });
}
function la(a) {
  const r = a[0];
  if (r.some((o) => o > 1 || o < -1)) {
    const o = r.length;
    let h = 0;
    for (let l = 0; l < o; l++) {
      const d = Math.abs(r[l]);
      d > h && (h = d);
    }
    for (const l of a)
      for (let d = 0; d < o; d++)
        l[d] /= h;
  }
  return a;
}
function ca(a, r) {
  return typeof a[0] == "number" && (a = [a]), la(a), {
    duration: r,
    length: a[0].length,
    sampleRate: a[0].length / r,
    numberOfChannels: a.length,
    getChannelData: (o) => a == null ? void 0 : a[o],
    copyFromChannel: AudioBuffer.prototype.copyFromChannel,
    copyToChannel: AudioBuffer.prototype.copyToChannel
  };
}
const Io = {
  decode: ha,
  createBuffer: ca
};
var Oo = globalThis && globalThis.__awaiter || function(a, r, o, h) {
  function l(d) {
    return d instanceof o ? d : new o(function(u) {
      u(d);
    });
  }
  return new (o || (o = Promise))(function(d, u) {
    function p(y) {
      try {
        _(h.next(y));
      } catch (w) {
        u(w);
      }
    }
    function g(y) {
      try {
        _(h.throw(y));
      } catch (w) {
        u(w);
      }
    }
    function _(y) {
      y.done ? d(y.value) : l(y.value).then(p, g);
    }
    _((h = h.apply(a, r || [])).next());
  });
};
function ua(a, r, o) {
  var h, l;
  return Oo(this, void 0, void 0, function* () {
    const d = yield fetch(a, o);
    {
      const u = (h = d.clone().body) === null || h === void 0 ? void 0 : h.getReader(), p = Number((l = d.headers) === null || l === void 0 ? void 0 : l.get("Content-Length"));
      let g = 0;
      const _ = (y, w) => Oo(this, void 0, void 0, function* () {
        if (y)
          return;
        g += (w == null ? void 0 : w.length) || 0;
        const P = Math.round(g / p * 100);
        return r(P), u == null ? void 0 : u.read().then(({ done: E, value: C }) => _(E, C));
      });
      u == null || u.read().then(({ done: y, value: w }) => _(y, w));
    }
    return d.blob();
  });
}
const da = {
  fetchBlob: ua
};
class dn {
  constructor() {
    this.listeners = {};
  }
  /** Subscribe to an event. Returns an unsubscribe function. */
  on(r, o) {
    return this.listeners[r] || (this.listeners[r] = /* @__PURE__ */ new Set()), this.listeners[r].add(o), () => this.un(r, o);
  }
  /** Subscribe to an event only once */
  once(r, o) {
    const h = this.on(r, o), l = this.on(r, () => {
      h(), l();
    });
    return h;
  }
  /** Unsubscribe from an event */
  un(r, o) {
    this.listeners[r] && (o ? this.listeners[r].delete(o) : delete this.listeners[r]);
  }
  /** Clear all events */
  unAll() {
    this.listeners = {};
  }
  /** Emit an event */
  emit(r, ...o) {
    this.listeners[r] && this.listeners[r].forEach((h) => h(...o));
  }
}
class fa extends dn {
  constructor(r) {
    super(), r.media ? this.media = r.media : this.media = document.createElement("audio"), r.mediaControls && (this.media.controls = !0), r.autoplay && (this.media.autoplay = !0), r.playbackRate != null && this.onceMediaEvent("canplay", () => {
      r.playbackRate != null && (this.media.playbackRate = r.playbackRate);
    });
  }
  onMediaEvent(r, o, h) {
    return this.media.addEventListener(r, o, h), () => this.media.removeEventListener(r, o);
  }
  onceMediaEvent(r, o) {
    return this.onMediaEvent(r, o, { once: !0 });
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const r = this.getSrc();
    r.startsWith("blob:") && URL.revokeObjectURL(r);
  }
  setSrc(r, o) {
    if (this.getSrc() === r)
      return;
    this.revokeSrc();
    const l = o instanceof Blob ? URL.createObjectURL(o) : r;
    this.media.src = l, this.media.load();
  }
  destroy() {
    this.media.pause(), this.revokeSrc(), this.media.src = "", this.media.load();
  }
  /** Start playing the audio */
  play() {
    return this.media.play();
  }
  /** Pause the audio */
  pause() {
    this.media.pause();
  }
  /** Check if the audio is playing */
  isPlaying() {
    return this.media.currentTime > 0 && !this.media.paused && !this.media.ended;
  }
  /** Jumpt to a specific time in the audio (in seconds) */
  setTime(r) {
    this.media.currentTime = r;
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    return this.media.duration;
  }
  /** Get the current audio position in seconds */
  getCurrentTime() {
    return this.media.currentTime;
  }
  /** Get the audio volume */
  getVolume() {
    return this.media.volume;
  }
  /** Set the audio volume */
  setVolume(r) {
    this.media.volume = r;
  }
  /** Get the audio muted state */
  getMuted() {
    return this.media.muted;
  }
  /** Mute or unmute the audio */
  setMuted(r) {
    this.media.muted = r;
  }
  /** Get the playback speed */
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  /** Set the playback speed, pass an optional false to NOT preserve the pitch */
  setPlaybackRate(r, o) {
    o != null && (this.media.preservesPitch = o), this.media.playbackRate = r;
  }
  /** Get the HTML media element */
  getMediaElement() {
    return this.media;
  }
  /** Set a sink id to change the audio output device */
  setSinkId(r) {
    return this.media.setSinkId(r);
  }
}
function pa(a, r, o, h, l = 5) {
  let d = () => {
  };
  if (!a)
    return d;
  const u = (p) => {
    if (p.button === 2)
      return;
    p.preventDefault(), p.stopPropagation();
    let g = p.clientX, _ = p.clientY, y = !1;
    const w = (C) => {
      C.preventDefault(), C.stopPropagation();
      const x = C.clientX, R = C.clientY;
      if (y || Math.abs(x - g) >= l || Math.abs(R - _) >= l) {
        const { left: Z, top: S } = a.getBoundingClientRect();
        y || (y = !0, o == null || o(g - Z, _ - S)), r(x - g, R - _, x - Z, R - S), g = x, _ = R;
      }
    }, P = (C) => {
      y && (C.preventDefault(), C.stopPropagation());
    }, E = () => {
      y && (h == null || h()), d();
    };
    document.addEventListener("pointermove", w), document.addEventListener("pointerup", E), document.addEventListener("pointerleave", E), document.addEventListener("click", P, !0), d = () => {
      document.removeEventListener("pointermove", w), document.removeEventListener("pointerup", E), document.removeEventListener("pointerleave", E), setTimeout(() => {
        document.removeEventListener("click", P, !0);
      }, 10);
    };
  };
  return a.addEventListener("pointerdown", u), () => {
    d(), a.removeEventListener("pointerdown", u);
  };
}
class si extends dn {
  constructor(r, o) {
    super(), this.timeouts = [], this.isScrolling = !1, this.audioData = null, this.resizeObserver = null, this.isDragging = !1, this.options = r;
    let h;
    if (typeof r.container == "string" ? h = document.querySelector(r.container) : r.container instanceof HTMLElement && (h = r.container), !h)
      throw new Error("Container not found");
    this.parent = h;
    const [l, d] = this.initHtml();
    h.appendChild(l), this.container = l, this.scrollContainer = d.querySelector(".scroll"), this.wrapper = d.querySelector(".wrapper"), this.canvasWrapper = d.querySelector(".canvases"), this.progressWrapper = d.querySelector(".progress"), this.cursor = d.querySelector(".cursor"), o && d.appendChild(o), this.initEvents();
  }
  initEvents() {
    this.wrapper.addEventListener("click", (o) => {
      const h = this.wrapper.getBoundingClientRect(), d = (o.clientX - h.left) / h.width;
      this.emit("click", d);
    }), this.options.dragToSeek && this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const { scrollLeft: o, scrollWidth: h, clientWidth: l } = this.scrollContainer, d = o / h, u = (o + l) / h;
      this.emit("scroll", d, u);
    });
    const r = this.createDelay(100);
    this.resizeObserver = new ResizeObserver(() => {
      r(() => this.reRender());
    }), this.resizeObserver.observe(this.scrollContainer);
  }
  initDrag() {
    pa(
      this.wrapper,
      // On drag
      (r, o, h) => {
        this.emit("drag", Math.max(0, Math.min(1, h / this.wrapper.getBoundingClientRect().width)));
      },
      // On start drag
      () => this.isDragging = !0,
      // On end drag
      () => this.isDragging = !1
    );
  }
  getHeight() {
    return this.options.height == null ? 128 : isNaN(Number(this.options.height)) ? this.options.height === "auto" && this.parent.clientHeight || 128 : Number(this.options.height);
  }
  initHtml() {
    const r = document.createElement("div"), o = r.attachShadow({ mode: "open" });
    return o.innerHTML = `
      <style>
        :host {
          user-select: none;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
          touch-action: none;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight()}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper">
          <div class="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [r, o];
  }
  setOptions(r) {
    this.options = r, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  destroy() {
    var r;
    this.container.remove(), (r = this.resizeObserver) === null || r === void 0 || r.disconnect();
  }
  createDelay(r = 10) {
    const o = {};
    return this.timeouts.push(o), (h) => {
      o.timeout && clearTimeout(o.timeout), o.timeout = setTimeout(h, r);
    };
  }
  // Convert array of color values to linear gradient
  convertColorValues(r) {
    if (!Array.isArray(r))
      return r || "";
    if (r.length < 2)
      return r[0] || "";
    const o = document.createElement("canvas"), l = o.getContext("2d").createLinearGradient(0, 0, 0, o.height), d = 1 / (r.length - 1);
    return r.forEach((u, p) => {
      const g = p * d;
      l.addColorStop(g, u);
    }), l;
  }
  renderBarWaveform(r, o, h, l) {
    const d = r[0], u = r[1] || r[0], p = d.length, { width: g, height: _ } = h.canvas, y = _ / 2, w = window.devicePixelRatio || 1, P = o.barWidth ? o.barWidth * w : 1, E = o.barGap ? o.barGap * w : o.barWidth ? P / 2 : 0, C = o.barRadius || 0, x = g / (P + E) / p, R = C && "roundRect" in h ? "roundRect" : "rect";
    h.beginPath();
    let Z = 0, S = 0, B = 0;
    for (let G = 0; G <= p; G++) {
      const F = Math.round(G * x);
      if (F > Z) {
        const Y = Math.round(S * y * l), K = Math.round(B * y * l), vt = Y + K || 1;
        let Q = y - Y;
        o.barAlign === "top" ? Q = 0 : o.barAlign === "bottom" && (Q = _ - vt), h[R](Z * (P + E), Q, P, vt, C), Z = F, S = 0, B = 0;
      }
      const V = Math.abs(d[G] || 0), rt = Math.abs(u[G] || 0);
      V > S && (S = V), rt > B && (B = rt);
    }
    h.fill(), h.closePath();
  }
  renderLineWaveform(r, o, h, l) {
    const d = (u) => {
      const p = r[u] || r[0], g = p.length, { height: _ } = h.canvas, y = _ / 2, w = h.canvas.width / g;
      h.moveTo(0, y);
      let P = 0, E = 0;
      for (let C = 0; C <= g; C++) {
        const x = Math.round(C * w);
        if (x > P) {
          const Z = Math.round(E * y * l) || 1, S = y + Z * (u === 0 ? -1 : 1);
          h.lineTo(P, S), P = x, E = 0;
        }
        const R = Math.abs(p[C] || 0);
        R > E && (E = R);
      }
      h.lineTo(P, y);
    };
    h.beginPath(), d(0), d(1), h.fill(), h.closePath();
  }
  renderWaveform(r, o, h) {
    if (h.fillStyle = this.convertColorValues(o.waveColor), o.renderFunction) {
      o.renderFunction(r, h);
      return;
    }
    let l = o.barHeight || 1;
    if (o.normalize) {
      const d = Array.from(r[0]).reduce((u, p) => Math.max(u, Math.abs(p)), 0);
      l = d ? 1 / d : 1;
    }
    if (o.barWidth || o.barGap || o.barAlign) {
      this.renderBarWaveform(r, o, h, l);
      return;
    }
    this.renderLineWaveform(r, o, h, l);
  }
  renderSingleCanvas(r, o, h, l, d, u, p, g) {
    const _ = window.devicePixelRatio || 1, y = document.createElement("canvas"), w = r[0].length;
    y.width = Math.round(h * (u - d) / w), y.height = l * _, y.style.width = `${Math.floor(y.width / _)}px`, y.style.height = `${l}px`, y.style.left = `${Math.floor(d * h / _ / w)}px`, p.appendChild(y);
    const P = y.getContext("2d");
    this.renderWaveform(r.map((x) => x.slice(d, u)), o, P);
    const E = y.cloneNode();
    g.appendChild(E);
    const C = E.getContext("2d");
    y.width > 0 && y.height > 0 && C.drawImage(y, 0, 0), C.globalCompositeOperation = "source-in", C.fillStyle = this.convertColorValues(o.progressColor), C.fillRect(0, 0, y.width, y.height);
  }
  renderChannel(r, o, h) {
    const l = document.createElement("div"), d = this.getHeight();
    l.style.height = `${d}px`, this.canvasWrapper.style.minHeight = `${d}px`, this.canvasWrapper.appendChild(l);
    const u = l.cloneNode();
    this.progressWrapper.appendChild(u);
    const { scrollLeft: p, scrollWidth: g, clientWidth: _ } = this.scrollContainer, y = r[0].length, w = y / g;
    let P = Math.min(si.MAX_CANVAS_WIDTH, _);
    if (o.barWidth || o.barGap) {
      const F = o.barWidth || 0.5, V = o.barGap || F / 2, rt = F + V;
      P % rt !== 0 && (P = Math.floor(P / rt) * rt);
    }
    const E = Math.floor(Math.abs(p) * w), C = Math.floor(E + P * w), x = C - E, R = (F, V) => {
      this.renderSingleCanvas(r, o, h, d, Math.max(0, F), Math.min(V, y), l, u);
    }, Z = this.createDelay(), S = this.createDelay(), B = (F, V) => {
      R(F, V), F > 0 && Z(() => {
        B(F - x, V - x);
      });
    }, G = (F, V) => {
      R(F, V), V < y && S(() => {
        G(F + x, V + x);
      });
    };
    B(E, C), C < y && G(C, C + x);
  }
  render(r) {
    this.timeouts.forEach((p) => p.timeout && clearTimeout(p.timeout)), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", this.wrapper.style.width = "";
    const o = window.devicePixelRatio || 1, h = this.scrollContainer.clientWidth, l = Math.ceil(r.duration * (this.options.minPxPerSec || 0));
    this.isScrolling = l > h;
    const d = this.options.fillParent && !this.isScrolling, u = (d ? h : l) * o;
    if (this.wrapper.style.width = d ? "100%" : `${l}px`, this.scrollContainer.style.overflowX = this.isScrolling ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.options.splitChannels)
      for (let p = 0; p < r.numberOfChannels; p++) {
        const g = Object.assign(Object.assign({}, this.options), this.options.splitChannels[p]);
        this.renderChannel([r.getChannelData(p)], g, u);
      }
    else {
      const p = [r.getChannelData(0)];
      r.numberOfChannels > 1 && p.push(r.getChannelData(1)), this.renderChannel(p, this.options, u);
    }
    this.audioData = r, this.emit("render");
  }
  reRender() {
    if (!this.audioData)
      return;
    const r = this.progressWrapper.clientWidth;
    this.render(this.audioData);
    const o = this.progressWrapper.clientWidth;
    this.scrollContainer.scrollLeft += o - r;
  }
  zoom(r) {
    this.options.minPxPerSec = r, this.reRender();
  }
  scrollIntoView(r, o = !1) {
    const { clientWidth: h, scrollLeft: l, scrollWidth: d } = this.scrollContainer, u = d * r, p = h / 2, g = o && this.options.autoCenter && !this.isDragging ? p : h;
    if (u > l + g || u < l)
      if (this.options.autoCenter && !this.isDragging) {
        const _ = p / 20;
        u - (l + p) >= _ && u < l + h ? this.scrollContainer.scrollLeft += _ : this.scrollContainer.scrollLeft = u - p;
      } else
        this.isDragging ? this.scrollContainer.scrollLeft = u < l ? u - 10 : u - h + 10 : this.scrollContainer.scrollLeft = u;
    {
      const { scrollLeft: _ } = this.scrollContainer, y = _ / d, w = (_ + h) / d;
      this.emit("scroll", y, w);
    }
  }
  renderProgress(r, o) {
    isNaN(r) || (this.progressWrapper.style.width = `${r * 100}%`, this.cursor.style.left = `${r * 100}%`, this.cursor.style.marginLeft = Math.round(r * 100) === 100 ? `-${this.options.cursorWidth}px` : "", this.isScrolling && this.options.autoScroll && this.scrollIntoView(r, o));
  }
}
si.MAX_CANVAS_WIDTH = 4e3;
class ma extends dn {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
}
var Je = globalThis && globalThis.__awaiter || function(a, r, o, h) {
  function l(d) {
    return d instanceof o ? d : new o(function(u) {
      u(d);
    });
  }
  return new (o || (o = Promise))(function(d, u) {
    function p(y) {
      try {
        _(h.next(y));
      } catch (w) {
        u(w);
      }
    }
    function g(y) {
      try {
        _(h.throw(y));
      } catch (w) {
        u(w);
      }
    }
    function _(y) {
      y.done ? d(y.value) : l(y.value).then(p, g);
    }
    _((h = h.apply(a, r || [])).next());
  });
};
const ga = {
  waveColor: "#999",
  progressColor: "#555",
  cursorWidth: 1,
  minPxPerSec: 0,
  fillParent: !0,
  interact: !0,
  dragToSeek: !1,
  autoScroll: !0,
  autoCenter: !0,
  sampleRate: 8e3
};
class ai extends fa {
  /** Create a new WaveSurfer instance */
  static create(r) {
    return new ai(r);
  }
  /** Create a new WaveSurfer instance */
  constructor(r) {
    var o, h;
    super({
      media: r.media,
      mediaControls: r.mediaControls,
      autoplay: r.autoplay,
      playbackRate: r.audioRate
    }), this.plugins = [], this.decodedData = null, this.subscriptions = [], this.options = Object.assign({}, ga, r), this.timer = new ma();
    const l = r.media ? void 0 : this.getMediaElement();
    this.renderer = new si(this.options, l), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const d = this.options.url || ((o = this.options.media) === null || o === void 0 ? void 0 : o.currentSrc) || ((h = this.options.media) === null || h === void 0 ? void 0 : h.src);
    d && this.load(d, this.options.peaks, this.options.duration);
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      const r = this.getCurrentTime();
      this.renderer.renderProgress(r / this.getDuration(), !0), this.emit("timeupdate", r), this.emit("audioprocess", r);
    }));
  }
  initPlayerEvents() {
    this.subscriptions.push(this.onMediaEvent("timeupdate", () => {
      const r = this.getCurrentTime();
      this.renderer.renderProgress(r / this.getDuration(), this.isPlaying()), this.emit("timeupdate", r);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop();
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop();
    }), this.onMediaEvent("ended", () => {
      this.emit("finish");
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(
      // Seek on click
      this.renderer.on("click", (r) => {
        this.options.interact && (this.seekTo(r), this.emit("interaction", r * this.getDuration()), this.emit("click", r));
      }),
      // Scroll
      this.renderer.on("scroll", (r, o) => {
        const h = this.getDuration();
        this.emit("scroll", r * h, o * h);
      }),
      // Redraw
      this.renderer.on("render", () => {
        this.emit("redraw");
      })
    );
    {
      let r;
      this.subscriptions.push(this.renderer.on("drag", (o) => {
        this.options.interact && (this.renderer.renderProgress(o), clearTimeout(r), r = setTimeout(() => {
          this.seekTo(o);
        }, this.isPlaying() ? 0 : 200), this.emit("interaction", o * this.getDuration()), this.emit("drag", o));
      }));
    }
  }
  initPlugins() {
    var r;
    !((r = this.options.plugins) === null || r === void 0) && r.length && this.options.plugins.forEach((o) => {
      this.registerPlugin(o);
    });
  }
  /** Set new wavesurfer options and re-render it */
  setOptions(r) {
    this.options = Object.assign({}, this.options, r), this.renderer.setOptions(this.options), r.audioRate && this.setPlaybackRate(r.audioRate), r.mediaControls != null && (this.getMediaElement().controls = r.mediaControls);
  }
  /** Register a wavesurfer.js plugin */
  registerPlugin(r) {
    return r.init(this), this.plugins.push(r), this.subscriptions.push(r.once("destroy", () => {
      this.plugins = this.plugins.filter((o) => o !== r);
    })), r;
  }
  /** For plugins only: get the waveform wrapper div */
  getWrapper() {
    return this.renderer.getWrapper();
  }
  /** Get the current scroll position in pixels */
  getScroll() {
    return this.renderer.getScroll();
  }
  /** Get all registered plugins */
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(r, o, h, l) {
    return Je(this, void 0, void 0, function* () {
      if (this.emit("load", r), this.isPlaying() && this.pause(), this.decodedData = null, !o && !h) {
        const d = (u) => this.emit("loading", u);
        o = yield da.fetchBlob(r, d, this.options.fetchParams);
      }
      if (this.setSrc(r, o), h)
        l = (yield Promise.resolve(l || this.getDuration())) || (yield new Promise((d) => {
          this.onceMediaEvent("loadedmetadata", () => d(this.getDuration()));
        })) || (yield Promise.resolve(0)), this.decodedData = Io.createBuffer(h, l);
      else if (o) {
        const d = yield o.arrayBuffer();
        this.decodedData = yield Io.decode(d, this.options.sampleRate);
      }
      this.emit("decode", this.getDuration()), this.decodedData && this.renderer.render(this.decodedData), this.emit("ready", this.getDuration());
    });
  }
  /** Load an audio file by URL, with optional pre-decoded audio data */
  load(r, o, h) {
    return Je(this, void 0, void 0, function* () {
      yield this.loadAudio(r, void 0, o, h);
    });
  }
  /** Load an audio blob */
  loadBlob(r, o, h) {
    return Je(this, void 0, void 0, function* () {
      yield this.loadAudio("blob", r, o, h);
    });
  }
  /** Zoom the waveform by a given pixels-per-second factor */
  zoom(r) {
    if (!this.decodedData)
      throw new Error("No audio loaded");
    this.renderer.zoom(r), this.emit("zoom", r);
  }
  /** Get the decoded audio data */
  getDecodedData() {
    return this.decodedData;
  }
  /** Get decoded peaks */
  exportPeaks({ channels: r = 1, maxLength: o = 8e3, precision: h = 1e4 } = {}) {
    if (!this.decodedData)
      throw new Error("The audio has not been decoded yet");
    const l = Math.min(r, this.decodedData.numberOfChannels), d = [];
    for (let u = 0; u < l; u++) {
      const p = this.decodedData.getChannelData(u), g = Math.min(p.length, o), _ = p.length / g, y = [];
      for (let w = 0; w < g; w++) {
        const P = Math.round(w * _), E = p[P];
        y.push(Math.round(E * h) / h);
      }
      d.push(y);
    }
    return d;
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    let r = super.getDuration() || 0;
    return (r === 0 || r === 1 / 0) && this.decodedData && (r = this.decodedData.duration), r;
  }
  /** Toggle if the waveform should react to clicks */
  toggleInteraction(r) {
    this.options.interact = r;
  }
  /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */
  seekTo(r) {
    const o = this.getDuration() * r;
    this.setTime(o);
  }
  /** Play or pause the audio */
  playPause() {
    return Je(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  /** Stop the audio and go to the beginning */
  stop() {
    this.pause(), this.setTime(0);
  }
  /** Skip N or -N seconds from the current position */
  skip(r) {
    this.setTime(this.getCurrentTime() + r);
  }
  /** Empty the waveform by loading a tiny silent audio */
  empty() {
    this.load("", [[0]], 1e-3);
  }
  /** Unmount wavesurfer */
  destroy() {
    this.emit("destroy"), this.plugins.forEach((r) => r.destroy()), this.subscriptions.forEach((r) => r()), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
}
const Ji = `<svg fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" \r
	 viewBox="0 0 17.804 17.804" xml:space="preserve">\r
<g>\r
	<g id="c98_play">\r
		<path d="M2.067,0.043C2.21-0.028,2.372-0.008,2.493,0.085l13.312,8.503c0.094,0.078,0.154,0.191,0.154,0.313\r
			c0,0.12-0.061,0.237-0.154,0.314L2.492,17.717c-0.07,0.057-0.162,0.087-0.25,0.087l-0.176-0.04\r
			c-0.136-0.065-0.222-0.207-0.222-0.361V0.402C1.844,0.25,1.93,0.107,2.067,0.043z"/>\r
	</g>\r
	<g id="Capa_1_78_">\r
	</g>\r
</g>\r
</svg>`, va = '<?xml version="1.0" ?><svg fill="currentColor" style="color:currentColor;enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><path d="M224,435.8V76.1c0-6.7-5.4-12.1-12.2-12.1h-71.6c-6.8,0-12.2,5.4-12.2,12.1v359.7c0,6.7,5.4,12.2,12.2,12.2h71.6   C218.6,448,224,442.6,224,435.8z"/><path d="M371.8,64h-71.6c-6.7,0-12.2,5.4-12.2,12.1v359.7c0,6.7,5.4,12.2,12.2,12.2h71.6c6.7,0,12.2-5.4,12.2-12.2V76.1   C384,69.4,378.6,64,371.8,64z"/></g></svg>', Qo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAJ16AACdegHu2JUgAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAIABJREFUeJzs3XeYXVW9P/732u2UOdMzk0x6AkkIJQEChKqEoogFREQUEFBA5cv1ir39vnKvX6/9qhexdwHvpQpKlQsoIjUJvYWQRqa3zOm7rd8fk2CAJMyZ2fusfc5+v57HB5XZe3/mzDlnvffaqwBERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERHVCqC6AiMIlj/hwGzSxGBJLIcQcCDTAFy0Qfmb8B7QcNDkKiTwkNkPI5+DLF8QDvxxWXDoRhYgBgKjOyKM+tATQVwFYBcg3AWLGJM/UC4i/AeJuCHmP+PvPXwi0UCJSigGAqA7IlRfMhinOgsSHACwO5yrieQj8N3z8XvzjZ+vDuQYRVQsDAFENk0de9BYI+TkAq1C9z7MPKe+BwDfF/b/4S5WuSUQBYwAgqkFjh593ofTdzzSZqUVKCxF4GBJfE/f//GaldRBRxRgAiGpI/ogPHpQvuf9dlu7irlQjdE1TXdI4ib9C1y4W9/30GdWlENHEMAAQ1QB57HnJkazz24LnnO5LqTVaCbRYKdVlvZYNiO+gKfHv4rbLy6qLIaI9YwAgirjsyvP3LdqlO0q+OxsABARmNjRBExH9+EqsgfTfJx745YuqSyGi3YtI/yER7cq2w869dFup8NiOxh8AMpYV3cYfAAQOhq49Ko+84HTVpRDR7jEAEEXU4IqzrhgrF//Th2/u+P8EBBrNhMqyJkaiGUJcI4++6DLVpRDRrkX4NoIoniQgRg4568ac45wCyFf9u6RuoiPVoKiySRLyv/D32ZcKXOarLoWI/ok9AEQRIgExdMjZ9+Qc+3WNPwCkDXMXR0WcFB/Hkd0/lrzhIIoUBgCiCBlecfb1Baf85t39+1QtBgAAEPIiHH3BV1WXQUT/xABAFBHDK87+Ud613727f5/UzWgP/nsjUnxJHnXRJarLIKJxDABEETByyDnn5F37o7vq9t8hYRhVrCgs8gfyiI8cr7oKIuIzOSLl+lacu5fj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+zvP91tV17InpqYPZYR5RuOa39+tuhYi2jM+AiCqAW1rrvpzYUZnV9I0f60J4aqu57U0IbyUYV3jJr05bPyJagN7AIhqzMhhZy8v2d6vXd89UAq1n2EhpUwYxqNJIT7YtPoPz6mshYgqwwBAVKMGDv7ACk/K7zrSO7ra4wMEND+h6asTlvXx5od+82A1r01EwWAAIKpxA4e9b7F09S840n+n53vtYV7LENqgoet/Tkjna81rrn0xzGsRUbgYAIjqyNDBH3jr0JK9fm4NDM7RhkYA35vaCTUdfnsryp0dW6Y/t+G8Fj7fJ6obDABEdeaGNX3XAPK9etnGtDVPILNhM5K9/Uj0D0LkC4DrQrg2pDe+JL/QdUjDBAwdfiYDu6MdpRmdyC2ci4GDl8G3LADi2tMOnn6G2t+MiIJkqC6AiMLhJSz0HXEI+o44RHUpRBRBnAZIREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDHEAEBERBRDDABEREQxxABAREQUQwwAREREMcQAQEREFEMMAERERDEkVBdA4ZBSisFCoUvzrPlC+HMFZAcg2gHRLuFbQookBFKq66TgjRTdIxzPnx3kOU1de7k1ZTwQ5DkpIiSKUsiSgFYG5JCEHALEoJTaZl+3N05Lp3uEEFJ1mRQ8BoA60C1lOpVzDxHCO0z64gAILAOwFEBCdW1EVNskUBLAs5B4Epp8AlJ/JJcxHpkjRFF1bTQ1DAA1SEppjeZKR0mhnSSAYyFxEABTdV1EFBuOFFgD4F4h/dtbMsn7hRCO6qKoMgwANaJbynQ6Z58sgTMAvA1ARnVNRETbZSVwqwCuyWWs29g7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", ya = "data:image/png;base64,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", _a = "data:image/png;base64,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";
var $i = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function(a, r) {
  (function(o, h) {
    h(r);
  })(Zo, function(o) {
    var h = "1.9.4";
    function l(t) {
      var e, i, n, s;
      for (i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (e in s)
          t[e] = s[e];
      }
      return t;
    }
    var d = Object.create || function() {
      function t() {
      }
      return function(e) {
        return t.prototype = e, new t();
      };
    }();
    function u(t, e) {
      var i = Array.prototype.slice;
      if (t.bind)
        return t.bind.apply(t, i.call(arguments, 1));
      var n = i.call(arguments, 2);
      return function() {
        return t.apply(e, n.length ? n.concat(i.call(arguments)) : arguments);
      };
    }
    var p = 0;
    function g(t) {
      return "_leaflet_id" in t || (t._leaflet_id = ++p), t._leaflet_id;
    }
    function _(t, e, i) {
      var n, s, c, f;
      return f = function() {
        n = !1, s && (c.apply(i, s), s = !1);
      }, c = function() {
        n ? s = arguments : (t.apply(i, arguments), setTimeout(f, e), n = !0);
      }, c;
    }
    function y(t, e, i) {
      var n = e[1], s = e[0], c = n - s;
      return t === n && i ? t : ((t - s) % c + c) % c + s;
    }
    function w() {
      return !1;
    }
    function P(t, e) {
      if (e === !1)
        return t;
      var i = Math.pow(10, e === void 0 ? 6 : e);
      return Math.round(t * i) / i;
    }
    function E(t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
    }
    function C(t) {
      return E(t).split(/\s+/);
    }
    function x(t, e) {
      Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? d(t.options) : {});
      for (var i in e)
        t.options[i] = e[i];
      return t.options;
    }
    function R(t, e, i) {
      var n = [];
      for (var s in t)
        n.push(encodeURIComponent(i ? s.toUpperCase() : s) + "=" + encodeURIComponent(t[s]));
      return (!e || e.indexOf("?") === -1 ? "?" : "&") + n.join("&");
    }
    var Z = /\{ *([\w_ -]+) *\}/g;
    function S(t, e) {
      return t.replace(Z, function(i, n) {
        var s = e[n];
        if (s === void 0)
          throw new Error("No value provided for variable " + i);
        return typeof s == "function" && (s = s(e)), s;
      });
    }
    var B = Array.isArray || function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    };
    function G(t, e) {
      for (var i = 0; i < t.length; i++)
        if (t[i] === e)
          return i;
      return -1;
    }
    var F = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function V(t) {
      return window["webkit" + t] || window["moz" + t] || window["ms" + t];
    }
    var rt = 0;
    function Y(t) {
      var e = +/* @__PURE__ */ new Date(), i = Math.max(0, 16 - (e - rt));
      return rt = e + i, window.setTimeout(t, i);
    }
    var K = window.requestAnimationFrame || V("RequestAnimationFrame") || Y, vt = window.cancelAnimationFrame || V("CancelAnimationFrame") || V("CancelRequestAnimationFrame") || function(t) {
      window.clearTimeout(t);
    };
    function Q(t, e, i) {
      if (i && K === Y)
        t.call(e);
      else
        return K.call(window, u(t, e));
    }
    function it(t) {
      t && vt.call(window, t);
    }
    var lt = {
      __proto__: null,
      extend: l,
      create: d,
      bind: u,
      get lastId() {
        return p;
      },
      stamp: g,
      throttle: _,
      wrapNum: y,
      falseFn: w,
      formatNum: P,
      trim: E,
      splitWords: C,
      setOptions: x,
      getParamString: R,
      template: S,
      isArray: B,
      indexOf: G,
      emptyImageUrl: F,
      requestFn: K,
      cancelFn: vt,
      requestAnimFrame: Q,
      cancelAnimFrame: it
    };
    function J() {
    }
    J.extend = function(t) {
      var e = function() {
        x(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
      }, i = e.__super__ = this.prototype, n = d(i);
      n.constructor = e, e.prototype = n;
      for (var s in this)
        Object.prototype.hasOwnProperty.call(this, s) && s !== "prototype" && s !== "__super__" && (e[s] = this[s]);
      return t.statics && l(e, t.statics), t.includes && (ee(t.includes), l.apply(null, [n].concat(t.includes))), l(n, t), delete n.statics, delete n.includes, n.options && (n.options = i.options ? d(i.options) : {}, l(n.options, t.options)), n._initHooks = [], n.callInitHooks = function() {
        if (!this._initHooksCalled) {
          i.callInitHooks && i.callInitHooks.call(this), this._initHooksCalled = !0;
          for (var c = 0, f = n._initHooks.length; c < f; c++)
            n._initHooks[c].call(this);
        }
      }, e;
    }, J.include = function(t) {
      var e = this.prototype.options;
      return l(this.prototype, t), t.options && (this.prototype.options = e, this.mergeOptions(t.options)), this;
    }, J.mergeOptions = function(t) {
      return l(this.prototype.options, t), this;
    }, J.addInitHook = function(t) {
      var e = Array.prototype.slice.call(arguments, 1), i = typeof t == "function" ? t : function() {
        this[t].apply(this, e);
      };
      return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i), this;
    };
    function ee(t) {
      if (!(typeof L > "u" || !L || !L.Mixin)) {
        t = B(t) ? t : [t];
        for (var e = 0; e < t.length; e++)
          t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
      }
    }
    var $ = {
      /* @method on(type: String, fn: Function, context?: Object): this
       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
       *
       * @alternative
       * @method on(eventMap: Object): this
       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
       */
      on: function(t, e, i) {
        if (typeof t == "object")
          for (var n in t)
            this._on(n, t[n], e);
        else {
          t = C(t);
          for (var s = 0, c = t.length; s < c; s++)
            this._on(t[s], e, i);
        }
        return this;
      },
      /* @method off(type: String, fn?: Function, context?: Object): this
       * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
       *
       * @alternative
       * @method off(eventMap: Object): this
       * Removes a set of type/listener pairs.
       *
       * @alternative
       * @method off: this
       * Removes all listeners to all events on the object. This includes implicitly attached events.
       */
      off: function(t, e, i) {
        if (!arguments.length)
          delete this._events;
        else if (typeof t == "object")
          for (var n in t)
            this._off(n, t[n], e);
        else {
          t = C(t);
          for (var s = arguments.length === 1, c = 0, f = t.length; c < f; c++)
            s ? this._off(t[c]) : this._off(t[c], e, i);
        }
        return this;
      },
      // attach listener (without syntactic sugar now)
      _on: function(t, e, i, n) {
        if (typeof e != "function") {
          console.warn("wrong listener type: " + typeof e);
          return;
        }
        if (this._listens(t, e, i) === !1) {
          i === this && (i = void 0);
          var s = { fn: e, ctx: i };
          n && (s.once = !0), this._events = this._events || {}, this._events[t] = this._events[t] || [], this._events[t].push(s);
        }
      },
      _off: function(t, e, i) {
        var n, s, c;
        if (this._events && (n = this._events[t], !!n)) {
          if (arguments.length === 1) {
            if (this._firingCount)
              for (s = 0, c = n.length; s < c; s++)
                n[s].fn = w;
            delete this._events[t];
            return;
          }
          if (typeof e != "function") {
            console.warn("wrong listener type: " + typeof e);
            return;
          }
          var f = this._listens(t, e, i);
          if (f !== !1) {
            var m = n[f];
            this._firingCount && (m.fn = w, this._events[t] = n = n.slice()), n.splice(f, 1);
          }
        }
      },
      // @method fire(type: String, data?: Object, propagate?: Boolean): this
      // Fires an event of the specified type. You can optionally provide a data
      // object  the first argument of the listener function will contain its
      // properties. The event can optionally be propagated to event parents.
      fire: function(t, e, i) {
        if (!this.listens(t, i))
          return this;
        var n = l({}, e, {
          type: t,
          target: this,
          sourceTarget: e && e.sourceTarget || this
        });
        if (this._events) {
          var s = this._events[t];
          if (s) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var c = 0, f = s.length; c < f; c++) {
              var m = s[c], v = m.fn;
              m.once && this.off(t, v, m.ctx), v.call(m.ctx || this, n);
            }
            this._firingCount--;
          }
        }
        return i && this._propagateEvent(n), this;
      },
      // @method listens(type: String, propagate?: Boolean): Boolean
      // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
      // Returns `true` if a particular event type has any listeners attached to it.
      // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
      listens: function(t, e, i, n) {
        typeof t != "string" && console.warn('"string" type argument expected');
        var s = e;
        typeof e != "function" && (n = !!e, s = void 0, i = void 0);
        var c = this._events && this._events[t];
        if (c && c.length && this._listens(t, s, i) !== !1)
          return !0;
        if (n) {
          for (var f in this._eventParents)
            if (this._eventParents[f].listens(t, e, i, n))
              return !0;
        }
        return !1;
      },
      // returns the index (number) or false
      _listens: function(t, e, i) {
        if (!this._events)
          return !1;
        var n = this._events[t] || [];
        if (!e)
          return !!n.length;
        i === this && (i = void 0);
        for (var s = 0, c = n.length; s < c; s++)
          if (n[s].fn === e && n[s].ctx === i)
            return s;
        return !1;
      },
      // @method once(): this
      // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
      once: function(t, e, i) {
        if (typeof t == "object")
          for (var n in t)
            this._on(n, t[n], e, !0);
        else {
          t = C(t);
          for (var s = 0, c = t.length; s < c; s++)
            this._on(t[s], e, i, !0);
        }
        return this;
      },
      // @method addEventParent(obj: Evented): this
      // Adds an event parent - an `Evented` that will receive propagated events
      addEventParent: function(t) {
        return this._eventParents = this._eventParents || {}, this._eventParents[g(t)] = t, this;
      },
      // @method removeEventParent(obj: Evented): this
      // Removes an event parent, so it will stop receiving propagated events
      removeEventParent: function(t) {
        return this._eventParents && delete this._eventParents[g(t)], this;
      },
      _propagateEvent: function(t) {
        for (var e in this._eventParents)
          this._eventParents[e].fire(t.type, l({
            layer: t.target,
            propagatedFrom: t.target
          }, t), !0);
      }
    };
    $.addEventListener = $.on, $.removeEventListener = $.clearAllEventListeners = $.off, $.addOneTimeEventListener = $.once, $.fireEvent = $.fire, $.hasEventListeners = $.listens;
    var Ut = J.extend($);
    function O(t, e, i) {
      this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e;
    }
    var _n = Math.trunc || function(t) {
      return t > 0 ? Math.floor(t) : Math.ceil(t);
    };
    O.prototype = {
      // @method clone(): Point
      // Returns a copy of the current point.
      clone: function() {
        return new O(this.x, this.y);
      },
      // @method add(otherPoint: Point): Point
      // Returns the result of addition of the current and the given points.
      add: function(t) {
        return this.clone()._add(I(t));
      },
      _add: function(t) {
        return this.x += t.x, this.y += t.y, this;
      },
      // @method subtract(otherPoint: Point): Point
      // Returns the result of subtraction of the given point from the current.
      subtract: function(t) {
        return this.clone()._subtract(I(t));
      },
      _subtract: function(t) {
        return this.x -= t.x, this.y -= t.y, this;
      },
      // @method divideBy(num: Number): Point
      // Returns the result of division of the current point by the given number.
      divideBy: function(t) {
        return this.clone()._divideBy(t);
      },
      _divideBy: function(t) {
        return this.x /= t, this.y /= t, this;
      },
      // @method multiplyBy(num: Number): Point
      // Returns the result of multiplication of the current point by the given number.
      multiplyBy: function(t) {
        return this.clone()._multiplyBy(t);
      },
      _multiplyBy: function(t) {
        return this.x *= t, this.y *= t, this;
      },
      // @method scaleBy(scale: Point): Point
      // Multiply each coordinate of the current point by each coordinate of
      // `scale`. In linear algebra terms, multiply the point by the
      // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
      // defined by `scale`.
      scaleBy: function(t) {
        return new O(this.x * t.x, this.y * t.y);
      },
      // @method unscaleBy(scale: Point): Point
      // Inverse of `scaleBy`. Divide each coordinate of the current point by
      // each coordinate of `scale`.
      unscaleBy: function(t) {
        return new O(this.x / t.x, this.y / t.y);
      },
      // @method round(): Point
      // Returns a copy of the current point with rounded coordinates.
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      },
      // @method floor(): Point
      // Returns a copy of the current point with floored coordinates (rounded down).
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      },
      // @method ceil(): Point
      // Returns a copy of the current point with ceiled coordinates (rounded up).
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      },
      // @method trunc(): Point
      // Returns a copy of the current point with truncated coordinates (rounded towards zero).
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        return this.x = _n(this.x), this.y = _n(this.y), this;
      },
      // @method distanceTo(otherPoint: Point): Number
      // Returns the cartesian distance between the current and the given points.
      distanceTo: function(t) {
        t = I(t);
        var e = t.x - this.x, i = t.y - this.y;
        return Math.sqrt(e * e + i * i);
      },
      // @method equals(otherPoint: Point): Boolean
      // Returns `true` if the given point has the same coordinates.
      equals: function(t) {
        return t = I(t), t.x === this.x && t.y === this.y;
      },
      // @method contains(otherPoint: Point): Boolean
      // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
      contains: function(t) {
        return t = I(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y);
      },
      // @method toString(): String
      // Returns a string representation of the point for debugging purposes.
      toString: function() {
        return "Point(" + P(this.x) + ", " + P(this.y) + ")";
      }
    };
    function I(t, e, i) {
      return t instanceof O ? t : B(t) ? new O(t[0], t[1]) : t == null ? t : typeof t == "object" && "x" in t && "y" in t ? new O(t.x, t.y) : new O(t, e, i);
    }
    function tt(t, e) {
      if (t)
        for (var i = e ? [t, e] : t, n = 0, s = i.length; n < s; n++)
          this.extend(i[n]);
    }
    tt.prototype = {
      // @method extend(point: Point): this
      // Extends the bounds to contain the given point.
      // @alternative
      // @method extend(otherBounds: Bounds): this
      // Extend the bounds to contain the given bounds
      extend: function(t) {
        var e, i;
        if (!t)
          return this;
        if (t instanceof O || typeof t[0] == "number" || "x" in t)
          e = i = I(t);
        else if (t = pt(t), e = t.min, i = t.max, !e || !i)
          return this;
        return !this.min && !this.max ? (this.min = e.clone(), this.max = i.clone()) : (this.min.x = Math.min(e.x, this.min.x), this.max.x = Math.max(i.x, this.max.x), this.min.y = Math.min(e.y, this.min.y), this.max.y = Math.max(i.y, this.max.y)), this;
      },
      // @method getCenter(round?: Boolean): Point
      // Returns the center point of the bounds.
      getCenter: function(t) {
        return I(
          (this.min.x + this.max.x) / 2,
          (this.min.y + this.max.y) / 2,
          t
        );
      },
      // @method getBottomLeft(): Point
      // Returns the bottom-left point of the bounds.
      getBottomLeft: function() {
        return I(this.min.x, this.max.y);
      },
      // @method getTopRight(): Point
      // Returns the top-right point of the bounds.
      getTopRight: function() {
        return I(this.max.x, this.min.y);
      },
      // @method getTopLeft(): Point
      // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
      getTopLeft: function() {
        return this.min;
      },
      // @method getBottomRight(): Point
      // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
      getBottomRight: function() {
        return this.max;
      },
      // @method getSize(): Point
      // Returns the size of the given bounds
      getSize: function() {
        return this.max.subtract(this.min);
      },
      // @method contains(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains(point: Point): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(t) {
        var e, i;
        return typeof t[0] == "number" || t instanceof O ? t = I(t) : t = pt(t), t instanceof tt ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y;
      },
      // @method intersects(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds
      // intersect if they have at least one point in common.
      intersects: function(t) {
        t = pt(t);
        var e = this.min, i = this.max, n = t.min, s = t.max, c = s.x >= e.x && n.x <= i.x, f = s.y >= e.y && n.y <= i.y;
        return c && f;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds
      // overlap if their intersection is an area.
      overlaps: function(t) {
        t = pt(t);
        var e = this.min, i = this.max, n = t.min, s = t.max, c = s.x > e.x && n.x < i.x, f = s.y > e.y && n.y < i.y;
        return c && f;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this.min && this.max);
      },
      // @method pad(bufferRatio: Number): Bounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(t) {
        var e = this.min, i = this.max, n = Math.abs(e.x - i.x) * t, s = Math.abs(e.y - i.y) * t;
        return pt(
          I(e.x - n, e.y - s),
          I(i.x + n, i.y + s)
        );
      },
      // @method equals(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle is equivalent to the given bounds.
      equals: function(t) {
        return t ? (t = pt(t), this.min.equals(t.getTopLeft()) && this.max.equals(t.getBottomRight())) : !1;
      }
    };
    function pt(t, e) {
      return !t || t instanceof tt ? t : new tt(t, e);
    }
    function mt(t, e) {
      if (t)
        for (var i = e ? [t, e] : t, n = 0, s = i.length; n < s; n++)
          this.extend(i[n]);
    }
    mt.prototype = {
      // @method extend(latlng: LatLng): this
      // Extend the bounds to contain the given point
      // @alternative
      // @method extend(otherBounds: LatLngBounds): this
      // Extend the bounds to contain the given bounds
      extend: function(t) {
        var e = this._southWest, i = this._northEast, n, s;
        if (t instanceof W)
          n = t, s = t;
        else if (t instanceof mt) {
          if (n = t._southWest, s = t._northEast, !n || !s)
            return this;
        } else
          return t ? this.extend(U(t) || st(t)) : this;
        return !e && !i ? (this._southWest = new W(n.lat, n.lng), this._northEast = new W(s.lat, s.lng)) : (e.lat = Math.min(n.lat, e.lat), e.lng = Math.min(n.lng, e.lng), i.lat = Math.max(s.lat, i.lat), i.lng = Math.max(s.lng, i.lng)), this;
      },
      // @method pad(bufferRatio: Number): LatLngBounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(t) {
        var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, s = Math.abs(e.lng - i.lng) * t;
        return new mt(
          new W(e.lat - n, e.lng - s),
          new W(i.lat + n, i.lng + s)
        );
      },
      // @method getCenter(): LatLng
      // Returns the center point of the bounds.
      getCenter: function() {
        return new W(
          (this._southWest.lat + this._northEast.lat) / 2,
          (this._southWest.lng + this._northEast.lng) / 2
        );
      },
      // @method getSouthWest(): LatLng
      // Returns the south-west point of the bounds.
      getSouthWest: function() {
        return this._southWest;
      },
      // @method getNorthEast(): LatLng
      // Returns the north-east point of the bounds.
      getNorthEast: function() {
        return this._northEast;
      },
      // @method getNorthWest(): LatLng
      // Returns the north-west point of the bounds.
      getNorthWest: function() {
        return new W(this.getNorth(), this.getWest());
      },
      // @method getSouthEast(): LatLng
      // Returns the south-east point of the bounds.
      getSouthEast: function() {
        return new W(this.getSouth(), this.getEast());
      },
      // @method getWest(): Number
      // Returns the west longitude of the bounds
      getWest: function() {
        return this._southWest.lng;
      },
      // @method getSouth(): Number
      // Returns the south latitude of the bounds
      getSouth: function() {
        return this._southWest.lat;
      },
      // @method getEast(): Number
      // Returns the east longitude of the bounds
      getEast: function() {
        return this._northEast.lng;
      },
      // @method getNorth(): Number
      // Returns the north latitude of the bounds
      getNorth: function() {
        return this._northEast.lat;
      },
      // @method contains(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains (latlng: LatLng): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(t) {
        typeof t[0] == "number" || t instanceof W || "lat" in t ? t = U(t) : t = st(t);
        var e = this._southWest, i = this._northEast, n, s;
        return t instanceof mt ? (n = t.getSouthWest(), s = t.getNorthEast()) : n = s = t, n.lat >= e.lat && s.lat <= i.lat && n.lng >= e.lng && s.lng <= i.lng;
      },
      // @method intersects(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
      intersects: function(t) {
        t = st(t);
        var e = this._southWest, i = this._northEast, n = t.getSouthWest(), s = t.getNorthEast(), c = s.lat >= e.lat && n.lat <= i.lat, f = s.lng >= e.lng && n.lng <= i.lng;
        return c && f;
      },
      // @method overlaps(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
      overlaps: function(t) {
        t = st(t);
        var e = this._southWest, i = this._northEast, n = t.getSouthWest(), s = t.getNorthEast(), c = s.lat > e.lat && n.lat < i.lat, f = s.lng > e.lng && n.lng < i.lng;
        return c && f;
      },
      // @method toBBoxString(): String
      // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
      // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(t, e) {
        return t ? (t = st(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) : !1;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function st(t, e) {
      return t instanceof mt ? t : new mt(t, e);
    }
    function W(t, e, i) {
      if (isNaN(t) || isNaN(e))
        throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
      this.lat = +t, this.lng = +e, i !== void 0 && (this.alt = +i);
    }
    W.prototype = {
      // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
      // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(t, e) {
        if (!t)
          return !1;
        t = U(t);
        var i = Math.max(
          Math.abs(this.lat - t.lat),
          Math.abs(this.lng - t.lng)
        );
        return i <= (e === void 0 ? 1e-9 : e);
      },
      // @method toString(): String
      // Returns a string representation of the point (for debugging purposes).
      toString: function(t) {
        return "LatLng(" + P(this.lat, t) + ", " + P(this.lng, t) + ")";
      },
      // @method distanceTo(otherLatLng: LatLng): Number
      // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
      distanceTo: function(t) {
        return Dt.distance(this, U(t));
      },
      // @method wrap(): LatLng
      // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
      wrap: function() {
        return Dt.wrapLatLng(this);
      },
      // @method toBounds(sizeInMeters: Number): LatLngBounds
      // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
      toBounds: function(t) {
        var e = 180 * t / 40075017, i = e / Math.cos(Math.PI / 180 * this.lat);
        return st(
          [this.lat - e, this.lng - i],
          [this.lat + e, this.lng + i]
        );
      },
      clone: function() {
        return new W(this.lat, this.lng, this.alt);
      }
    };
    function U(t, e, i) {
      return t instanceof W ? t : B(t) && typeof t[0] != "object" ? t.length === 3 ? new W(t[0], t[1], t[2]) : t.length === 2 ? new W(t[0], t[1]) : null : t == null ? t : typeof t == "object" && "lat" in t ? new W(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : e === void 0 ? null : new W(t, e, i);
    }
    var Rt = {
      // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
      // Projects geographical coordinates into pixel coordinates for a given zoom.
      latLngToPoint: function(t, e) {
        var i = this.projection.project(t), n = this.scale(e);
        return this.transformation._transform(i, n);
      },
      // @method pointToLatLng(point: Point, zoom: Number): LatLng
      // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
      // zoom into geographical coordinates.
      pointToLatLng: function(t, e) {
        var i = this.scale(e), n = this.transformation.untransform(t, i);
        return this.projection.unproject(n);
      },
      // @method project(latlng: LatLng): Point
      // Projects geographical coordinates into coordinates in units accepted for
      // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
      project: function(t) {
        return this.projection.project(t);
      },
      // @method unproject(point: Point): LatLng
      // Given a projected coordinate returns the corresponding LatLng.
      // The inverse of `project`.
      unproject: function(t) {
        return this.projection.unproject(t);
      },
      // @method scale(zoom: Number): Number
      // Returns the scale used when transforming projected coordinates into
      // pixel coordinates for a particular zoom. For example, it returns
      // `256 * 2^zoom` for Mercator-based CRS.
      scale: function(t) {
        return 256 * Math.pow(2, t);
      },
      // @method zoom(scale: Number): Number
      // Inverse of `scale()`, returns the zoom level corresponding to a scale
      // factor of `scale`.
      zoom: function(t) {
        return Math.log(t / 256) / Math.LN2;
      },
      // @method getProjectedBounds(zoom: Number): Bounds
      // Returns the projection's bounds scaled and transformed for the provided `zoom`.
      getProjectedBounds: function(t) {
        if (this.infinite)
          return null;
        var e = this.projection.bounds, i = this.scale(t), n = this.transformation.transform(e.min, i), s = this.transformation.transform(e.max, i);
        return new tt(n, s);
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates.
      // @property code: String
      // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
      //
      // @property wrapLng: Number[]
      // An array of two numbers defining whether the longitude (horizontal) coordinate
      // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
      // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
      //
      // @property wrapLat: Number[]
      // Like `wrapLng`, but for the latitude (vertical) axis.
      // wrapLng: [min, max],
      // wrapLat: [min, max],
      // @property infinite: Boolean
      // If true, the coordinate space will be unbounded (infinite in both axes)
      infinite: !1,
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where lat and lng has been wrapped according to the
      // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
      wrapLatLng: function(t) {
        var e = this.wrapLng ? y(t.lng, this.wrapLng, !0) : t.lng, i = this.wrapLat ? y(t.lat, this.wrapLat, !0) : t.lat, n = t.alt;
        return new W(i, e, n);
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring
      // that its center is within the CRS's bounds.
      // Only accepts actual `L.LatLngBounds` instances, not arrays.
      wrapLatLngBounds: function(t) {
        var e = t.getCenter(), i = this.wrapLatLng(e), n = e.lat - i.lat, s = e.lng - i.lng;
        if (n === 0 && s === 0)
          return t;
        var c = t.getSouthWest(), f = t.getNorthEast(), m = new W(c.lat - n, c.lng - s), v = new W(f.lat - n, f.lng - s);
        return new mt(m, v);
      }
    }, Dt = l({}, Rt, {
      wrapLng: [-180, 180],
      // Mean Earth Radius, as recommended for use by
      // the International Union of Geodesy and Geophysics,
      // see https://rosettacode.org/wiki/Haversine_formula
      R: 6371e3,
      // distance between two geographical points using spherical law of cosines approximation
      distance: function(t, e) {
        var i = Math.PI / 180, n = t.lat * i, s = e.lat * i, c = Math.sin((e.lat - t.lat) * i / 2), f = Math.sin((e.lng - t.lng) * i / 2), m = c * c + Math.cos(n) * Math.cos(s) * f * f, v = 2 * Math.atan2(Math.sqrt(m), Math.sqrt(1 - m));
        return this.R * v;
      }
    }), bn = 6378137, li = {
      R: bn,
      MAX_LATITUDE: 85.0511287798,
      project: function(t) {
        var e = Math.PI / 180, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, t.lat), -i), s = Math.sin(n * e);
        return new O(
          this.R * t.lng * e,
          this.R * Math.log((1 + s) / (1 - s)) / 2
        );
      },
      unproject: function(t) {
        var e = 180 / Math.PI;
        return new W(
          (2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e,
          t.x * e / this.R
        );
      },
      bounds: function() {
        var t = bn * Math.PI;
        return new tt([-t, -t], [t, t]);
      }()
    };
    function ci(t, e, i, n) {
      if (B(t)) {
        this._a = t[0], this._b = t[1], this._c = t[2], this._d = t[3];
        return;
      }
      this._a = t, this._b = e, this._c = i, this._d = n;
    }
    ci.prototype = {
      // @method transform(point: Point, scale?: Number): Point
      // Returns a transformed point, optionally multiplied by the given scale.
      // Only accepts actual `L.Point` instances, not arrays.
      transform: function(t, e) {
        return this._transform(t.clone(), e);
      },
      // destructive transform (faster)
      _transform: function(t, e) {
        return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t;
      },
      // @method untransform(point: Point, scale?: Number): Point
      // Returns the reverse transformation of the given point, optionally divided
      // by the given scale. Only accepts actual `L.Point` instances, not arrays.
      untransform: function(t, e) {
        return e = e || 1, new O(
          (t.x / e - this._b) / this._a,
          (t.y / e - this._d) / this._c
        );
      }
    };
    function de(t, e, i, n) {
      return new ci(t, e, i, n);
    }
    var ui = l({}, Dt, {
      code: "EPSG:3857",
      projection: li,
      transformation: function() {
        var t = 0.5 / (Math.PI * li.R);
        return de(t, 0.5, -t, 0.5);
      }()
    }), ar = l({}, ui, {
      code: "EPSG:900913"
    });
    function wn(t) {
      return document.createElementNS("http://www.w3.org/2000/svg", t);
    }
    function xn(t, e) {
      var i = "", n, s, c, f, m, v;
      for (n = 0, c = t.length; n < c; n++) {
        for (m = t[n], s = 0, f = m.length; s < f; s++)
          v = m[s], i += (s ? "L" : "M") + v.x + " " + v.y;
        i += e ? T.svg ? "z" : "x" : "";
      }
      return i || "M0 0";
    }
    var di = document.documentElement.style, Se = "ActiveXObject" in window, hr = Se && !document.addEventListener, Cn = "msLaunchUri" in navigator && !("documentMode" in document), fi = Et("webkit"), An = Et("android"), En = Et("android 2") || Et("android 3"), lr = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), cr = An && Et("Google") && lr < 537 && !("AudioNode" in window), pi = !!window.opera, Pn = !Cn && Et("chrome"), Ln = Et("gecko") && !fi && !pi && !Se, ur = !Pn && Et("safari"), Tn = Et("phantom"), Sn = "OTransition" in di, dr = navigator.platform.indexOf("Win") === 0, Mn = Se && "transition" in di, mi = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !En, Rn = "MozPerspective" in di, fr = !window.L_DISABLE_3D && (Mn || mi || Rn) && !Sn && !Tn, fe = typeof orientation < "u" || Et("mobile"), pr = fe && fi, mr = fe && mi, kn = !window.PointerEvent && window.MSPointerEvent, Bn = !!(window.PointerEvent || kn), In = "ontouchstart" in window || !!window.TouchEvent, gr = !window.L_NO_TOUCH && (In || Bn), vr = fe && pi, yr = fe && Ln, _r = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, br = function() {
      var t = !1;
      try {
        var e = Object.defineProperty({}, "passive", {
          get: function() {
            t = !0;
          }
        });
        window.addEventListener("testPassiveEventSupport", w, e), window.removeEventListener("testPassiveEventSupport", w, e);
      } catch {
      }
      return t;
    }(), wr = function() {
      return !!document.createElement("canvas").getContext;
    }(), gi = !!(document.createElementNS && wn("svg").createSVGRect), xr = !!gi && function() {
      var t = document.createElement("div");
      return t.innerHTML = "<svg/>", (t.firstChild && t.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }(), Cr = !gi && function() {
      try {
        var t = document.createElement("div");
        t.innerHTML = '<v:shape adj="1"/>';
        var e = t.firstChild;
        return e.style.behavior = "url(#default#VML)", e && typeof e.adj == "object";
      } catch {
        return !1;
      }
    }(), Ar = navigator.platform.indexOf("Mac") === 0, Er = navigator.platform.indexOf("Linux") === 0;
    function Et(t) {
      return navigator.userAgent.toLowerCase().indexOf(t) >= 0;
    }
    var T = {
      ie: Se,
      ielt9: hr,
      edge: Cn,
      webkit: fi,
      android: An,
      android23: En,
      androidStock: cr,
      opera: pi,
      chrome: Pn,
      gecko: Ln,
      safari: ur,
      phantom: Tn,
      opera12: Sn,
      win: dr,
      ie3d: Mn,
      webkit3d: mi,
      gecko3d: Rn,
      any3d: fr,
      mobile: fe,
      mobileWebkit: pr,
      mobileWebkit3d: mr,
      msPointer: kn,
      pointer: Bn,
      touch: gr,
      touchNative: In,
      mobileOpera: vr,
      mobileGecko: yr,
      retina: _r,
      passiveEvents: br,
      canvas: wr,
      svg: gi,
      vml: Cr,
      inlineSvg: xr,
      mac: Ar,
      linux: Er
    }, On = T.msPointer ? "MSPointerDown" : "pointerdown", zn = T.msPointer ? "MSPointerMove" : "pointermove", Dn = T.msPointer ? "MSPointerUp" : "pointerup", Nn = T.msPointer ? "MSPointerCancel" : "pointercancel", vi = {
      touchstart: On,
      touchmove: zn,
      touchend: Dn,
      touchcancel: Nn
    }, Hn = {
      touchstart: Rr,
      touchmove: Me,
      touchend: Me,
      touchcancel: Me
    }, ie = {}, Zn = !1;
    function Pr(t, e, i) {
      return e === "touchstart" && Mr(), Hn[e] ? (i = Hn[e].bind(this, i), t.addEventListener(vi[e], i, !1), i) : (console.warn("wrong event specified:", e), w);
    }
    function Lr(t, e, i) {
      if (!vi[e]) {
        console.warn("wrong event specified:", e);
        return;
      }
      t.removeEventListener(vi[e], i, !1);
    }
    function Tr(t) {
      ie[t.pointerId] = t;
    }
    function Sr(t) {
      ie[t.pointerId] && (ie[t.pointerId] = t);
    }
    function Fn(t) {
      delete ie[t.pointerId];
    }
    function Mr() {
      Zn || (document.addEventListener(On, Tr, !0), document.addEventListener(zn, Sr, !0), document.addEventListener(Dn, Fn, !0), document.addEventListener(Nn, Fn, !0), Zn = !0);
    }
    function Me(t, e) {
      if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
        e.touches = [];
        for (var i in ie)
          e.touches.push(ie[i]);
        e.changedTouches = [e], t(e);
      }
    }
    function Rr(t, e) {
      e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && ut(e), Me(t, e);
    }
    function kr(t) {
      var e = {}, i, n;
      for (n in t)
        i = t[n], e[n] = i && i.bind ? i.bind(t) : i;
      return t = e, e.type = "dblclick", e.detail = 2, e.isTrusted = !1, e._simulated = !0, e;
    }
    var Br = 200;
    function Ir(t, e) {
      t.addEventListener("dblclick", e);
      var i = 0, n;
      function s(c) {
        if (c.detail !== 1) {
          n = c.detail;
          return;
        }
        if (!(c.pointerType === "mouse" || c.sourceCapabilities && !c.sourceCapabilities.firesTouchEvents)) {
          var f = Yn(c);
          if (!(f.some(function(v) {
            return v instanceof HTMLLabelElement && v.attributes.for;
          }) && !f.some(function(v) {
            return v instanceof HTMLInputElement || v instanceof HTMLSelectElement;
          }))) {
            var m = Date.now();
            m - i <= Br ? (n++, n === 2 && e(kr(c))) : n = 1, i = m;
          }
        }
      }
      return t.addEventListener("click", s), {
        dblclick: e,
        simDblclick: s
      };
    }
    function Or(t, e) {
      t.removeEventListener("dblclick", e.dblclick), t.removeEventListener("click", e.simDblclick);
    }
    var yi = Be(
      ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
    ), pe = Be(
      ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
    ), Un = pe === "webkitTransition" || pe === "OTransition" ? pe + "End" : "transitionend";
    function jn(t) {
      return typeof t == "string" ? document.getElementById(t) : t;
    }
    function me(t, e) {
      var i = t.style[e] || t.currentStyle && t.currentStyle[e];
      if ((!i || i === "auto") && document.defaultView) {
        var n = document.defaultView.getComputedStyle(t, null);
        i = n ? n[e] : null;
      }
      return i === "auto" ? null : i;
    }
    function q(t, e, i) {
      var n = document.createElement(t);
      return n.className = e || "", i && i.appendChild(n), n;
    }
    function et(t) {
      var e = t.parentNode;
      e && e.removeChild(t);
    }
    function Re(t) {
      for (; t.firstChild; )
        t.removeChild(t.firstChild);
    }
    function ne(t) {
      var e = t.parentNode;
      e && e.lastChild !== t && e.appendChild(t);
    }
    function oe(t) {
      var e = t.parentNode;
      e && e.firstChild !== t && e.insertBefore(t, e.firstChild);
    }
    function _i(t, e) {
      if (t.classList !== void 0)
        return t.classList.contains(e);
      var i = ke(t);
      return i.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(i);
    }
    function D(t, e) {
      if (t.classList !== void 0)
        for (var i = C(e), n = 0, s = i.length; n < s; n++)
          t.classList.add(i[n]);
      else if (!_i(t, e)) {
        var c = ke(t);
        bi(t, (c ? c + " " : "") + e);
      }
    }
    function nt(t, e) {
      t.classList !== void 0 ? t.classList.remove(e) : bi(t, E((" " + ke(t) + " ").replace(" " + e + " ", " ")));
    }
    function bi(t, e) {
      t.className.baseVal === void 0 ? t.className = e : t.className.baseVal = e;
    }
    function ke(t) {
      return t.correspondingElement && (t = t.correspondingElement), t.className.baseVal === void 0 ? t.className : t.className.baseVal;
    }
    function _t(t, e) {
      "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && zr(t, e);
    }
    function zr(t, e) {
      var i = !1, n = "DXImageTransform.Microsoft.Alpha";
      try {
        i = t.filters.item(n);
      } catch {
        if (e === 1)
          return;
      }
      e = Math.round(e * 100), i ? (i.Enabled = e !== 100, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")";
    }
    function Be(t) {
      for (var e = document.documentElement.style, i = 0; i < t.length; i++)
        if (t[i] in e)
          return t[i];
      return !1;
    }
    function jt(t, e, i) {
      var n = e || new O(0, 0);
      t.style[yi] = (T.ie3d ? "translate(" + n.x + "px," + n.y + "px)" : "translate3d(" + n.x + "px," + n.y + "px,0)") + (i ? " scale(" + i + ")" : "");
    }
    function at(t, e) {
      t._leaflet_pos = e, T.any3d ? jt(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px");
    }
    function qt(t) {
      return t._leaflet_pos || new O(0, 0);
    }
    var ge, ve, wi;
    if ("onselectstart" in document)
      ge = function() {
        z(window, "selectstart", ut);
      }, ve = function() {
        X(window, "selectstart", ut);
      };
    else {
      var ye = Be(
        ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
      );
      ge = function() {
        if (ye) {
          var t = document.documentElement.style;
          wi = t[ye], t[ye] = "none";
        }
      }, ve = function() {
        ye && (document.documentElement.style[ye] = wi, wi = void 0);
      };
    }
    function xi() {
      z(window, "dragstart", ut);
    }
    function Ci() {
      X(window, "dragstart", ut);
    }
    var Ie, Ai;
    function Ei(t) {
      for (; t.tabIndex === -1; )
        t = t.parentNode;
      t.style && (Oe(), Ie = t, Ai = t.style.outlineStyle, t.style.outlineStyle = "none", z(window, "keydown", Oe));
    }
    function Oe() {
      Ie && (Ie.style.outlineStyle = Ai, Ie = void 0, Ai = void 0, X(window, "keydown", Oe));
    }
    function qn(t) {
      do
        t = t.parentNode;
      while ((!t.offsetWidth || !t.offsetHeight) && t !== document.body);
      return t;
    }
    function Pi(t) {
      var e = t.getBoundingClientRect();
      return {
        x: e.width / t.offsetWidth || 1,
        y: e.height / t.offsetHeight || 1,
        boundingClientRect: e
      };
    }
    var Dr = {
      __proto__: null,
      TRANSFORM: yi,
      TRANSITION: pe,
      TRANSITION_END: Un,
      get: jn,
      getStyle: me,
      create: q,
      remove: et,
      empty: Re,
      toFront: ne,
      toBack: oe,
      hasClass: _i,
      addClass: D,
      removeClass: nt,
      setClass: bi,
      getClass: ke,
      setOpacity: _t,
      testProp: Be,
      setTransform: jt,
      setPosition: at,
      getPosition: qt,
      get disableTextSelection() {
        return ge;
      },
      get enableTextSelection() {
        return ve;
      },
      disableImageDrag: xi,
      enableImageDrag: Ci,
      preventOutline: Ei,
      restoreOutline: Oe,
      getSizedParentNode: qn,
      getScale: Pi
    };
    function z(t, e, i, n) {
      if (e && typeof e == "object")
        for (var s in e)
          Ti(t, s, e[s], i);
      else {
        e = C(e);
        for (var c = 0, f = e.length; c < f; c++)
          Ti(t, e[c], i, n);
      }
      return this;
    }
    var Pt = "_leaflet_events";
    function X(t, e, i, n) {
      if (arguments.length === 1)
        Vn(t), delete t[Pt];
      else if (e && typeof e == "object")
        for (var s in e)
          Si(t, s, e[s], i);
      else if (e = C(e), arguments.length === 2)
        Vn(t, function(m) {
          return G(e, m) !== -1;
        });
      else
        for (var c = 0, f = e.length; c < f; c++)
          Si(t, e[c], i, n);
      return this;
    }
    function Vn(t, e) {
      for (var i in t[Pt]) {
        var n = i.split(/\d/)[0];
        (!e || e(n)) && Si(t, n, null, null, i);
      }
    }
    var Li = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function Ti(t, e, i, n) {
      var s = e + g(i) + (n ? "_" + g(n) : "");
      if (t[Pt] && t[Pt][s])
        return this;
      var c = function(m) {
        return i.call(n || t, m || window.event);
      }, f = c;
      !T.touchNative && T.pointer && e.indexOf("touch") === 0 ? c = Pr(t, e, c) : T.touch && e === "dblclick" ? c = Ir(t, c) : "addEventListener" in t ? e === "touchstart" || e === "touchmove" || e === "wheel" || e === "mousewheel" ? t.addEventListener(Li[e] || e, c, T.passiveEvents ? { passive: !1 } : !1) : e === "mouseenter" || e === "mouseleave" ? (c = function(m) {
        m = m || window.event, Ri(t, m) && f(m);
      }, t.addEventListener(Li[e], c, !1)) : t.addEventListener(e, f, !1) : t.attachEvent("on" + e, c), t[Pt] = t[Pt] || {}, t[Pt][s] = c;
    }
    function Si(t, e, i, n, s) {
      s = s || e + g(i) + (n ? "_" + g(n) : "");
      var c = t[Pt] && t[Pt][s];
      if (!c)
        return this;
      !T.touchNative && T.pointer && e.indexOf("touch") === 0 ? Lr(t, e, c) : T.touch && e === "dblclick" ? Or(t, c) : "removeEventListener" in t ? t.removeEventListener(Li[e] || e, c, !1) : t.detachEvent("on" + e, c), t[Pt][s] = null;
    }
    function Vt(t) {
      return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, this;
    }
    function Mi(t) {
      return Ti(t, "wheel", Vt), this;
    }
    function _e(t) {
      return z(t, "mousedown touchstart dblclick contextmenu", Vt), t._leaflet_disable_click = !0, this;
    }
    function ut(t) {
      return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;
    }
    function Yt(t) {
      return ut(t), Vt(t), this;
    }
    function Yn(t) {
      if (t.composedPath)
        return t.composedPath();
      for (var e = [], i = t.target; i; )
        e.push(i), i = i.parentNode;
      return e;
    }
    function Wn(t, e) {
      if (!e)
        return new O(t.clientX, t.clientY);
      var i = Pi(e), n = i.boundingClientRect;
      return new O(
        // offset.left/top values are in page scale (like clientX/Y),
        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
        (t.clientX - n.left) / i.x - e.clientLeft,
        (t.clientY - n.top) / i.y - e.clientTop
      );
    }
    var Nr = T.linux && T.chrome ? window.devicePixelRatio : T.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
    function Gn(t) {
      return T.edge ? t.wheelDeltaY / 2 : (
        // Don't trust window-geometry-based delta
        t.deltaY && t.deltaMode === 0 ? -t.deltaY / Nr : (
          // Pixels
          t.deltaY && t.deltaMode === 1 ? -t.deltaY * 20 : (
            // Lines
            t.deltaY && t.deltaMode === 2 ? -t.deltaY * 60 : (
              // Pages
              t.deltaX || t.deltaZ ? 0 : (
                // Skip horizontal/depth wheel events
                t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : (
                  // Legacy IE pixels
                  t.detail && Math.abs(t.detail) < 32765 ? -t.detail * 20 : (
                    // Legacy Moz lines
                    t.detail ? t.detail / -32765 * 60 : (
                      // Legacy Moz pages
                      0
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
    function Ri(t, e) {
      var i = e.relatedTarget;
      if (!i)
        return !0;
      try {
        for (; i && i !== t; )
          i = i.parentNode;
      } catch {
        return !1;
      }
      return i !== t;
    }
    var Hr = {
      __proto__: null,
      on: z,
      off: X,
      stopPropagation: Vt,
      disableScrollPropagation: Mi,
      disableClickPropagation: _e,
      preventDefault: ut,
      stop: Yt,
      getPropagationPath: Yn,
      getMousePosition: Wn,
      getWheelDelta: Gn,
      isExternalTarget: Ri,
      addListener: z,
      removeListener: X
    }, Xn = Ut.extend({
      // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
      // Run an animation of a given element to a new position, optionally setting
      // duration in seconds (`0.25` by default) and easing linearity factor (3rd
      // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
      // `0.5` by default).
      run: function(t, e, i, n) {
        this.stop(), this._el = t, this._inProgress = !0, this._duration = i || 0.25, this._easeOutPower = 1 / Math.max(n || 0.5, 0.2), this._startPos = qt(t), this._offset = e.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
      },
      // @method stop()
      // Stops the animation (if currently running).
      stop: function() {
        this._inProgress && (this._step(!0), this._complete());
      },
      _animate: function() {
        this._animId = Q(this._animate, this), this._step();
      },
      _step: function(t) {
        var e = +/* @__PURE__ */ new Date() - this._startTime, i = this._duration * 1e3;
        e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1), this._complete());
      },
      _runFrame: function(t, e) {
        var i = this._startPos.add(this._offset.multiplyBy(t));
        e && i._round(), at(this._el, i), this.fire("step");
      },
      _complete: function() {
        it(this._animId), this._inProgress = !1, this.fire("end");
      },
      _easeOut: function(t) {
        return 1 - Math.pow(1 - t, this._easeOutPower);
      }
    }), j = Ut.extend({
      options: {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: ui,
        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: void 0,
        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: void 0,
        // @option minZoom: Number = *
        // Minimum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the lowest of their `minZoom` options will be used instead.
        minZoom: void 0,
        // @option maxZoom: Number = *
        // Maximum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the highest of their `maxZoom` options will be used instead.
        maxZoom: void 0,
        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],
        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back if the user tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: void 0,
        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: void 0,
        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: !0,
        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,
        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: !0,
        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: !0,
        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608,
        // Precision limit of a 32-bit float
        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 1,
        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 1,
        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: !0
      },
      initialize: function(t, e) {
        e = x(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = u(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.zoom !== void 0 && (this._zoom = this._limitZoom(e.zoom)), e.center && e.zoom !== void 0 && this.setView(U(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = pe && T.any3d && !T.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), z(this._proxy, Un, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
      },
      // @section Methods for modifying map state
      // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) with the given
      // animation options.
      setView: function(t, e, i) {
        if (e = e === void 0 ? this._zoom : this._limitZoom(e), t = this._limitCenter(U(t), e, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && i !== !0) {
          i.animate !== void 0 && (i.zoom = l({ animate: i.animate }, i.zoom), i.pan = l({ animate: i.animate, duration: i.duration }, i.pan));
          var n = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan);
          if (n)
            return clearTimeout(this._sizeTimer), this;
        }
        return this._resetView(t, e, i.pan && i.pan.noMoveStart), this;
      },
      // @method setZoom(zoom: Number, options?: Zoom/pan options): this
      // Sets the zoom of the map.
      setZoom: function(t, e) {
        return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this);
      },
      // @method zoomIn(delta?: Number, options?: Zoom options): this
      // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomIn: function(t, e) {
        return t = t || (T.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e);
      },
      // @method zoomOut(delta?: Number, options?: Zoom options): this
      // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomOut: function(t, e) {
        return t = t || (T.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e);
      },
      // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified geographical point on the map
      // stationary (e.g. used internally for scroll zoom and double-click zoom).
      // @alternative
      // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
      setZoomAround: function(t, e, i) {
        var n = this.getZoomScale(e), s = this.getSize().divideBy(2), c = t instanceof O ? t : this.latLngToContainerPoint(t), f = c.subtract(s).multiplyBy(1 - 1 / n), m = this.containerPointToLatLng(s.add(f));
        return this.setView(m, e, { zoom: i });
      },
      _getBoundsCenterZoom: function(t, e) {
        e = e || {}, t = t.getBounds ? t.getBounds() : st(t);
        var i = I(e.paddingTopLeft || e.padding || [0, 0]), n = I(e.paddingBottomRight || e.padding || [0, 0]), s = this.getBoundsZoom(t, !1, i.add(n));
        if (s = typeof e.maxZoom == "number" ? Math.min(e.maxZoom, s) : s, s === 1 / 0)
          return {
            center: t.getCenter(),
            zoom: s
          };
        var c = n.subtract(i).divideBy(2), f = this.project(t.getSouthWest(), s), m = this.project(t.getNorthEast(), s), v = this.unproject(f.add(m).divideBy(2).add(c), s);
        return {
          center: v,
          zoom: s
        };
      },
      // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets a map view that contains the given geographical bounds with the
      // maximum zoom level possible.
      fitBounds: function(t, e) {
        if (t = st(t), !t.isValid())
          throw new Error("Bounds are not valid.");
        var i = this._getBoundsCenterZoom(t, e);
        return this.setView(i.center, i.zoom, e);
      },
      // @method fitWorld(options?: fitBounds options): this
      // Sets a map view that mostly contains the whole world with the maximum
      // zoom level possible.
      fitWorld: function(t) {
        return this.fitBounds([[-90, -180], [90, 180]], t);
      },
      // @method panTo(latlng: LatLng, options?: Pan options): this
      // Pans the map to a given center.
      panTo: function(t, e) {
        return this.setView(t, this._zoom, { pan: e });
      },
      // @method panBy(offset: Point, options?: Pan options): this
      // Pans the map by a given number of pixels (animated).
      panBy: function(t, e) {
        if (t = I(t).round(), e = e || {}, !t.x && !t.y)
          return this.fire("moveend");
        if (e.animate !== !0 && !this.getSize().contains(t))
          return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this;
        if (this._panAnim || (this._panAnim = new Xn(), this._panAnim.on({
          step: this._onPanTransitionStep,
          end: this._onPanTransitionEnd
        }, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
          D(this._mapPane, "leaflet-pan-anim");
          var i = this._getMapPanePos().subtract(t).round();
          this._panAnim.run(this._mapPane, i, e.duration || 0.25, e.easeLinearity);
        } else
          this._rawPanBy(t), this.fire("move").fire("moveend");
        return this;
      },
      // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) performing a smooth
      // pan-zoom animation.
      flyTo: function(t, e, i) {
        if (i = i || {}, i.animate === !1 || !T.any3d)
          return this.setView(t, e, i);
        this._stop();
        var n = this.project(this.getCenter()), s = this.project(t), c = this.getSize(), f = this._zoom;
        t = U(t), e = e === void 0 ? f : e;
        var m = Math.max(c.x, c.y), v = m * this.getZoomScale(f, e), b = s.distanceTo(n) || 1, A = 1.42, M = A * A;
        function N(ht) {
          var We = ht ? -1 : 1, Ls = ht ? v : m, Ts = v * v - m * m + We * M * M * b * b, Ss = 2 * Ls * M * b, Ui = Ts / Ss, Mo = Math.sqrt(Ui * Ui + 1) - Ui, Ms = Mo < 1e-9 ? -18 : Math.log(Mo);
          return Ms;
        }
        function ft(ht) {
          return (Math.exp(ht) - Math.exp(-ht)) / 2;
        }
        function ct(ht) {
          return (Math.exp(ht) + Math.exp(-ht)) / 2;
        }
        function wt(ht) {
          return ft(ht) / ct(ht);
        }
        var gt = N(0);
        function ce(ht) {
          return m * (ct(gt) / ct(gt + A * ht));
        }
        function Cs(ht) {
          return m * (ct(gt) * wt(gt + A * ht) - ft(gt)) / M;
        }
        function As(ht) {
          return 1 - Math.pow(1 - ht, 1.5);
        }
        var Es = Date.now(), To = (N(1) - gt) / A, Ps = i.duration ? 1e3 * i.duration : 1e3 * To * 0.8;
        function So() {
          var ht = (Date.now() - Es) / Ps, We = As(ht) * To;
          ht <= 1 ? (this._flyToFrame = Q(So, this), this._move(
            this.unproject(n.add(s.subtract(n).multiplyBy(Cs(We) / b)), f),
            this.getScaleZoom(m / ce(We), f),
            { flyTo: !0 }
          )) : this._move(t, e)._moveEnd(!0);
        }
        return this._moveStart(!0, i.noMoveStart), So.call(this), this;
      },
      // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
      // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
      flyToBounds: function(t, e) {
        var i = this._getBoundsCenterZoom(t, e);
        return this.flyTo(i.center, i.zoom, e);
      },
      // @method setMaxBounds(bounds: LatLngBounds): this
      // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
      setMaxBounds: function(t) {
        return t = st(t), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), t.isValid() ? (this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
      },
      // @method setMinZoom(zoom: Number): this
      // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
      setMinZoom: function(t) {
        var e = this.options.minZoom;
        return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this;
      },
      // @method setMaxZoom(zoom: Number): this
      // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
      setMaxZoom: function(t) {
        var e = this.options.maxZoom;
        return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this;
      },
      // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
      // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
      panInsideBounds: function(t, e) {
        this._enforcingBounds = !0;
        var i = this.getCenter(), n = this._limitCenter(i, this._zoom, st(t));
        return i.equals(n) || this.panTo(n, e), this._enforcingBounds = !1, this;
      },
      // @method panInside(latlng: LatLng, options?: padding options): this
      // Pans the map the minimum amount to make the `latlng` visible. Use
      // padding options to fit the display to more restricted bounds.
      // If `latlng` is already within the (optionally padded) display bounds,
      // the map will not be panned.
      panInside: function(t, e) {
        e = e || {};
        var i = I(e.paddingTopLeft || e.padding || [0, 0]), n = I(e.paddingBottomRight || e.padding || [0, 0]), s = this.project(this.getCenter()), c = this.project(t), f = this.getPixelBounds(), m = pt([f.min.add(i), f.max.subtract(n)]), v = m.getSize();
        if (!m.contains(c)) {
          this._enforcingBounds = !0;
          var b = c.subtract(m.getCenter()), A = m.extend(c).getSize().subtract(v);
          s.x += b.x < 0 ? -A.x : A.x, s.y += b.y < 0 ? -A.y : A.y, this.panTo(this.unproject(s), e), this._enforcingBounds = !1;
        }
        return this;
      },
      // @method invalidateSize(options: Zoom/pan options): this
      // Checks if the map container size changed and updates the map if so 
      // call it after you've changed the map size dynamically, also animating
      // pan by default. If `options.pan` is `false`, panning will not occur.
      // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
      // that it doesn't happen often even if the method is called many
      // times in a row.
      // @alternative
      // @method invalidateSize(animate: Boolean): this
      // Checks if the map container size changed and updates the map if so 
      // call it after you've changed the map size dynamically, also animating
      // pan by default.
      invalidateSize: function(t) {
        if (!this._loaded)
          return this;
        t = l({
          animate: !1,
          pan: !0
        }, t === !0 ? { animate: !0 } : t);
        var e = this.getSize();
        this._sizeChanged = !0, this._lastCenter = null;
        var i = this.getSize(), n = e.divideBy(2).round(), s = i.divideBy(2).round(), c = n.subtract(s);
        return !c.x && !c.y ? this : (t.animate && t.pan ? this.panBy(c) : (t.pan && this._rawPanBy(c), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(u(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
          oldSize: e,
          newSize: i
        }));
      },
      // @section Methods for modifying map state
      // @method stop(): this
      // Stops the currently running `panTo` or `flyTo` animation, if any.
      stop: function() {
        return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
      },
      // @section Geolocation methods
      // @method locate(options?: Locate options): this
      // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
      // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
      // and optionally sets the map view to the user's location with respect to
      // detection accuracy (or to the world view if geolocation failed).
      // Note that, if your page doesn't use HTTPS, this method will fail in
      // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
      // See `Locate options` for more details.
      locate: function(t) {
        if (t = this._locateOptions = l({
          timeout: 1e4,
          watch: !1
          // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false
        }, t), !("geolocation" in navigator))
          return this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          }), this;
        var e = u(this._handleGeolocationResponse, this), i = u(this._handleGeolocationError, this);
        return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this;
      },
      // @method stopLocate(): this
      // Stops watching location previously initiated by `map.locate({watch: true})`
      // and aborts resetting the map view if map.locate was called with
      // `{setView: true}`.
      stopLocate: function() {
        return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
      },
      _handleGeolocationError: function(t) {
        if (this._container._leaflet_id) {
          var e = t.code, i = t.message || (e === 1 ? "permission denied" : e === 2 ? "position unavailable" : "timeout");
          this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
            code: e,
            message: "Geolocation error: " + i + "."
          });
        }
      },
      _handleGeolocationResponse: function(t) {
        if (this._container._leaflet_id) {
          var e = t.coords.latitude, i = t.coords.longitude, n = new W(e, i), s = n.toBounds(t.coords.accuracy * 2), c = this._locateOptions;
          if (c.setView) {
            var f = this.getBoundsZoom(s);
            this.setView(n, c.maxZoom ? Math.min(f, c.maxZoom) : f);
          }
          var m = {
            latlng: n,
            bounds: s,
            timestamp: t.timestamp
          };
          for (var v in t.coords)
            typeof t.coords[v] == "number" && (m[v] = t.coords[v]);
          this.fire("locationfound", m);
        }
      },
      // TODO Appropriate docs section?
      // @section Other Methods
      // @method addHandler(name: String, HandlerClass: Function): this
      // Adds a new `Handler` to the map, given its name and constructor function.
      addHandler: function(t, e) {
        if (!e)
          return this;
        var i = this[t] = new e(this);
        return this._handlers.push(i), this.options[t] && i.enable(), this;
      },
      // @method remove(): this
      // Destroys the map and clears all related event listeners.
      remove: function() {
        if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
          throw new Error("Map container is being reused by another instance");
        try {
          delete this._container._leaflet_id, delete this._containerId;
        } catch {
          this._container._leaflet_id = void 0, this._containerId = void 0;
        }
        this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), et(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (it(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
        var t;
        for (t in this._layers)
          this._layers[t].remove();
        for (t in this._panes)
          et(this._panes[t]);
        return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
      },
      // @section Other Methods
      // @method createPane(name: String, container?: HTMLElement): HTMLElement
      // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
      // then returns it. The pane is created as a child of `container`, or
      // as a child of the main map pane if not set.
      createPane: function(t, e) {
        var i = "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), n = q("div", i, e || this._mapPane);
        return t && (this._panes[t] = n), n;
      },
      // @section Methods for Getting Map State
      // @method getCenter(): LatLng
      // Returns the geographical center of the map view
      getCenter: function() {
        return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      // @method getZoom(): Number
      // Returns the current zoom level of the map view
      getZoom: function() {
        return this._zoom;
      },
      // @method getBounds(): LatLngBounds
      // Returns the geographical bounds visible in the current map view
      getBounds: function() {
        var t = this.getPixelBounds(), e = this.unproject(t.getBottomLeft()), i = this.unproject(t.getTopRight());
        return new mt(e, i);
      },
      // @method getMinZoom(): Number
      // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      // @method getMaxZoom(): Number
      // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
      },
      // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
      // Returns the maximum zoom level on which the given bounds fit to the map
      // view in its entirety. If `inside` (optional) is set to `true`, the method
      // instead returns the minimum zoom level on which the map view fits into
      // the given bounds in its entirety.
      getBoundsZoom: function(t, e, i) {
        t = st(t), i = I(i || [0, 0]);
        var n = this.getZoom() || 0, s = this.getMinZoom(), c = this.getMaxZoom(), f = t.getNorthWest(), m = t.getSouthEast(), v = this.getSize().subtract(i), b = pt(this.project(m, n), this.project(f, n)).getSize(), A = T.any3d ? this.options.zoomSnap : 1, M = v.x / b.x, N = v.y / b.y, ft = e ? Math.max(M, N) : Math.min(M, N);
        return n = this.getScaleZoom(ft, n), A && (n = Math.round(n / (A / 100)) * (A / 100), n = e ? Math.ceil(n / A) * A : Math.floor(n / A) * A), Math.max(s, Math.min(c, n));
      },
      // @method getSize(): Point
      // Returns the current size of the map container (in pixels).
      getSize: function() {
        return (!this._size || this._sizeChanged) && (this._size = new O(
          this._container.clientWidth || 0,
          this._container.clientHeight || 0
        ), this._sizeChanged = !1), this._size.clone();
      },
      // @method getPixelBounds(): Bounds
      // Returns the bounds of the current map view in projected pixel
      // coordinates (sometimes useful in layer and overlay implementations).
      getPixelBounds: function(t, e) {
        var i = this._getTopLeftPoint(t, e);
        return new tt(i, i.add(this.getSize()));
      },
      // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
      // the map pane? "left point of the map layer" can be confusing, specially
      // since there can be negative offsets.
      // @method getPixelOrigin(): Point
      // Returns the projected pixel coordinates of the top left point of
      // the map layer (useful in custom layer and overlay implementations).
      getPixelOrigin: function() {
        return this._checkIfLoaded(), this._pixelOrigin;
      },
      // @method getPixelWorldBounds(zoom?: Number): Bounds
      // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
      // If `zoom` is omitted, the map's current zoom level is used.
      getPixelWorldBounds: function(t) {
        return this.options.crs.getProjectedBounds(t === void 0 ? this.getZoom() : t);
      },
      // @section Other Methods
      // @method getPane(pane: String|HTMLElement): HTMLElement
      // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
      getPane: function(t) {
        return typeof t == "string" ? this._panes[t] : t;
      },
      // @method getPanes(): Object
      // Returns a plain object containing the names of all [panes](#map-pane) as keys and
      // the panes as values.
      getPanes: function() {
        return this._panes;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the map.
      getContainer: function() {
        return this._container;
      },
      // @section Conversion Methods
      // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
      // Returns the scale factor to be applied to a map transition from zoom level
      // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
      getZoomScale: function(t, e) {
        var i = this.options.crs;
        return e = e === void 0 ? this._zoom : e, i.scale(t) / i.scale(e);
      },
      // @method getScaleZoom(scale: Number, fromZoom: Number): Number
      // Returns the zoom level that the map would end up at, if it is at `fromZoom`
      // level and everything is scaled by a factor of `scale`. Inverse of
      // [`getZoomScale`](#map-getZoomScale).
      getScaleZoom: function(t, e) {
        var i = this.options.crs;
        e = e === void 0 ? this._zoom : e;
        var n = i.zoom(t * i.scale(e));
        return isNaN(n) ? 1 / 0 : n;
      },
      // @method project(latlng: LatLng, zoom: Number): Point
      // Projects a geographical coordinate `LatLng` according to the projection
      // of the map's CRS, then scales it according to `zoom` and the CRS's
      // `Transformation`. The result is pixel coordinate relative to
      // the CRS origin.
      project: function(t, e) {
        return e = e === void 0 ? this._zoom : e, this.options.crs.latLngToPoint(U(t), e);
      },
      // @method unproject(point: Point, zoom: Number): LatLng
      // Inverse of [`project`](#map-project).
      unproject: function(t, e) {
        return e = e === void 0 ? this._zoom : e, this.options.crs.pointToLatLng(I(t), e);
      },
      // @method layerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding geographical coordinate (for the current zoom level).
      layerPointToLatLng: function(t) {
        var e = I(t).add(this.getPixelOrigin());
        return this.unproject(e);
      },
      // @method latLngToLayerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the [origin pixel](#map-getpixelorigin).
      latLngToLayerPoint: function(t) {
        var e = this.project(U(t))._round();
        return e._subtract(this.getPixelOrigin());
      },
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
      // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
      // CRS's bounds.
      // By default this means longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees.
      wrapLatLng: function(t) {
        return this.options.crs.wrapLatLng(U(t));
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring that
      // its center is within the CRS's bounds.
      // By default this means the center longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees, and the majority of the bounds
      // overlaps the CRS's bounds.
      wrapLatLngBounds: function(t) {
        return this.options.crs.wrapLatLngBounds(st(t));
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates according to
      // the map's CRS. By default this measures distance in meters.
      distance: function(t, e) {
        return this.options.crs.distance(U(t), U(e));
      },
      // @method containerPointToLayerPoint(point: Point): Point
      // Given a pixel coordinate relative to the map container, returns the corresponding
      // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
      containerPointToLayerPoint: function(t) {
        return I(t).subtract(this._getMapPanePos());
      },
      // @method layerPointToContainerPoint(point: Point): Point
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding pixel coordinate relative to the map container.
      layerPointToContainerPoint: function(t) {
        return I(t).add(this._getMapPanePos());
      },
      // @method containerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the map container, returns
      // the corresponding geographical coordinate (for the current zoom level).
      containerPointToLatLng: function(t) {
        var e = this.containerPointToLayerPoint(I(t));
        return this.layerPointToLatLng(e);
      },
      // @method latLngToContainerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the map container.
      latLngToContainerPoint: function(t) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(U(t)));
      },
      // @method mouseEventToContainerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to the
      // map container where the event took place.
      mouseEventToContainerPoint: function(t) {
        return Wn(t, this._container);
      },
      // @method mouseEventToLayerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to
      // the [origin pixel](#map-getpixelorigin) where the event took place.
      mouseEventToLayerPoint: function(t) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t));
      },
      // @method mouseEventToLatLng(ev: MouseEvent): LatLng
      // Given a MouseEvent object, returns geographical coordinate where the
      // event took place.
      mouseEventToLatLng: function(t) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(t));
      },
      // map initialization methods
      _initContainer: function(t) {
        var e = this._container = jn(t);
        if (e) {
          if (e._leaflet_id)
            throw new Error("Map container is already initialized.");
        } else
          throw new Error("Map container not found.");
        z(e, "scroll", this._onScroll, this), this._containerId = g(e);
      },
      _initLayout: function() {
        var t = this._container;
        this._fadeAnimated = this.options.fadeAnimation && T.any3d, D(t, "leaflet-container" + (T.touch ? " leaflet-touch" : "") + (T.retina ? " leaflet-retina" : "") + (T.ielt9 ? " leaflet-oldie" : "") + (T.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var e = me(t, "position");
        e !== "absolute" && e !== "relative" && e !== "fixed" && e !== "sticky" && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
      },
      _initPanes: function() {
        var t = this._panes = {};
        this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), at(this._mapPane, new O(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (D(t.markerPane, "leaflet-zoom-hide"), D(t.shadowPane, "leaflet-zoom-hide"));
      },
      // private methods that modify map state
      // @section Map state change events
      _resetView: function(t, e, i) {
        at(this._mapPane, new O(0, 0));
        var n = !this._loaded;
        this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset");
        var s = this._zoom !== e;
        this._moveStart(s, i)._move(t, e)._moveEnd(s), this.fire("viewreset"), n && this.fire("load");
      },
      _moveStart: function(t, e) {
        return t && this.fire("zoomstart"), e || this.fire("movestart"), this;
      },
      _move: function(t, e, i, n) {
        e === void 0 && (e = this._zoom);
        var s = this._zoom !== e;
        return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), n ? i && i.pinch && this.fire("zoom", i) : ((s || i && i.pinch) && this.fire("zoom", i), this.fire("move", i)), this;
      },
      _moveEnd: function(t) {
        return t && this.fire("zoomend"), this.fire("moveend");
      },
      _stop: function() {
        return it(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
      },
      _rawPanBy: function(t) {
        at(this._mapPane, this._getMapPanePos().subtract(t));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
      },
      _checkIfLoaded: function() {
        if (!this._loaded)
          throw new Error("Set map center and zoom first.");
      },
      // DOM event handling
      // @section Interaction events
      _initEvents: function(t) {
        this._targets = {}, this._targets[g(this._container)] = this;
        var e = t ? X : z;
        e(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), T.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
      },
      _onResize: function() {
        it(this._resizeRequest), this._resizeRequest = Q(
          function() {
            this.invalidateSize({ debounceMoveend: !0 });
          },
          this
        );
      },
      _onScroll: function() {
        this._container.scrollTop = 0, this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var t = this._getMapPanePos();
        Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
      },
      _findEventTargets: function(t, e) {
        for (var i = [], n, s = e === "mouseout" || e === "mouseover", c = t.target || t.srcElement, f = !1; c; ) {
          if (n = this._targets[g(c)], n && (e === "click" || e === "preclick") && this._draggableMoved(n)) {
            f = !0;
            break;
          }
          if (n && n.listens(e, !0) && (s && !Ri(c, t) || (i.push(n), s)) || c === this._container)
            break;
          c = c.parentNode;
        }
        return !i.length && !f && !s && this.listens(e, !0) && (i = [this]), i;
      },
      _isClickDisabled: function(t) {
        for (; t && t !== this._container; ) {
          if (t._leaflet_disable_click)
            return !0;
          t = t.parentNode;
        }
      },
      _handleDOMEvent: function(t) {
        var e = t.target || t.srcElement;
        if (!(!this._loaded || e._leaflet_disable_events || t.type === "click" && this._isClickDisabled(e))) {
          var i = t.type;
          i === "mousedown" && Ei(e), this._fireDOMEvent(t, i);
        }
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(t, e, i) {
        if (t.type === "click") {
          var n = l({}, t);
          n.type = "preclick", this._fireDOMEvent(n, n.type, i);
        }
        var s = this._findEventTargets(t, e);
        if (i) {
          for (var c = [], f = 0; f < i.length; f++)
            i[f].listens(e, !0) && c.push(i[f]);
          s = c.concat(s);
        }
        if (s.length) {
          e === "contextmenu" && ut(t);
          var m = s[0], v = {
            originalEvent: t
          };
          if (t.type !== "keypress" && t.type !== "keydown" && t.type !== "keyup") {
            var b = m.getLatLng && (!m._radius || m._radius <= 10);
            v.containerPoint = b ? this.latLngToContainerPoint(m.getLatLng()) : this.mouseEventToContainerPoint(t), v.layerPoint = this.containerPointToLayerPoint(v.containerPoint), v.latlng = b ? m.getLatLng() : this.layerPointToLatLng(v.layerPoint);
          }
          for (f = 0; f < s.length; f++)
            if (s[f].fire(e, v, !0), v.originalEvent._stopped || s[f].options.bubblingMouseEvents === !1 && G(this._mouseEvents, e) !== -1)
              return;
        }
      },
      _draggableMoved: function(t) {
        return t = t.dragging && t.dragging.enabled() ? t : this, t.dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var t = 0, e = this._handlers.length; t < e; t++)
          this._handlers[t].disable();
      },
      // @section Other Methods
      // @method whenReady(fn: Function, context?: Object): this
      // Runs the given function `fn` when the map gets initialized with
      // a view (center and zoom) and at least one layer, or immediately
      // if it's already initialized, optionally passing a function context.
      whenReady: function(t, e) {
        return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this;
      },
      // private methods for getting map state
      _getMapPanePos: function() {
        return qt(this._mapPane) || new O(0, 0);
      },
      _moved: function() {
        var t = this._getMapPanePos();
        return t && !t.equals([0, 0]);
      },
      _getTopLeftPoint: function(t, e) {
        var i = t && e !== void 0 ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin();
        return i.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(t, e) {
        var i = this.getSize()._divideBy(2);
        return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(t, e, i) {
        var n = this._getNewPixelOrigin(i, e);
        return this.project(t, e)._subtract(n);
      },
      _latLngBoundsToNewLayerBounds: function(t, e, i) {
        var n = this._getNewPixelOrigin(i, e);
        return pt([
          this.project(t.getSouthWest(), e)._subtract(n),
          this.project(t.getNorthWest(), e)._subtract(n),
          this.project(t.getSouthEast(), e)._subtract(n),
          this.project(t.getNorthEast(), e)._subtract(n)
        ]);
      },
      // layer point of the current center
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      // offset of the specified place to the current center in pixels
      _getCenterOffset: function(t) {
        return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint());
      },
      // adjust center for view to get inside bounds
      _limitCenter: function(t, e, i) {
        if (!i)
          return t;
        var n = this.project(t, e), s = this.getSize().divideBy(2), c = new tt(n.subtract(s), n.add(s)), f = this._getBoundsOffset(c, i, e);
        return Math.abs(f.x) <= 1 && Math.abs(f.y) <= 1 ? t : this.unproject(n.add(f), e);
      },
      // adjust offset for view to get inside bounds
      _limitOffset: function(t, e) {
        if (!e)
          return t;
        var i = this.getPixelBounds(), n = new tt(i.min.add(t), i.max.add(t));
        return t.add(this._getBoundsOffset(n, e));
      },
      // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
      _getBoundsOffset: function(t, e, i) {
        var n = pt(
          this.project(e.getNorthEast(), i),
          this.project(e.getSouthWest(), i)
        ), s = n.min.subtract(t.min), c = n.max.subtract(t.max), f = this._rebound(s.x, -c.x), m = this._rebound(s.y, -c.y);
        return new O(f, m);
      },
      _rebound: function(t, e) {
        return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e));
      },
      _limitZoom: function(t) {
        var e = this.getMinZoom(), i = this.getMaxZoom(), n = T.any3d ? this.options.zoomSnap : 1;
        return n && (t = Math.round(t / n) * n), Math.max(e, Math.min(i, t));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        nt(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
      },
      _tryAnimatedPan: function(t, e) {
        var i = this._getCenterOffset(t)._trunc();
        return (e && e.animate) !== !0 && !this.getSize().contains(i) ? !1 : (this.panBy(i, e), !0);
      },
      _createAnimProxy: function() {
        var t = this._proxy = q("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(t), this.on("zoomanim", function(e) {
          var i = yi, n = this._proxy.style[i];
          jt(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)), n === this._proxy.style[i] && this._animatingZoom && this._onZoomTransitionEnd();
        }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        et(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
      },
      _animMoveEnd: function() {
        var t = this.getCenter(), e = this.getZoom();
        jt(this._proxy, this.project(t, e), this.getZoomScale(e, 1));
      },
      _catchTransitionEnd: function(t) {
        this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(t, e, i) {
        if (this._animatingZoom)
          return !0;
        if (i = i || {}, !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)
          return !1;
        var n = this.getZoomScale(e), s = this._getCenterOffset(t)._divideBy(1 - 1 / n);
        return i.animate !== !0 && !this.getSize().contains(s) ? !1 : (Q(function() {
          this._moveStart(!0, i.noMoveStart || !1)._animateZoom(t, e, !0);
        }, this), !0);
      },
      _animateZoom: function(t, e, i, n) {
        this._mapPane && (i && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, D(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
          center: t,
          zoom: e,
          noUpdate: n
        }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(u(this._onZoomTransitionEnd, this), 250));
      },
      _onZoomTransitionEnd: function() {
        this._animatingZoom && (this._mapPane && nt(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
      }
    });
    function Zr(t, e) {
      return new j(t, e);
    }
    var xt = J.extend({
      // @section
      // @aka Control Options
      options: {
        // @option position: String = 'topright'
        // The position of the control (one of the map corners). Possible values are `'topleft'`,
        // `'topright'`, `'bottomleft'` or `'bottomright'`
        position: "topright"
      },
      initialize: function(t) {
        x(this, t);
      },
      /* @section
       * Classes extending L.Control will inherit the following methods:
       *
       * @method getPosition: string
       * Returns the position of the control.
       */
      getPosition: function() {
        return this.options.position;
      },
      // @method setPosition(position: string): this
      // Sets the position of the control.
      setPosition: function(t) {
        var e = this._map;
        return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTMLElement that contains the control.
      getContainer: function() {
        return this._container;
      },
      // @method addTo(map: Map): this
      // Adds the control to the given map.
      addTo: function(t) {
        this.remove(), this._map = t;
        var e = this._container = this.onAdd(t), i = this.getPosition(), n = t._controlCorners[i];
        return D(e, "leaflet-control"), i.indexOf("bottom") !== -1 ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this._map.on("unload", this.remove, this), this;
      },
      // @method remove: this
      // Removes the control from the map it is currently active on.
      remove: function() {
        return this._map ? (et(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
      },
      _refocusOnMap: function(t) {
        this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus();
      }
    }), be = function(t) {
      return new xt(t);
    };
    j.include({
      // @method addControl(control: Control): this
      // Adds the given control to the map
      addControl: function(t) {
        return t.addTo(this), this;
      },
      // @method removeControl(control: Control): this
      // Removes the given control from the map
      removeControl: function(t) {
        return t.remove(), this;
      },
      _initControlPos: function() {
        var t = this._controlCorners = {}, e = "leaflet-", i = this._controlContainer = q("div", e + "control-container", this._container);
        function n(s, c) {
          var f = e + s + " " + e + c;
          t[s + c] = q("div", f, i);
        }
        n("top", "left"), n("top", "right"), n("bottom", "left"), n("bottom", "right");
      },
      _clearControlPos: function() {
        for (var t in this._controlCorners)
          et(this._controlCorners[t]);
        et(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
      }
    });
    var Qn = xt.extend({
      // @section
      // @aka Control.Layers options
      options: {
        // @option collapsed: Boolean = true
        // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
        collapsed: !0,
        position: "topright",
        // @option autoZIndex: Boolean = true
        // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
        autoZIndex: !0,
        // @option hideSingleBase: Boolean = false
        // If `true`, the base layers in the control will be hidden when there is only one.
        hideSingleBase: !1,
        // @option sortLayers: Boolean = false
        // Whether to sort the layers. When `false`, layers will keep the order
        // in which they were added to the control.
        sortLayers: !1,
        // @option sortFunction: Function = *
        // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
        // that will be used for sorting the layers, when `sortLayers` is `true`.
        // The function receives both the `L.Layer` instances and their names, as in
        // `sortFunction(layerA, layerB, nameA, nameB)`.
        // By default, it sorts layers alphabetically by their name.
        sortFunction: function(t, e, i, n) {
          return i < n ? -1 : n < i ? 1 : 0;
        }
      },
      initialize: function(t, e, i) {
        x(this, i), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
        for (var n in t)
          this._addLayer(t[n], n);
        for (n in e)
          this._addLayer(e[n], n, !0);
      },
      onAdd: function(t) {
        this._initLayout(), this._update(), this._map = t, t.on("zoomend", this._checkDisabledLayers, this);
        for (var e = 0; e < this._layers.length; e++)
          this._layers[e].layer.on("add remove", this._onLayerChange, this);
        return this._container;
      },
      addTo: function(t) {
        return xt.prototype.addTo.call(this, t), this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var t = 0; t < this._layers.length; t++)
          this._layers[t].layer.off("add remove", this._onLayerChange, this);
      },
      // @method addBaseLayer(layer: Layer, name: String): this
      // Adds a base layer (radio button entry) with the given name to the control.
      addBaseLayer: function(t, e) {
        return this._addLayer(t, e), this._map ? this._update() : this;
      },
      // @method addOverlay(layer: Layer, name: String): this
      // Adds an overlay (checkbox entry) with the given name to the control.
      addOverlay: function(t, e) {
        return this._addLayer(t, e, !0), this._map ? this._update() : this;
      },
      // @method removeLayer(layer: Layer): this
      // Remove the given layer from the control.
      removeLayer: function(t) {
        t.off("add remove", this._onLayerChange, this);
        var e = this._getLayer(g(t));
        return e && this._layers.splice(this._layers.indexOf(e), 1), this._map ? this._update() : this;
      },
      // @method expand(): this
      // Expand the control container if collapsed.
      expand: function() {
        D(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
        var t = this._map.getSize().y - (this._container.offsetTop + 50);
        return t < this._section.clientHeight ? (D(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t + "px") : nt(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
      },
      // @method collapse(): this
      // Collapse the control container if expanded.
      collapse: function() {
        return nt(this._container, "leaflet-control-layers-expanded"), this;
      },
      _initLayout: function() {
        var t = "leaflet-control-layers", e = this._container = q("div", t), i = this.options.collapsed;
        e.setAttribute("aria-haspopup", !0), _e(e), Mi(e);
        var n = this._section = q("section", t + "-list");
        i && (this._map.on("click", this.collapse, this), z(e, {
          mouseenter: this._expandSafely,
          mouseleave: this.collapse
        }, this));
        var s = this._layersLink = q("a", t + "-toggle", e);
        s.href = "#", s.title = "Layers", s.setAttribute("role", "button"), z(s, {
          keydown: function(c) {
            c.keyCode === 13 && this._expandSafely();
          },
          // Certain screen readers intercept the key event and instead send a click event
          click: function(c) {
            ut(c), this._expandSafely();
          }
        }, this), i || this.expand(), this._baseLayersList = q("div", t + "-base", n), this._separator = q("div", t + "-separator", n), this._overlaysList = q("div", t + "-overlays", n), e.appendChild(n);
      },
      _getLayer: function(t) {
        for (var e = 0; e < this._layers.length; e++)
          if (this._layers[e] && g(this._layers[e].layer) === t)
            return this._layers[e];
      },
      _addLayer: function(t, e, i) {
        this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({
          layer: t,
          name: e,
          overlay: i
        }), this.options.sortLayers && this._layers.sort(u(function(n, s) {
          return this.options.sortFunction(n.layer, s.layer, n.name, s.name);
        }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container)
          return this;
        Re(this._baseLayersList), Re(this._overlaysList), this._layerControlInputs = [];
        var t, e, i, n, s = 0;
        for (i = 0; i < this._layers.length; i++)
          n = this._layers[i], this._addItem(n), e = e || n.overlay, t = t || !n.overlay, s += n.overlay ? 0 : 1;
        return this.options.hideSingleBase && (t = t && s > 1, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this;
      },
      _onLayerChange: function(t) {
        this._handlingClick || this._update();
        var e = this._getLayer(g(t.target)), i = e.overlay ? t.type === "add" ? "overlayadd" : "overlayremove" : t.type === "add" ? "baselayerchange" : null;
        i && this._map.fire(i, e);
      },
      // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
      _createRadioElement: function(t, e) {
        var i = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", n = document.createElement("div");
        return n.innerHTML = i, n.firstChild;
      },
      _addItem: function(t) {
        var e = document.createElement("label"), i = this._map.hasLayer(t.layer), n;
        t.overlay ? (n = document.createElement("input"), n.type = "checkbox", n.className = "leaflet-control-layers-selector", n.defaultChecked = i) : n = this._createRadioElement("leaflet-base-layers_" + g(this), i), this._layerControlInputs.push(n), n.layerId = g(t.layer), z(n, "click", this._onInputClick, this);
        var s = document.createElement("span");
        s.innerHTML = " " + t.name;
        var c = document.createElement("span");
        e.appendChild(c), c.appendChild(n), c.appendChild(s);
        var f = t.overlay ? this._overlaysList : this._baseLayersList;
        return f.appendChild(e), this._checkDisabledLayers(), e;
      },
      _onInputClick: function() {
        if (!this._preventClick) {
          var t = this._layerControlInputs, e, i, n = [], s = [];
          this._handlingClick = !0;
          for (var c = t.length - 1; c >= 0; c--)
            e = t[c], i = this._getLayer(e.layerId).layer, e.checked ? n.push(i) : e.checked || s.push(i);
          for (c = 0; c < s.length; c++)
            this._map.hasLayer(s[c]) && this._map.removeLayer(s[c]);
          for (c = 0; c < n.length; c++)
            this._map.hasLayer(n[c]) || this._map.addLayer(n[c]);
          this._handlingClick = !1, this._refocusOnMap();
        }
      },
      _checkDisabledLayers: function() {
        for (var t = this._layerControlInputs, e, i, n = this._map.getZoom(), s = t.length - 1; s >= 0; s--)
          e = t[s], i = this._getLayer(e.layerId).layer, e.disabled = i.options.minZoom !== void 0 && n < i.options.minZoom || i.options.maxZoom !== void 0 && n > i.options.maxZoom;
      },
      _expandIfNotCollapsed: function() {
        return this._map && !this.options.collapsed && this.expand(), this;
      },
      _expandSafely: function() {
        var t = this._section;
        this._preventClick = !0, z(t, "click", ut), this.expand();
        var e = this;
        setTimeout(function() {
          X(t, "click", ut), e._preventClick = !1;
        });
      }
    }), Fr = function(t, e, i) {
      return new Qn(t, e, i);
    }, ki = xt.extend({
      // @section
      // @aka Control.Zoom options
      options: {
        position: "topleft",
        // @option zoomInText: String = '<span aria-hidden="true">+</span>'
        // The text set on the 'zoom in' button.
        zoomInText: '<span aria-hidden="true">+</span>',
        // @option zoomInTitle: String = 'Zoom in'
        // The title set on the 'zoom in' button.
        zoomInTitle: "Zoom in",
        // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
        // The text set on the 'zoom out' button.
        zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
        // @option zoomOutTitle: String = 'Zoom out'
        // The title set on the 'zoom out' button.
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(t) {
        var e = "leaflet-control-zoom", i = q("div", e + " leaflet-bar"), n = this.options;
        return this._zoomInButton = this._createButton(
          n.zoomInText,
          n.zoomInTitle,
          e + "-in",
          i,
          this._zoomIn
        ), this._zoomOutButton = this._createButton(
          n.zoomOutText,
          n.zoomOutTitle,
          e + "-out",
          i,
          this._zoomOut
        ), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i;
      },
      onRemove: function(t) {
        t.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        return this._disabled = !0, this._updateDisabled(), this;
      },
      enable: function() {
        return this._disabled = !1, this._updateDisabled(), this;
      },
      _zoomIn: function(t) {
        !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));
      },
      _zoomOut: function(t) {
        !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));
      },
      _createButton: function(t, e, i, n, s) {
        var c = q("a", i, n);
        return c.innerHTML = t, c.href = "#", c.title = e, c.setAttribute("role", "button"), c.setAttribute("aria-label", e), _e(c), z(c, "click", Yt), z(c, "click", s, this), z(c, "click", this._refocusOnMap, this), c;
      },
      _updateDisabled: function() {
        var t = this._map, e = "leaflet-disabled";
        nt(this._zoomInButton, e), nt(this._zoomOutButton, e), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || t._zoom === t.getMinZoom()) && (D(this._zoomOutButton, e), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || t._zoom === t.getMaxZoom()) && (D(this._zoomInButton, e), this._zoomInButton.setAttribute("aria-disabled", "true"));
      }
    });
    j.mergeOptions({
      zoomControl: !0
    }), j.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new ki(), this.addControl(this.zoomControl));
    });
    var Ur = function(t) {
      return new ki(t);
    }, Kn = xt.extend({
      // @section
      // @aka Control.Scale options
      options: {
        position: "bottomleft",
        // @option maxWidth: Number = 100
        // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
        maxWidth: 100,
        // @option metric: Boolean = True
        // Whether to show the metric scale line (m/km).
        metric: !0,
        // @option imperial: Boolean = True
        // Whether to show the imperial scale line (mi/ft).
        imperial: !0
        // @option updateWhenIdle: Boolean = false
        // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
      },
      onAdd: function(t) {
        var e = "leaflet-control-scale", i = q("div", e), n = this.options;
        return this._addScales(n, e + "-line", i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i;
      },
      onRemove: function(t) {
        t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(t, e, i) {
        t.metric && (this._mScale = q("div", e, i)), t.imperial && (this._iScale = q("div", e, i));
      },
      _update: function() {
        var t = this._map, e = t.getSize().y / 2, i = t.distance(
          t.containerPointToLatLng([0, e]),
          t.containerPointToLatLng([this.options.maxWidth, e])
        );
        this._updateScales(i);
      },
      _updateScales: function(t) {
        this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t);
      },
      _updateMetric: function(t) {
        var e = this._getRoundNum(t), i = e < 1e3 ? e + " m" : e / 1e3 + " km";
        this._updateScale(this._mScale, i, e / t);
      },
      _updateImperial: function(t) {
        var e = t * 3.2808399, i, n, s;
        e > 5280 ? (i = e / 5280, n = this._getRoundNum(i), this._updateScale(this._iScale, n + " mi", n / i)) : (s = this._getRoundNum(e), this._updateScale(this._iScale, s + " ft", s / e));
      },
      _updateScale: function(t, e, i) {
        t.style.width = Math.round(this.options.maxWidth * i) + "px", t.innerHTML = e;
      },
      _getRoundNum: function(t) {
        var e = Math.pow(10, (Math.floor(t) + "").length - 1), i = t / e;
        return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i;
      }
    }), jr = function(t) {
      return new Kn(t);
    }, qr = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', Bi = xt.extend({
      // @section
      // @aka Control.Attribution options
      options: {
        position: "bottomright",
        // @option prefix: String|false = 'Leaflet'
        // The HTML text shown before the attributions. Pass `false` to disable.
        prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (T.inlineSvg ? qr + " " : "") + "Leaflet</a>"
      },
      initialize: function(t) {
        x(this, t), this._attributions = {};
      },
      onAdd: function(t) {
        t.attributionControl = this, this._container = q("div", "leaflet-control-attribution"), _e(this._container);
        for (var e in t._layers)
          t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
        return this._update(), t.on("layeradd", this._addAttribution, this), this._container;
      },
      onRemove: function(t) {
        t.off("layeradd", this._addAttribution, this);
      },
      _addAttribution: function(t) {
        t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()), t.layer.once("remove", function() {
          this.removeAttribution(t.layer.getAttribution());
        }, this));
      },
      // @method setPrefix(prefix: String|false): this
      // The HTML text shown before the attributions. Pass `false` to disable.
      setPrefix: function(t) {
        return this.options.prefix = t, this._update(), this;
      },
      // @method addAttribution(text: String): this
      // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
      addAttribution: function(t) {
        return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : this;
      },
      // @method removeAttribution(text: String): this
      // Removes an attribution text.
      removeAttribution: function(t) {
        return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : this;
      },
      _update: function() {
        if (this._map) {
          var t = [];
          for (var e in this._attributions)
            this._attributions[e] && t.push(e);
          var i = [];
          this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(' <span aria-hidden="true">|</span> ');
        }
      }
    });
    j.mergeOptions({
      attributionControl: !0
    }), j.addInitHook(function() {
      this.options.attributionControl && new Bi().addTo(this);
    });
    var Vr = function(t) {
      return new Bi(t);
    };
    xt.Layers = Qn, xt.Zoom = ki, xt.Scale = Kn, xt.Attribution = Bi, be.layers = Fr, be.zoom = Ur, be.scale = jr, be.attribution = Vr;
    var Lt = J.extend({
      initialize: function(t) {
        this._map = t;
      },
      // @method enable(): this
      // Enables the handler
      enable: function() {
        return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
      },
      // @method disable(): this
      // Disables the handler
      disable: function() {
        return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
      },
      // @method enabled(): Boolean
      // Returns `true` if the handler is enabled
      enabled: function() {
        return !!this._enabled;
      }
      // @section Extension methods
      // Classes inheriting from `Handler` must implement the two following methods:
      // @method addHooks()
      // Called when the handler is enabled, should add event hooks.
      // @method removeHooks()
      // Called when the handler is disabled, should remove the event hooks added previously.
    });
    Lt.addTo = function(t, e) {
      return t.addHandler(e, this), this;
    };
    var Yr = { Events: $ }, Jn = T.touch ? "touchstart mousedown" : "mousedown", Nt = Ut.extend({
      options: {
        // @section
        // @aka Draggable options
        // @option clickTolerance: Number = 3
        // The max number of pixels a user can shift the mouse pointer during a click
        // for it to be considered a valid click (as opposed to a mouse drag).
        clickTolerance: 3
      },
      // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
      // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
      initialize: function(t, e, i, n) {
        x(this, n), this._element = t, this._dragStartTarget = e || t, this._preventOutline = i;
      },
      // @method enable()
      // Enables the dragging ability
      enable: function() {
        this._enabled || (z(this._dragStartTarget, Jn, this._onDown, this), this._enabled = !0);
      },
      // @method disable()
      // Disables the dragging ability
      disable: function() {
        this._enabled && (Nt._dragging === this && this.finishDrag(!0), X(this._dragStartTarget, Jn, this._onDown, this), this._enabled = !1, this._moved = !1);
      },
      _onDown: function(t) {
        if (this._enabled && (this._moved = !1, !_i(this._element, "leaflet-zoom-anim"))) {
          if (t.touches && t.touches.length !== 1) {
            Nt._dragging === this && this.finishDrag();
            return;
          }
          if (!(Nt._dragging || t.shiftKey || t.which !== 1 && t.button !== 1 && !t.touches) && (Nt._dragging = this, this._preventOutline && Ei(this._element), xi(), ge(), !this._moving)) {
            this.fire("down");
            var e = t.touches ? t.touches[0] : t, i = qn(this._element);
            this._startPoint = new O(e.clientX, e.clientY), this._startPos = qt(this._element), this._parentScale = Pi(i);
            var n = t.type === "mousedown";
            z(document, n ? "mousemove" : "touchmove", this._onMove, this), z(document, n ? "mouseup" : "touchend touchcancel", this._onUp, this);
          }
        }
      },
      _onMove: function(t) {
        if (this._enabled) {
          if (t.touches && t.touches.length > 1) {
            this._moved = !0;
            return;
          }
          var e = t.touches && t.touches.length === 1 ? t.touches[0] : t, i = new O(e.clientX, e.clientY)._subtract(this._startPoint);
          !i.x && !i.y || Math.abs(i.x) + Math.abs(i.y) < this.options.clickTolerance || (i.x /= this._parentScale.x, i.y /= this._parentScale.y, ut(t), this._moved || (this.fire("dragstart"), this._moved = !0, D(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), D(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(i), this._moving = !0, this._lastEvent = t, this._updatePosition());
        }
      },
      _updatePosition: function() {
        var t = { originalEvent: this._lastEvent };
        this.fire("predrag", t), at(this._element, this._newPos), this.fire("drag", t);
      },
      _onUp: function() {
        this._enabled && this.finishDrag();
      },
      finishDrag: function(t) {
        nt(document.body, "leaflet-dragging"), this._lastTarget && (nt(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), X(document, "mousemove touchmove", this._onMove, this), X(document, "mouseup touchend touchcancel", this._onUp, this), Ci(), ve();
        var e = this._moved && this._moving;
        this._moving = !1, Nt._dragging = !1, e && this.fire("dragend", {
          noInertia: t,
          distance: this._newPos.distanceTo(this._startPos)
        });
      }
    });
    function $n(t, e, i) {
      var n, s = [1, 4, 2, 8], c, f, m, v, b, A, M, N;
      for (c = 0, A = t.length; c < A; c++)
        t[c]._code = Wt(t[c], e);
      for (m = 0; m < 4; m++) {
        for (M = s[m], n = [], c = 0, A = t.length, f = A - 1; c < A; f = c++)
          v = t[c], b = t[f], v._code & M ? b._code & M || (N = ze(b, v, M, e, i), N._code = Wt(N, e), n.push(N)) : (b._code & M && (N = ze(b, v, M, e, i), N._code = Wt(N, e), n.push(N)), n.push(v));
        t = n;
      }
      return t;
    }
    function to(t, e) {
      var i, n, s, c, f, m, v, b, A;
      if (!t || t.length === 0)
        throw new Error("latlngs not passed");
      bt(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]);
      var M = U([0, 0]), N = st(t), ft = N.getNorthWest().distanceTo(N.getSouthWest()) * N.getNorthEast().distanceTo(N.getNorthWest());
      ft < 1700 && (M = Ii(t));
      var ct = t.length, wt = [];
      for (i = 0; i < ct; i++) {
        var gt = U(t[i]);
        wt.push(e.project(U([gt.lat - M.lat, gt.lng - M.lng])));
      }
      for (m = v = b = 0, i = 0, n = ct - 1; i < ct; n = i++)
        s = wt[i], c = wt[n], f = s.y * c.x - c.y * s.x, v += (s.x + c.x) * f, b += (s.y + c.y) * f, m += f * 3;
      m === 0 ? A = wt[0] : A = [v / m, b / m];
      var ce = e.unproject(I(A));
      return U([ce.lat + M.lat, ce.lng + M.lng]);
    }
    function Ii(t) {
      for (var e = 0, i = 0, n = 0, s = 0; s < t.length; s++) {
        var c = U(t[s]);
        e += c.lat, i += c.lng, n++;
      }
      return U([e / n, i / n]);
    }
    var Wr = {
      __proto__: null,
      clipPolygon: $n,
      polygonCenter: to,
      centroid: Ii
    };
    function eo(t, e) {
      if (!e || !t.length)
        return t.slice();
      var i = e * e;
      return t = Qr(t, i), t = Xr(t, i), t;
    }
    function io(t, e, i) {
      return Math.sqrt(we(t, e, i, !0));
    }
    function Gr(t, e, i) {
      return we(t, e, i);
    }
    function Xr(t, e) {
      var i = t.length, n = typeof Uint8Array != void 0 + "" ? Uint8Array : Array, s = new n(i);
      s[0] = s[i - 1] = 1, Oi(t, s, e, 0, i - 1);
      var c, f = [];
      for (c = 0; c < i; c++)
        s[c] && f.push(t[c]);
      return f;
    }
    function Oi(t, e, i, n, s) {
      var c = 0, f, m, v;
      for (m = n + 1; m <= s - 1; m++)
        v = we(t[m], t[n], t[s], !0), v > c && (f = m, c = v);
      c > i && (e[f] = 1, Oi(t, e, i, n, f), Oi(t, e, i, f, s));
    }
    function Qr(t, e) {
      for (var i = [t[0]], n = 1, s = 0, c = t.length; n < c; n++)
        Kr(t[n], t[s]) > e && (i.push(t[n]), s = n);
      return s < c - 1 && i.push(t[c - 1]), i;
    }
    var no;
    function oo(t, e, i, n, s) {
      var c = n ? no : Wt(t, i), f = Wt(e, i), m, v, b;
      for (no = f; ; ) {
        if (!(c | f))
          return [t, e];
        if (c & f)
          return !1;
        m = c || f, v = ze(t, e, m, i, s), b = Wt(v, i), m === c ? (t = v, c = b) : (e = v, f = b);
      }
    }
    function ze(t, e, i, n, s) {
      var c = e.x - t.x, f = e.y - t.y, m = n.min, v = n.max, b, A;
      return i & 8 ? (b = t.x + c * (v.y - t.y) / f, A = v.y) : i & 4 ? (b = t.x + c * (m.y - t.y) / f, A = m.y) : i & 2 ? (b = v.x, A = t.y + f * (v.x - t.x) / c) : i & 1 && (b = m.x, A = t.y + f * (m.x - t.x) / c), new O(b, A, s);
    }
    function Wt(t, e) {
      var i = 0;
      return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i;
    }
    function Kr(t, e) {
      var i = e.x - t.x, n = e.y - t.y;
      return i * i + n * n;
    }
    function we(t, e, i, n) {
      var s = e.x, c = e.y, f = i.x - s, m = i.y - c, v = f * f + m * m, b;
      return v > 0 && (b = ((t.x - s) * f + (t.y - c) * m) / v, b > 1 ? (s = i.x, c = i.y) : b > 0 && (s += f * b, c += m * b)), f = t.x - s, m = t.y - c, n ? f * f + m * m : new O(s, c);
    }
    function bt(t) {
      return !B(t[0]) || typeof t[0][0] != "object" && typeof t[0][0] < "u";
    }
    function ro(t) {
      return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), bt(t);
    }
    function so(t, e) {
      var i, n, s, c, f, m, v, b;
      if (!t || t.length === 0)
        throw new Error("latlngs not passed");
      bt(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]);
      var A = U([0, 0]), M = st(t), N = M.getNorthWest().distanceTo(M.getSouthWest()) * M.getNorthEast().distanceTo(M.getNorthWest());
      N < 1700 && (A = Ii(t));
      var ft = t.length, ct = [];
      for (i = 0; i < ft; i++) {
        var wt = U(t[i]);
        ct.push(e.project(U([wt.lat - A.lat, wt.lng - A.lng])));
      }
      for (i = 0, n = 0; i < ft - 1; i++)
        n += ct[i].distanceTo(ct[i + 1]) / 2;
      if (n === 0)
        b = ct[0];
      else
        for (i = 0, c = 0; i < ft - 1; i++)
          if (f = ct[i], m = ct[i + 1], s = f.distanceTo(m), c += s, c > n) {
            v = (c - n) / s, b = [
              m.x - v * (m.x - f.x),
              m.y - v * (m.y - f.y)
            ];
            break;
          }
      var gt = e.unproject(I(b));
      return U([gt.lat + A.lat, gt.lng + A.lng]);
    }
    var Jr = {
      __proto__: null,
      simplify: eo,
      pointToSegmentDistance: io,
      closestPointOnSegment: Gr,
      clipSegment: oo,
      _getEdgeIntersection: ze,
      _getBitCode: Wt,
      _sqClosestPointOnSegment: we,
      isFlat: bt,
      _flat: ro,
      polylineCenter: so
    }, zi = {
      project: function(t) {
        return new O(t.lng, t.lat);
      },
      unproject: function(t) {
        return new W(t.y, t.x);
      },
      bounds: new tt([-180, -90], [180, 90])
    }, Di = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new tt([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(t) {
        var e = Math.PI / 180, i = this.R, n = t.lat * e, s = this.R_MINOR / i, c = Math.sqrt(1 - s * s), f = c * Math.sin(n), m = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - f) / (1 + f), c / 2);
        return n = -i * Math.log(Math.max(m, 1e-10)), new O(t.lng * e * i, n);
      },
      unproject: function(t) {
        for (var e = 180 / Math.PI, i = this.R, n = this.R_MINOR / i, s = Math.sqrt(1 - n * n), c = Math.exp(-t.y / i), f = Math.PI / 2 - 2 * Math.atan(c), m = 0, v = 0.1, b; m < 15 && Math.abs(v) > 1e-7; m++)
          b = s * Math.sin(f), b = Math.pow((1 - b) / (1 + b), s / 2), v = Math.PI / 2 - 2 * Math.atan(c * b) - f, f += v;
        return new W(f * e, t.x * e / i);
      }
    }, $r = {
      __proto__: null,
      LonLat: zi,
      Mercator: Di,
      SphericalMercator: li
    }, ts = l({}, Dt, {
      code: "EPSG:3395",
      projection: Di,
      transformation: function() {
        var t = 0.5 / (Math.PI * Di.R);
        return de(t, 0.5, -t, 0.5);
      }()
    }), ao = l({}, Dt, {
      code: "EPSG:4326",
      projection: zi,
      transformation: de(1 / 180, 1, -1 / 180, 0.5)
    }), es = l({}, Rt, {
      projection: zi,
      transformation: de(1, 0, -1, 0),
      scale: function(t) {
        return Math.pow(2, t);
      },
      zoom: function(t) {
        return Math.log(t) / Math.LN2;
      },
      distance: function(t, e) {
        var i = e.lng - t.lng, n = e.lat - t.lat;
        return Math.sqrt(i * i + n * n);
      },
      infinite: !0
    });
    Rt.Earth = Dt, Rt.EPSG3395 = ts, Rt.EPSG3857 = ui, Rt.EPSG900913 = ar, Rt.EPSG4326 = ao, Rt.Simple = es;
    var Ct = Ut.extend({
      // Classes extending `L.Layer` will inherit the following options:
      options: {
        // @option pane: String = 'overlayPane'
        // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
        pane: "overlayPane",
        // @option attribution: String = null
        // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
        attribution: null,
        bubblingMouseEvents: !0
      },
      /* @section
       * Classes extending `L.Layer` will inherit the following methods:
       *
       * @method addTo(map: Map|LayerGroup): this
       * Adds the layer to the given map or layer group.
       */
      addTo: function(t) {
        return t.addLayer(this), this;
      },
      // @method remove: this
      // Removes the layer from the map it is currently active on.
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      // @method removeFrom(map: Map): this
      // Removes the layer from the given map
      //
      // @alternative
      // @method removeFrom(group: LayerGroup): this
      // Removes the layer from the given `LayerGroup`
      removeFrom: function(t) {
        return t && t.removeLayer(this), this;
      },
      // @method getPane(name? : String): HTMLElement
      // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
      getPane: function(t) {
        return this._map.getPane(t ? this.options[t] || t : this.options.pane);
      },
      addInteractiveTarget: function(t) {
        return this._map._targets[g(t)] = this, this;
      },
      removeInteractiveTarget: function(t) {
        return delete this._map._targets[g(t)], this;
      },
      // @method getAttribution: String
      // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(t) {
        var e = t.target;
        if (e.hasLayer(this)) {
          if (this._map = e, this._zoomAnimated = e._zoomAnimated, this.getEvents) {
            var i = this.getEvents();
            e.on(i, this), this.once("remove", function() {
              e.off(i, this);
            }, this);
          }
          this.onAdd(e), this.fire("add"), e.fire("layeradd", { layer: this });
        }
      }
    });
    j.include({
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the map
      addLayer: function(t) {
        if (!t._layerAdd)
          throw new Error("The provided object is not a Layer.");
        var e = g(t);
        return this._layers[e] ? this : (this._layers[e] = t, t._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t), this);
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the map.
      removeLayer: function(t) {
        var e = g(t);
        return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null, this) : this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the map
      hasLayer: function(t) {
        return g(t) in this._layers;
      },
      /* @method eachLayer(fn: Function, context?: Object): this
       * Iterates over the layers of the map, optionally specifying context of the iterator function.
       * ```
       * map.eachLayer(function(layer){
       *     layer.bindPopup('Hello');
       * });
       * ```
       */
      eachLayer: function(t, e) {
        for (var i in this._layers)
          t.call(e, this._layers[i]);
        return this;
      },
      _addLayers: function(t) {
        t = t ? B(t) ? t : [t] : [];
        for (var e = 0, i = t.length; e < i; e++)
          this.addLayer(t[e]);
      },
      _addZoomLimit: function(t) {
        (!isNaN(t.options.maxZoom) || !isNaN(t.options.minZoom)) && (this._zoomBoundLayers[g(t)] = t, this._updateZoomLevels());
      },
      _removeZoomLimit: function(t) {
        var e = g(t);
        this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels());
      },
      _updateZoomLevels: function() {
        var t = 1 / 0, e = -1 / 0, i = this._getZoomSpan();
        for (var n in this._zoomBoundLayers) {
          var s = this._zoomBoundLayers[n].options;
          t = s.minZoom === void 0 ? t : Math.min(t, s.minZoom), e = s.maxZoom === void 0 ? e : Math.max(e, s.maxZoom);
        }
        this._layersMaxZoom = e === -1 / 0 ? void 0 : e, this._layersMinZoom = t === 1 / 0 ? void 0 : t, i !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
      }
    });
    var re = Ct.extend({
      initialize: function(t, e) {
        x(this, e), this._layers = {};
        var i, n;
        if (t)
          for (i = 0, n = t.length; i < n; i++)
            this.addLayer(t[i]);
      },
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the group.
      addLayer: function(t) {
        var e = this.getLayerId(t);
        return this._layers[e] = t, this._map && this._map.addLayer(t), this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the group.
      // @alternative
      // @method removeLayer(id: Number): this
      // Removes the layer with the given internal ID from the group.
      removeLayer: function(t) {
        var e = t in this._layers ? t : this.getLayerId(t);
        return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the group.
      // @alternative
      // @method hasLayer(id: Number): Boolean
      // Returns `true` if the given internal ID is currently added to the group.
      hasLayer: function(t) {
        var e = typeof t == "number" ? t : this.getLayerId(t);
        return e in this._layers;
      },
      // @method clearLayers(): this
      // Removes all the layers from the group.
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      // @method invoke(methodName: String, ): this
      // Calls `methodName` on every layer contained in this group, passing any
      // additional parameters. Has no effect if the layers contained do not
      // implement `methodName`.
      invoke: function(t) {
        var e = Array.prototype.slice.call(arguments, 1), i, n;
        for (i in this._layers)
          n = this._layers[i], n[t] && n[t].apply(n, e);
        return this;
      },
      onAdd: function(t) {
        this.eachLayer(t.addLayer, t);
      },
      onRemove: function(t) {
        this.eachLayer(t.removeLayer, t);
      },
      // @method eachLayer(fn: Function, context?: Object): this
      // Iterates over the layers of the group, optionally specifying context of the iterator function.
      // ```js
      // group.eachLayer(function (layer) {
      // 	layer.bindPopup('Hello');
      // });
      // ```
      eachLayer: function(t, e) {
        for (var i in this._layers)
          t.call(e, this._layers[i]);
        return this;
      },
      // @method getLayer(id: Number): Layer
      // Returns the layer with the given internal ID.
      getLayer: function(t) {
        return this._layers[t];
      },
      // @method getLayers(): Layer[]
      // Returns an array of all the layers added to the group.
      getLayers: function() {
        var t = [];
        return this.eachLayer(t.push, t), t;
      },
      // @method setZIndex(zIndex: Number): this
      // Calls `setZIndex` on every layer contained in this group, passing the z-index.
      setZIndex: function(t) {
        return this.invoke("setZIndex", t);
      },
      // @method getLayerId(layer: Layer): Number
      // Returns the internal ID for a layer
      getLayerId: function(t) {
        return g(t);
      }
    }), is = function(t, e) {
      return new re(t, e);
    }, kt = re.extend({
      addLayer: function(t) {
        return this.hasLayer(t) ? this : (t.addEventParent(this), re.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t }));
      },
      removeLayer: function(t) {
        return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), re.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this;
      },
      // @method setStyle(style: Path options): this
      // Sets the given path options to each layer of the group that has a `setStyle` method.
      setStyle: function(t) {
        return this.invoke("setStyle", t);
      },
      // @method bringToFront(): this
      // Brings the layer group to the top of all other layers
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      // @method bringToBack(): this
      // Brings the layer group to the back of all other layers
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      // @method getBounds(): LatLngBounds
      // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
      getBounds: function() {
        var t = new mt();
        for (var e in this._layers) {
          var i = this._layers[e];
          t.extend(i.getBounds ? i.getBounds() : i.getLatLng());
        }
        return t;
      }
    }), ns = function(t, e) {
      return new kt(t, e);
    }, se = J.extend({
      /* @section
       * @aka Icon options
       *
       * @option iconUrl: String = null
       * **(required)** The URL to the icon image (absolute or relative to your script path).
       *
       * @option iconRetinaUrl: String = null
       * The URL to a retina sized version of the icon image (absolute or relative to your
       * script path). Used for Retina screen devices.
       *
       * @option iconSize: Point = null
       * Size of the icon image in pixels.
       *
       * @option iconAnchor: Point = null
       * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
       * will be aligned so that this point is at the marker's geographical location. Centered
       * by default if size is specified, also can be set in CSS with negative margins.
       *
       * @option popupAnchor: Point = [0, 0]
       * The coordinates of the point from which popups will "open", relative to the icon anchor.
       *
       * @option tooltipAnchor: Point = [0, 0]
       * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
       *
       * @option shadowUrl: String = null
       * The URL to the icon shadow image. If not specified, no shadow image will be created.
       *
       * @option shadowRetinaUrl: String = null
       *
       * @option shadowSize: Point = null
       * Size of the shadow image in pixels.
       *
       * @option shadowAnchor: Point = null
       * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
       * as iconAnchor if not specified).
       *
       * @option className: String = ''
       * A custom class name to assign to both icon and shadow images. Empty by default.
       */
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0],
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1
      },
      initialize: function(t) {
        x(this, t);
      },
      // @method createIcon(oldIcon?: HTMLElement): HTMLElement
      // Called internally when the icon has to be shown, returns a `<img>` HTML element
      // styled according to the options.
      createIcon: function(t) {
        return this._createIcon("icon", t);
      },
      // @method createShadow(oldIcon?: HTMLElement): HTMLElement
      // As `createIcon`, but for the shadow beneath it.
      createShadow: function(t) {
        return this._createIcon("shadow", t);
      },
      _createIcon: function(t, e) {
        var i = this._getIconUrl(t);
        if (!i) {
          if (t === "icon")
            throw new Error("iconUrl not set in Icon options (see the docs).");
          return null;
        }
        var n = this._createImg(i, e && e.tagName === "IMG" ? e : null);
        return this._setIconStyles(n, t), (this.options.crossOrigin || this.options.crossOrigin === "") && (n.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), n;
      },
      _setIconStyles: function(t, e) {
        var i = this.options, n = i[e + "Size"];
        typeof n == "number" && (n = [n, n]);
        var s = I(n), c = I(e === "shadow" && i.shadowAnchor || i.iconAnchor || s && s.divideBy(2, !0));
        t.className = "leaflet-marker-" + e + " " + (i.className || ""), c && (t.style.marginLeft = -c.x + "px", t.style.marginTop = -c.y + "px"), s && (t.style.width = s.x + "px", t.style.height = s.y + "px");
      },
      _createImg: function(t, e) {
        return e = e || document.createElement("img"), e.src = t, e;
      },
      _getIconUrl: function(t) {
        return T.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"];
      }
    });
    function os(t) {
      return new se(t);
    }
    var xe = se.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(t) {
        return typeof xe.imagePath != "string" && (xe.imagePath = this._detectIconPath()), (this.options.imagePath || xe.imagePath) + se.prototype._getIconUrl.call(this, t);
      },
      _stripUrl: function(t) {
        var e = function(i, n, s) {
          var c = n.exec(i);
          return c && c[s];
        };
        return t = e(t, /^url\((['"])?(.+)\1\)$/, 2), t && e(t, /^(.*)marker-icon\.png$/, 1);
      },
      _detectIconPath: function() {
        var t = q("div", "leaflet-default-icon-path", document.body), e = me(t, "background-image") || me(t, "backgroundImage");
        if (document.body.removeChild(t), e = this._stripUrl(e), e)
          return e;
        var i = document.querySelector('link[href$="leaflet.css"]');
        return i ? i.href.substring(0, i.href.length - 11 - 1) : "";
      }
    }), ho = Lt.extend({
      initialize: function(t) {
        this._marker = t;
      },
      addHooks: function() {
        var t = this._marker._icon;
        this._draggable || (this._draggable = new Nt(t, t, !0)), this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable(), D(t, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable(), this._marker._icon && nt(this._marker._icon, "leaflet-marker-draggable");
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(t) {
        var e = this._marker, i = e._map, n = this._marker.options.autoPanSpeed, s = this._marker.options.autoPanPadding, c = qt(e._icon), f = i.getPixelBounds(), m = i.getPixelOrigin(), v = pt(
          f.min._subtract(m).add(s),
          f.max._subtract(m).subtract(s)
        );
        if (!v.contains(c)) {
          var b = I(
            (Math.max(v.max.x, c.x) - v.max.x) / (f.max.x - v.max.x) - (Math.min(v.min.x, c.x) - v.min.x) / (f.min.x - v.min.x),
            (Math.max(v.max.y, c.y) - v.max.y) / (f.max.y - v.max.y) - (Math.min(v.min.y, c.y) - v.min.y) / (f.min.y - v.min.y)
          ).multiplyBy(n);
          i.panBy(b, { animate: !1 }), this._draggable._newPos._add(b), this._draggable._startPos._add(b), at(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = Q(this._adjustPan.bind(this, t));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(t) {
        this._marker.options.autoPan && (it(this._panRequest), this._panRequest = Q(this._adjustPan.bind(this, t)));
      },
      _onDrag: function(t) {
        var e = this._marker, i = e._shadow, n = qt(e._icon), s = e._map.layerPointToLatLng(n);
        i && at(i, n), e._latlng = s, t.latlng = s, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t);
      },
      _onDragEnd: function(t) {
        it(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t);
      }
    }), De = Ct.extend({
      // @section
      // @aka Marker options
      options: {
        // @option icon: Icon = *
        // Icon instance to use for rendering the marker.
        // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
        // If not specified, a common instance of `L.Icon.Default` is used.
        icon: new xe(),
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option keyboard: Boolean = true
        // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
        keyboard: !0,
        // @option title: String = ''
        // Text for the browser tooltip that appear on marker hover (no tooltip by default).
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        title: "",
        // @option alt: String = 'Marker'
        // Text for the `alt` attribute of the icon image.
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        alt: "Marker",
        // @option zIndexOffset: Number = 0
        // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
        zIndexOffset: 0,
        // @option opacity: Number = 1.0
        // The opacity of the marker.
        opacity: 1,
        // @option riseOnHover: Boolean = false
        // If `true`, the marker will get on top of others when you hover the mouse over it.
        riseOnHover: !1,
        // @option riseOffset: Number = 250
        // The z-index offset used for the `riseOnHover` feature.
        riseOffset: 250,
        // @option pane: String = 'markerPane'
        // `Map pane` where the markers icon will be added.
        pane: "markerPane",
        // @option shadowPane: String = 'shadowPane'
        // `Map pane` where the markers shadow will be added.
        shadowPane: "shadowPane",
        // @option bubblingMouseEvents: Boolean = false
        // When `true`, a mouse event on this marker will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !1,
        // @option autoPanOnFocus: Boolean = true
        // When `true`, the map will pan whenever the marker is focused (via
        // e.g. pressing `tab` on the keyboard) to ensure the marker is
        // visible within the map's bounds
        autoPanOnFocus: !0,
        // @section Draggable marker options
        // @option draggable: Boolean = false
        // Whether the marker is draggable with mouse/touch or not.
        draggable: !1,
        // @option autoPan: Boolean = false
        // Whether to pan the map when dragging this marker near its edge or not.
        autoPan: !1,
        // @option autoPanPadding: Point = Point(50, 50)
        // Distance (in pixels to the left/right and to the top/bottom) of the
        // map edge to start panning the map.
        autoPanPadding: [50, 50],
        // @option autoPanSpeed: Number = 10
        // Number of pixels the map should pan by.
        autoPanSpeed: 10
      },
      /* @section
       *
       * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
       */
      initialize: function(t, e) {
        x(this, e), this._latlng = U(t);
      },
      onAdd: function(t) {
        this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
      },
      onRemove: function(t) {
        this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      // @method getLatLng: LatLng
      // Returns the current geographical position of the marker.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Changes the marker position to the given point.
      setLatLng: function(t) {
        var e = this._latlng;
        return this._latlng = U(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng });
      },
      // @method setZIndexOffset(offset: Number): this
      // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
      setZIndexOffset: function(t) {
        return this.options.zIndexOffset = t, this.update();
      },
      // @method getIcon: Icon
      // Returns the current icon used by the marker
      getIcon: function() {
        return this.options.icon;
      },
      // @method setIcon(icon: Icon): this
      // Changes the marker icon.
      setIcon: function(t) {
        return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var t = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(t);
        }
        return this;
      },
      _initIcon: function() {
        var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i = t.icon.createIcon(this._icon), n = !1;
        i !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (i.title = t.title), i.tagName === "IMG" && (i.alt = t.alt || "")), D(i, e), t.keyboard && (i.tabIndex = "0", i.setAttribute("role", "button")), this._icon = i, t.riseOnHover && this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && z(i, "focus", this._panOnFocus, this);
        var s = t.icon.createShadow(this._shadow), c = !1;
        s !== this._shadow && (this._removeShadow(), c = !0), s && (D(s, e), s.alt = ""), this._shadow = s, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), s && c && this.getPane(t.shadowPane).appendChild(this._shadow);
      },
      _removeIcon: function() {
        this.options.riseOnHover && this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        }), this.options.autoPanOnFocus && X(this._icon, "focus", this._panOnFocus, this), et(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
      },
      _removeShadow: function() {
        this._shadow && et(this._shadow), this._shadow = null;
      },
      _setPos: function(t) {
        this._icon && at(this._icon, t), this._shadow && at(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex();
      },
      _updateZIndex: function(t) {
        this._icon && (this._icon.style.zIndex = this._zIndex + t);
      },
      _animateZoom: function(t) {
        var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
        this._setPos(e);
      },
      _initInteraction: function() {
        if (this.options.interactive && (D(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), ho)) {
          var t = this.options.draggable;
          this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new ho(this), t && this.dragging.enable();
        }
      },
      // @method setOpacity(opacity: Number): this
      // Changes the opacity of the marker.
      setOpacity: function(t) {
        return this.options.opacity = t, this._map && this._updateOpacity(), this;
      },
      _updateOpacity: function() {
        var t = this.options.opacity;
        this._icon && _t(this._icon, t), this._shadow && _t(this._shadow, t);
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _panOnFocus: function() {
        var t = this._map;
        if (t) {
          var e = this.options.icon.options, i = e.iconSize ? I(e.iconSize) : I(0, 0), n = e.iconAnchor ? I(e.iconAnchor) : I(0, 0);
          t.panInside(this._latlng, {
            paddingTopLeft: n,
            paddingBottomRight: i.subtract(n)
          });
        }
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function rs(t, e) {
      return new De(t, e);
    }
    var Ht = Ct.extend({
      // @section
      // @aka Path options
      options: {
        // @option stroke: Boolean = true
        // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
        stroke: !0,
        // @option color: String = '#3388ff'
        // Stroke color
        color: "#3388ff",
        // @option weight: Number = 3
        // Stroke width in pixels
        weight: 3,
        // @option opacity: Number = 1.0
        // Stroke opacity
        opacity: 1,
        // @option lineCap: String= 'round'
        // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
        lineCap: "round",
        // @option lineJoin: String = 'round'
        // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
        lineJoin: "round",
        // @option dashArray: String = null
        // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashArray: null,
        // @option dashOffset: String = null
        // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashOffset: null,
        // @option fill: Boolean = depends
        // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
        fill: !1,
        // @option fillColor: String = *
        // Fill color. Defaults to the value of the [`color`](#path-color) option
        fillColor: null,
        // @option fillOpacity: Number = 0.2
        // Fill opacity.
        fillOpacity: 0.2,
        // @option fillRule: String = 'evenodd'
        // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
        fillRule: "evenodd",
        // className: '',
        // Option inherited from "Interactive layer" abstract class
        interactive: !0,
        // @option bubblingMouseEvents: Boolean = true
        // When `true`, a mouse event on this path will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: !0
      },
      beforeAdd: function(t) {
        this._renderer = t.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      // @method redraw(): this
      // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
      redraw: function() {
        return this._map && this._renderer._updatePath(this), this;
      },
      // @method setStyle(style: Path options): this
      // Changes the appearance of a Path based on the options in the `Path options` object.
      setStyle: function(t) {
        return x(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all path layers.
      bringToFront: function() {
        return this._renderer && this._renderer._bringToFront(this), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all path layers.
      bringToBack: function() {
        return this._renderer && this._renderer._bringToBack(this), this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project(), this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
      }
    }), Ne = Ht.extend({
      // @section
      // @aka CircleMarker options
      options: {
        fill: !0,
        // @option radius: Number = 10
        // Radius of the circle marker, in pixels
        radius: 10
      },
      initialize: function(t, e) {
        x(this, e), this._latlng = U(t), this._radius = this.options.radius;
      },
      // @method setLatLng(latLng: LatLng): this
      // Sets the position of a circle marker to a new location.
      setLatLng: function(t) {
        var e = this._latlng;
        return this._latlng = U(t), this.redraw(), this.fire("move", { oldLatLng: e, latlng: this._latlng });
      },
      // @method getLatLng(): LatLng
      // Returns the current geographical position of the circle marker
      getLatLng: function() {
        return this._latlng;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle marker. Units are in pixels.
      setRadius: function(t) {
        return this.options.radius = this._radius = t, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of the circle
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(t) {
        var e = t && t.radius || this._radius;
        return Ht.prototype.setStyle.call(this, t), this.setRadius(e), this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
      },
      _updateBounds: function() {
        var t = this._radius, e = this._radiusY || t, i = this._clickTolerance(), n = [t + i, e + i];
        this._pxBounds = new tt(this._point.subtract(n), this._point.add(n));
      },
      _update: function() {
        this._map && this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(t) {
        return t.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function ss(t, e) {
      return new Ne(t, e);
    }
    var Ni = Ne.extend({
      initialize: function(t, e, i) {
        if (typeof e == "number" && (e = l({}, i, { radius: e })), x(this, e), this._latlng = U(t), isNaN(this.options.radius))
          throw new Error("Circle radius cannot be NaN");
        this._mRadius = this.options.radius;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle. Units are in meters.
      setRadius: function(t) {
        return this._mRadius = t, this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of a circle. Units are in meters.
      getRadius: function() {
        return this._mRadius;
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        var t = [this._radius, this._radiusY || this._radius];
        return new mt(
          this._map.layerPointToLatLng(this._point.subtract(t)),
          this._map.layerPointToLatLng(this._point.add(t))
        );
      },
      setStyle: Ht.prototype.setStyle,
      _project: function() {
        var t = this._latlng.lng, e = this._latlng.lat, i = this._map, n = i.options.crs;
        if (n.distance === Dt.distance) {
          var s = Math.PI / 180, c = this._mRadius / Dt.R / s, f = i.project([e + c, t]), m = i.project([e - c, t]), v = f.add(m).divideBy(2), b = i.unproject(v).lat, A = Math.acos((Math.cos(c * s) - Math.sin(e * s) * Math.sin(b * s)) / (Math.cos(e * s) * Math.cos(b * s))) / s;
          (isNaN(A) || A === 0) && (A = c / Math.cos(Math.PI / 180 * e)), this._point = v.subtract(i.getPixelOrigin()), this._radius = isNaN(A) ? 0 : v.x - i.project([b, t - A]).x, this._radiusY = v.y - f.y;
        } else {
          var M = n.unproject(n.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = i.latLngToLayerPoint(this._latlng), this._radius = this._point.x - i.latLngToLayerPoint(M).x;
        }
        this._updateBounds();
      }
    });
    function as(t, e, i) {
      return new Ni(t, e, i);
    }
    var Bt = Ht.extend({
      // @section
      // @aka Polyline options
      options: {
        // @option smoothFactor: Number = 1.0
        // How much to simplify the polyline on each zoom level. More means
        // better performance and smoother look, and less means more accurate representation.
        smoothFactor: 1,
        // @option noClip: Boolean = false
        // Disable polyline clipping.
        noClip: !1
      },
      initialize: function(t, e) {
        x(this, e), this._setLatLngs(t);
      },
      // @method getLatLngs(): LatLng[]
      // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
      getLatLngs: function() {
        return this._latlngs;
      },
      // @method setLatLngs(latlngs: LatLng[]): this
      // Replaces all the points in the polyline with the given array of geographical points.
      setLatLngs: function(t) {
        return this._setLatLngs(t), this.redraw();
      },
      // @method isEmpty(): Boolean
      // Returns `true` if the Polyline has no LatLngs.
      isEmpty: function() {
        return !this._latlngs.length;
      },
      // @method closestLayerPoint(p: Point): Point
      // Returns the point closest to `p` on the Polyline.
      closestLayerPoint: function(t) {
        for (var e = 1 / 0, i = null, n = we, s, c, f = 0, m = this._parts.length; f < m; f++)
          for (var v = this._parts[f], b = 1, A = v.length; b < A; b++) {
            s = v[b - 1], c = v[b];
            var M = n(t, s, c, !0);
            M < e && (e = M, i = n(t, s, c));
          }
        return i && (i.distance = Math.sqrt(e)), i;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return so(this._defaultShape(), this._map.options.crs);
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        return this._bounds;
      },
      // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
      // Adds a given point to the polyline. By default, adds to the first ring of
      // the polyline in case of a multi-polyline, but can be overridden by passing
      // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
      addLatLng: function(t, e) {
        return e = e || this._defaultShape(), t = U(t), e.push(t), this._bounds.extend(t), this.redraw();
      },
      _setLatLngs: function(t) {
        this._bounds = new mt(), this._latlngs = this._convertLatLngs(t);
      },
      _defaultShape: function() {
        return bt(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
      _convertLatLngs: function(t) {
        for (var e = [], i = bt(t), n = 0, s = t.length; n < s; n++)
          i ? (e[n] = U(t[n]), this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]);
        return e;
      },
      _project: function() {
        var t = new tt();
        this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds());
      },
      _updateBounds: function() {
        var t = this._clickTolerance(), e = new O(t, t);
        this._rawPxBounds && (this._pxBounds = new tt([
          this._rawPxBounds.min.subtract(e),
          this._rawPxBounds.max.add(e)
        ]));
      },
      // recursively turns latlngs into a set of rings with projected coordinates
      _projectLatlngs: function(t, e, i) {
        var n = t[0] instanceof W, s = t.length, c, f;
        if (n) {
          for (f = [], c = 0; c < s; c++)
            f[c] = this._map.latLngToLayerPoint(t[c]), i.extend(f[c]);
          e.push(f);
        } else
          for (c = 0; c < s; c++)
            this._projectLatlngs(t[c], e, i);
      },
      // clip polyline by renderer bounds so that we have less to render for performance
      _clipPoints: function() {
        var t = this._renderer._bounds;
        if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(t))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var e = this._parts, i, n, s, c, f, m, v;
          for (i = 0, s = 0, c = this._rings.length; i < c; i++)
            for (v = this._rings[i], n = 0, f = v.length; n < f - 1; n++)
              m = oo(v[n], v[n + 1], t, n, !0), m && (e[s] = e[s] || [], e[s].push(m[0]), (m[1] !== v[n + 1] || n === f - 2) && (e[s].push(m[1]), s++));
        }
      },
      // simplify each clipped part of the polyline for performance
      _simplifyPoints: function() {
        for (var t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++)
          t[i] = eo(t[i], e);
      },
      _update: function() {
        this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(t, e) {
        var i, n, s, c, f, m, v = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(t))
          return !1;
        for (i = 0, c = this._parts.length; i < c; i++)
          for (m = this._parts[i], n = 0, f = m.length, s = f - 1; n < f; s = n++)
            if (!(!e && n === 0) && io(t, m[s], m[n]) <= v)
              return !0;
        return !1;
      }
    });
    function hs(t, e) {
      return new Bt(t, e);
    }
    Bt._flat = ro;
    var ae = Bt.extend({
      options: {
        fill: !0
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
      getCenter: function() {
        if (!this._map)
          throw new Error("Must add layer to map before using getCenter()");
        return to(this._defaultShape(), this._map.options.crs);
      },
      _convertLatLngs: function(t) {
        var e = Bt.prototype._convertLatLngs.call(this, t), i = e.length;
        return i >= 2 && e[0] instanceof W && e[0].equals(e[i - 1]) && e.pop(), e;
      },
      _setLatLngs: function(t) {
        Bt.prototype._setLatLngs.call(this, t), bt(this._latlngs) && (this._latlngs = [this._latlngs]);
      },
      _defaultShape: function() {
        return bt(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var t = this._renderer._bounds, e = this.options.weight, i = new O(e, e);
        if (t = new tt(t.min.subtract(i), t.max.add(i)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(t))) {
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var n = 0, s = this._rings.length, c; n < s; n++)
            c = $n(this._rings[n], t, !0), c.length && this._parts.push(c);
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, !0);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(t) {
        var e = !1, i, n, s, c, f, m, v, b;
        if (!this._pxBounds || !this._pxBounds.contains(t))
          return !1;
        for (c = 0, v = this._parts.length; c < v; c++)
          for (i = this._parts[c], f = 0, b = i.length, m = b - 1; f < b; m = f++)
            n = i[f], s = i[m], n.y > t.y != s.y > t.y && t.x < (s.x - n.x) * (t.y - n.y) / (s.y - n.y) + n.x && (e = !e);
        return e || Bt.prototype._containsPoint.call(this, t, !0);
      }
    });
    function ls(t, e) {
      return new ae(t, e);
    }
    var It = kt.extend({
      /* @section
       * @aka GeoJSON options
       *
       * @option pointToLayer: Function = *
       * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
       * called when data is added, passing the GeoJSON point feature and its `LatLng`.
       * The default is to spawn a default `Marker`:
       * ```js
       * function(geoJsonPoint, latlng) {
       * 	return L.marker(latlng);
       * }
       * ```
       *
       * @option style: Function = *
       * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
       * called internally when data is added.
       * The default value is to not override any defaults:
       * ```js
       * function (geoJsonFeature) {
       * 	return {}
       * }
       * ```
       *
       * @option onEachFeature: Function = *
       * A `Function` that will be called once for each created `Feature`, after it has
       * been created and styled. Useful for attaching events and popups to features.
       * The default is to do nothing with the newly created layers:
       * ```js
       * function (feature, layer) {}
       * ```
       *
       * @option filter: Function = *
       * A `Function` that will be used to decide whether to include a feature or not.
       * The default is to include all features:
       * ```js
       * function (geoJsonFeature) {
       * 	return true;
       * }
       * ```
       * Note: dynamically changing the `filter` option will have effect only on newly
       * added data. It will _not_ re-evaluate already included features.
       *
       * @option coordsToLatLng: Function = *
       * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
       * The default is the `coordsToLatLng` static method.
       *
       * @option markersInheritOptions: Boolean = false
       * Whether default Markers for "Point" type Features inherit from group options.
       */
      initialize: function(t, e) {
        x(this, e), this._layers = {}, t && this.addData(t);
      },
      // @method addData( <GeoJSON> data ): this
      // Adds a GeoJSON object to the layer.
      addData: function(t) {
        var e = B(t) ? t : t.features, i, n, s;
        if (e) {
          for (i = 0, n = e.length; i < n; i++)
            s = e[i], (s.geometries || s.geometry || s.features || s.coordinates) && this.addData(s);
          return this;
        }
        var c = this.options;
        if (c.filter && !c.filter(t))
          return this;
        var f = He(t, c);
        return f ? (f.feature = Ue(t), f.defaultOptions = f.options, this.resetStyle(f), c.onEachFeature && c.onEachFeature(t, f), this.addLayer(f)) : this;
      },
      // @method resetStyle( <Path> layer? ): this
      // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
      // If `layer` is omitted, the style of all features in the current layer is reset.
      resetStyle: function(t) {
        return t === void 0 ? this.eachLayer(this.resetStyle, this) : (t.options = l({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this);
      },
      // @method setStyle( <Function> style ): this
      // Changes styles of GeoJSON vector layers with the given style function.
      setStyle: function(t) {
        return this.eachLayer(function(e) {
          this._setLayerStyle(e, t);
        }, this);
      },
      _setLayerStyle: function(t, e) {
        t.setStyle && (typeof e == "function" && (e = e(t.feature)), t.setStyle(e));
      }
    });
    function He(t, e) {
      var i = t.type === "Feature" ? t.geometry : t, n = i ? i.coordinates : null, s = [], c = e && e.pointToLayer, f = e && e.coordsToLatLng || Hi, m, v, b, A;
      if (!n && !i)
        return null;
      switch (i.type) {
        case "Point":
          return m = f(n), lo(c, t, m, e);
        case "MultiPoint":
          for (b = 0, A = n.length; b < A; b++)
            m = f(n[b]), s.push(lo(c, t, m, e));
          return new kt(s);
        case "LineString":
        case "MultiLineString":
          return v = Ze(n, i.type === "LineString" ? 0 : 1, f), new Bt(v, e);
        case "Polygon":
        case "MultiPolygon":
          return v = Ze(n, i.type === "Polygon" ? 1 : 2, f), new ae(v, e);
        case "GeometryCollection":
          for (b = 0, A = i.geometries.length; b < A; b++) {
            var M = He({
              geometry: i.geometries[b],
              type: "Feature",
              properties: t.properties
            }, e);
            M && s.push(M);
          }
          return new kt(s);
        case "FeatureCollection":
          for (b = 0, A = i.features.length; b < A; b++) {
            var N = He(i.features[b], e);
            N && s.push(N);
          }
          return new kt(s);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function lo(t, e, i, n) {
      return t ? t(e, i) : new De(i, n && n.markersInheritOptions && n);
    }
    function Hi(t) {
      return new W(t[1], t[0], t[2]);
    }
    function Ze(t, e, i) {
      for (var n = [], s = 0, c = t.length, f; s < c; s++)
        f = e ? Ze(t[s], e - 1, i) : (i || Hi)(t[s]), n.push(f);
      return n;
    }
    function Zi(t, e) {
      return t = U(t), t.alt !== void 0 ? [P(t.lng, e), P(t.lat, e), P(t.alt, e)] : [P(t.lng, e), P(t.lat, e)];
    }
    function Fe(t, e, i, n) {
      for (var s = [], c = 0, f = t.length; c < f; c++)
        s.push(e ? Fe(t[c], bt(t[c]) ? 0 : e - 1, i, n) : Zi(t[c], n));
      return !e && i && s.length > 0 && s.push(s[0].slice()), s;
    }
    function he(t, e) {
      return t.feature ? l({}, t.feature, { geometry: e }) : Ue(e);
    }
    function Ue(t) {
      return t.type === "Feature" || t.type === "FeatureCollection" ? t : {
        type: "Feature",
        properties: {},
        geometry: t
      };
    }
    var Fi = {
      toGeoJSON: function(t) {
        return he(this, {
          type: "Point",
          coordinates: Zi(this.getLatLng(), t)
        });
      }
    };
    De.include(Fi), Ni.include(Fi), Ne.include(Fi), Bt.include({
      toGeoJSON: function(t) {
        var e = !bt(this._latlngs), i = Fe(this._latlngs, e ? 1 : 0, !1, t);
        return he(this, {
          type: (e ? "Multi" : "") + "LineString",
          coordinates: i
        });
      }
    }), ae.include({
      toGeoJSON: function(t) {
        var e = !bt(this._latlngs), i = e && !bt(this._latlngs[0]), n = Fe(this._latlngs, i ? 2 : e ? 1 : 0, !0, t);
        return e || (n = [n]), he(this, {
          type: (i ? "Multi" : "") + "Polygon",
          coordinates: n
        });
      }
    }), re.include({
      toMultiPoint: function(t) {
        var e = [];
        return this.eachLayer(function(i) {
          e.push(i.toGeoJSON(t).geometry.coordinates);
        }), he(this, {
          type: "MultiPoint",
          coordinates: e
        });
      },
      // @method toGeoJSON(precision?: Number|false): Object
      // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
      // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
      toGeoJSON: function(t) {
        var e = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (e === "MultiPoint")
          return this.toMultiPoint(t);
        var i = e === "GeometryCollection", n = [];
        return this.eachLayer(function(s) {
          if (s.toGeoJSON) {
            var c = s.toGeoJSON(t);
            if (i)
              n.push(c.geometry);
            else {
              var f = Ue(c);
              f.type === "FeatureCollection" ? n.push.apply(n, f.features) : n.push(f);
            }
          }
        }), i ? he(this, {
          geometries: n,
          type: "GeometryCollection"
        }) : {
          type: "FeatureCollection",
          features: n
        };
      }
    });
    function co(t, e) {
      return new It(t, e);
    }
    var cs = co, je = Ct.extend({
      // @section
      // @aka ImageOverlay options
      options: {
        // @option opacity: Number = 1.0
        // The opacity of the image overlay.
        opacity: 1,
        // @option alt: String = ''
        // Text for the `alt` attribute of the image (useful for accessibility).
        alt: "",
        // @option interactive: Boolean = false
        // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
        interactive: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the image.
        // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option errorOverlayUrl: String = ''
        // URL to the overlay image to show in place of the overlay that failed to load.
        errorOverlayUrl: "",
        // @option zIndex: Number = 1
        // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
        zIndex: 1,
        // @option className: String = ''
        // A custom class name to assign to the image. Empty by default.
        className: ""
      },
      initialize: function(t, e, i) {
        this._url = t, this._bounds = st(e), x(this, i);
      },
      onAdd: function() {
        this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (D(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
      },
      onRemove: function() {
        et(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
      },
      // @method setOpacity(opacity: Number): this
      // Sets the opacity of the overlay.
      setOpacity: function(t) {
        return this.options.opacity = t, this._image && this._updateOpacity(), this;
      },
      setStyle: function(t) {
        return t.opacity && this.setOpacity(t.opacity), this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all overlays.
      bringToFront: function() {
        return this._map && ne(this._image), this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all overlays.
      bringToBack: function() {
        return this._map && oe(this._image), this;
      },
      // @method setUrl(url: String): this
      // Changes the URL of the image.
      setUrl: function(t) {
        return this._url = t, this._image && (this._image.src = t), this;
      },
      // @method setBounds(bounds: LatLngBounds): this
      // Update the bounds that this ImageOverlay covers
      setBounds: function(t) {
        return this._bounds = st(t), this._map && this._reset(), this;
      },
      getEvents: function() {
        var t = {
          zoom: this._reset,
          viewreset: this._reset
        };
        return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
      },
      // @method setZIndex(value: Number): this
      // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
      setZIndex: function(t) {
        return this.options.zIndex = t, this._updateZIndex(), this;
      },
      // @method getBounds(): LatLngBounds
      // Get the bounds that this ImageOverlay covers
      getBounds: function() {
        return this._bounds;
      },
      // @method getElement(): HTMLElement
      // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
      // used by this overlay.
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var t = this._url.tagName === "IMG", e = this._image = t ? this._url : q("img");
        if (D(e, "leaflet-image-layer"), this._zoomAnimated && D(e, "leaflet-zoom-animated"), this.options.className && D(e, this.options.className), e.onselectstart = w, e.onmousemove = w, e.onload = u(this.fire, this, "load"), e.onerror = u(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (e.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t) {
          this._url = e.src;
          return;
        }
        e.src = this._url, e.alt = this.options.alt;
      },
      _animateZoom: function(t) {
        var e = this._map.getZoomScale(t.zoom), i = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
        jt(this._image, i, e);
      },
      _reset: function() {
        var t = this._image, e = new tt(
          this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          this._map.latLngToLayerPoint(this._bounds.getSouthEast())
        ), i = e.getSize();
        at(t, e.min), t.style.width = i.x + "px", t.style.height = i.y + "px";
      },
      _updateOpacity: function() {
        _t(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
      },
      _overlayOnError: function() {
        this.fire("error");
        var t = this.options.errorOverlayUrl;
        t && this._url !== t && (this._url = t, this._image.src = t);
      },
      // @method getCenter(): LatLng
      // Returns the center of the ImageOverlay.
      getCenter: function() {
        return this._bounds.getCenter();
      }
    }), us = function(t, e, i) {
      return new je(t, e, i);
    }, uo = je.extend({
      // @section
      // @aka VideoOverlay options
      options: {
        // @option autoplay: Boolean = true
        // Whether the video starts playing automatically when loaded.
        // On some browsers autoplay will only work with `muted: true`
        autoplay: !0,
        // @option loop: Boolean = true
        // Whether the video will loop back to the beginning when played.
        loop: !0,
        // @option keepAspectRatio: Boolean = true
        // Whether the video will save aspect ratio after the projection.
        // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
        keepAspectRatio: !0,
        // @option muted: Boolean = false
        // Whether the video starts on mute when loaded.
        muted: !1,
        // @option playsInline: Boolean = true
        // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
        playsInline: !0
      },
      _initImage: function() {
        var t = this._url.tagName === "VIDEO", e = this._image = t ? this._url : q("video");
        if (D(e, "leaflet-image-layer"), this._zoomAnimated && D(e, "leaflet-zoom-animated"), this.options.className && D(e, this.options.className), e.onselectstart = w, e.onmousemove = w, e.onloadeddata = u(this.fire, this, "load"), t) {
          for (var i = e.getElementsByTagName("source"), n = [], s = 0; s < i.length; s++)
            n.push(i[s].src);
          this._url = i.length > 0 ? n : [e.src];
          return;
        }
        B(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop, e.muted = !!this.options.muted, e.playsInline = !!this.options.playsInline;
        for (var c = 0; c < this._url.length; c++) {
          var f = q("source");
          f.src = this._url[c], e.appendChild(f);
        }
      }
      // @method getElement(): HTMLVideoElement
      // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
      // used by this overlay.
    });
    function ds(t, e, i) {
      return new uo(t, e, i);
    }
    var fo = je.extend({
      _initImage: function() {
        var t = this._image = this._url;
        D(t, "leaflet-image-layer"), this._zoomAnimated && D(t, "leaflet-zoom-animated"), this.options.className && D(t, this.options.className), t.onselectstart = w, t.onmousemove = w;
      }
      // @method getElement(): SVGElement
      // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
      // used by this overlay.
    });
    function fs(t, e, i) {
      return new fo(t, e, i);
    }
    var Tt = Ct.extend({
      // @section
      // @aka DivOverlay options
      options: {
        // @option interactive: Boolean = false
        // If true, the popup/tooltip will listen to the mouse events.
        interactive: !1,
        // @option offset: Point = Point(0, 0)
        // The offset of the overlay position.
        offset: [0, 0],
        // @option className: String = ''
        // A custom CSS class name to assign to the overlay.
        className: "",
        // @option pane: String = undefined
        // `Map pane` where the overlay will be added.
        pane: void 0,
        // @option content: String|HTMLElement|Function = ''
        // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
        // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
        content: ""
      },
      initialize: function(t, e) {
        t && (t instanceof W || B(t)) ? (this._latlng = U(t), x(this, e)) : (x(this, t), this._source = e), this.options.content && (this._content = this.options.content);
      },
      // @method openOn(map: Map): this
      // Adds the overlay to the map.
      // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
      openOn: function(t) {
        return t = arguments.length ? t : this._source._map, t.hasLayer(this) || t.addLayer(this), this;
      },
      // @method close(): this
      // Closes the overlay.
      // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
      // and `layer.closePopup()`/`.closeTooltip()`.
      close: function() {
        return this._map && this._map.removeLayer(this), this;
      },
      // @method toggle(layer?: Layer): this
      // Opens or closes the overlay bound to layer depending on its current state.
      // Argument may be omitted only for overlay bound to layer.
      // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
      toggle: function(t) {
        return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source, this._prepareOpen(), this.openOn(t._map)), this;
      },
      onAdd: function(t) {
        this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && _t(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && _t(this._container, 1), this.bringToFront(), this.options.interactive && (D(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
      },
      onRemove: function(t) {
        t._fadeAnimated ? (_t(this._container, 0), this._removeTimeout = setTimeout(u(et, void 0, this._container), 200)) : et(this._container), this.options.interactive && (nt(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
      },
      // @namespace DivOverlay
      // @method getLatLng: LatLng
      // Returns the geographical point of the overlay.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Sets the geographical point where the overlay will open.
      setLatLng: function(t) {
        return this._latlng = U(t), this._map && (this._updatePosition(), this._adjustPan()), this;
      },
      // @method getContent: String|HTMLElement
      // Returns the content of the overlay.
      getContent: function() {
        return this._content;
      },
      // @method setContent(htmlContent: String|HTMLElement|Function): this
      // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
      // The function should return a `String` or `HTMLElement` to be used in the overlay.
      setContent: function(t) {
        return this._content = t, this.update(), this;
      },
      // @method getElement: String|HTMLElement
      // Returns the HTML container of the overlay.
      getElement: function() {
        return this._container;
      },
      // @method update: null
      // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
      update: function() {
        this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
      },
      getEvents: function() {
        var t = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
      },
      // @method isOpen: Boolean
      // Returns `true` when the overlay is visible on the map.
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      // @method bringToFront: this
      // Brings this overlay in front of other overlays (in the same map pane).
      bringToFront: function() {
        return this._map && ne(this._container), this;
      },
      // @method bringToBack: this
      // Brings this overlay to the back of other overlays (in the same map pane).
      bringToBack: function() {
        return this._map && oe(this._container), this;
      },
      // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
      _prepareOpen: function(t) {
        var e = this._source;
        if (!e._map)
          return !1;
        if (e instanceof kt) {
          e = null;
          var i = this._source._layers;
          for (var n in i)
            if (i[n]._map) {
              e = i[n];
              break;
            }
          if (!e)
            return !1;
          this._source = e;
        }
        if (!t)
          if (e.getCenter)
            t = e.getCenter();
          else if (e.getLatLng)
            t = e.getLatLng();
          else if (e.getBounds)
            t = e.getBounds().getCenter();
          else
            throw new Error("Unable to get source layer LatLng.");
        return this.setLatLng(t), this._map && this.update(), !0;
      },
      _updateContent: function() {
        if (this._content) {
          var t = this._contentNode, e = typeof this._content == "function" ? this._content(this._source || this) : this._content;
          if (typeof e == "string")
            t.innerHTML = e;
          else {
            for (; t.hasChildNodes(); )
              t.removeChild(t.firstChild);
            t.appendChild(e);
          }
          this.fire("contentupdate");
        }
      },
      _updatePosition: function() {
        if (this._map) {
          var t = this._map.latLngToLayerPoint(this._latlng), e = I(this.options.offset), i = this._getAnchor();
          this._zoomAnimated ? at(this._container, t.add(i)) : e = e.add(t).add(i);
          var n = this._containerBottom = -e.y, s = this._containerLeft = -Math.round(this._containerWidth / 2) + e.x;
          this._container.style.bottom = n + "px", this._container.style.left = s + "px";
        }
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    j.include({
      _initOverlay: function(t, e, i, n) {
        var s = e;
        return s instanceof t || (s = new t(n).setContent(e)), i && s.setLatLng(i), s;
      }
    }), Ct.include({
      _initOverlay: function(t, e, i, n) {
        var s = i;
        return s instanceof t ? (x(s, n), s._source = this) : (s = e && !n ? e : new t(n, this), s.setContent(i)), s;
      }
    });
    var qe = Tt.extend({
      // @section
      // @aka Popup options
      options: {
        // @option pane: String = 'popupPane'
        // `Map pane` where the popup will be added.
        pane: "popupPane",
        // @option offset: Point = Point(0, 7)
        // The offset of the popup position.
        offset: [0, 7],
        // @option maxWidth: Number = 300
        // Max width of the popup, in pixels.
        maxWidth: 300,
        // @option minWidth: Number = 50
        // Min width of the popup, in pixels.
        minWidth: 50,
        // @option maxHeight: Number = null
        // If set, creates a scrollable container of the given height
        // inside a popup if its content exceeds it.
        // The scrollable container can be styled using the
        // `leaflet-popup-scrolled` CSS class selector.
        maxHeight: null,
        // @option autoPan: Boolean = true
        // Set it to `false` if you don't want the map to do panning animation
        // to fit the opened popup.
        autoPan: !0,
        // @option autoPanPaddingTopLeft: Point = null
        // The margin between the popup and the top left corner of the map
        // view after autopanning was performed.
        autoPanPaddingTopLeft: null,
        // @option autoPanPaddingBottomRight: Point = null
        // The margin between the popup and the bottom right corner of the map
        // view after autopanning was performed.
        autoPanPaddingBottomRight: null,
        // @option autoPanPadding: Point = Point(5, 5)
        // Equivalent of setting both top left and bottom right autopan padding to the same value.
        autoPanPadding: [5, 5],
        // @option keepInView: Boolean = false
        // Set it to `true` if you want to prevent users from panning the popup
        // off of the screen while it is open.
        keepInView: !1,
        // @option closeButton: Boolean = true
        // Controls the presence of a close button in the popup.
        closeButton: !0,
        // @option autoClose: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the popup closing when another popup is opened.
        autoClose: !0,
        // @option closeOnEscapeKey: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the ESC key for closing of the popup.
        closeOnEscapeKey: !0,
        // @option closeOnClick: Boolean = *
        // Set it if you want to override the default behavior of the popup closing when user clicks
        // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
        // @option className: String = ''
        // A custom CSS class name to assign to the popup.
        className: ""
      },
      // @namespace Popup
      // @method openOn(map: Map): this
      // Alternative to `map.openPopup(popup)`.
      // Adds the popup to the map and closes the previous one.
      openOn: function(t) {
        return t = arguments.length ? t : this._source._map, !t.hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup), t._popup = this, Tt.prototype.openOn.call(this, t);
      },
      onAdd: function(t) {
        Tt.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Ht || this._source.on("preclick", Vt));
      },
      onRemove: function(t) {
        Tt.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Ht || this._source.off("preclick", Vt));
      },
      getEvents: function() {
        var t = Tt.prototype.getEvents.call(this);
        return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close), this.options.keepInView && (t.moveend = this._adjustPan), t;
      },
      _initLayout: function() {
        var t = "leaflet-popup", e = this._container = q(
          "div",
          t + " " + (this.options.className || "") + " leaflet-zoom-animated"
        ), i = this._wrapper = q("div", t + "-content-wrapper", e);
        if (this._contentNode = q("div", t + "-content", i), _e(e), Mi(this._contentNode), z(e, "contextmenu", Vt), this._tipContainer = q("div", t + "-tip-container", e), this._tip = q("div", t + "-tip", this._tipContainer), this.options.closeButton) {
          var n = this._closeButton = q("a", t + "-close-button", e);
          n.setAttribute("role", "button"), n.setAttribute("aria-label", "Close popup"), n.href = "#close", n.innerHTML = '<span aria-hidden="true">&#215;</span>', z(n, "click", function(s) {
            ut(s), this.close();
          }, this);
        }
      },
      _updateLayout: function() {
        var t = this._contentNode, e = t.style;
        e.width = "", e.whiteSpace = "nowrap";
        var i = t.offsetWidth;
        i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";
        var n = t.offsetHeight, s = this.options.maxHeight, c = "leaflet-popup-scrolled";
        s && n > s ? (e.height = s + "px", D(t, c)) : nt(t, c), this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(t) {
        var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center), i = this._getAnchor();
        at(this._container, e.add(i));
      },
      _adjustPan: function() {
        if (this.options.autoPan) {
          if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
            this._autopanning = !1;
            return;
          }
          var t = this._map, e = parseInt(me(this._container, "marginBottom"), 10) || 0, i = this._container.offsetHeight + e, n = this._containerWidth, s = new O(this._containerLeft, -i - this._containerBottom);
          s._add(qt(this._container));
          var c = t.layerPointToContainerPoint(s), f = I(this.options.autoPanPadding), m = I(this.options.autoPanPaddingTopLeft || f), v = I(this.options.autoPanPaddingBottomRight || f), b = t.getSize(), A = 0, M = 0;
          c.x + n + v.x > b.x && (A = c.x + n - b.x + v.x), c.x - A - m.x < 0 && (A = c.x - m.x), c.y + i + v.y > b.y && (M = c.y + i - b.y + v.y), c.y - M - m.y < 0 && (M = c.y - m.y), (A || M) && (this.options.keepInView && (this._autopanning = !0), t.fire("autopanstart").panBy([A, M]));
        }
      },
      _getAnchor: function() {
        return I(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    }), ps = function(t, e) {
      return new qe(t, e);
    };
    j.mergeOptions({
      closePopupOnClick: !0
    }), j.include({
      // @method openPopup(popup: Popup): this
      // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
      // @alternative
      // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
      // Creates a popup with the specified content and options and opens it in the given point on a map.
      openPopup: function(t, e, i) {
        return this._initOverlay(qe, t, e, i).openOn(this), this;
      },
      // @method closePopup(popup?: Popup): this
      // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
      closePopup: function(t) {
        return t = arguments.length ? t : this._popup, t && t.close(), this;
      }
    }), Ct.include({
      // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
      // Binds a popup to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindPopup: function(t, e) {
        return this._popup = this._initOverlay(qe, this._popup, t, e), this._popupHandlersAdded || (this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !0), this;
      },
      // @method unbindPopup(): this
      // Removes the popup previously bound with `bindPopup`.
      unbindPopup: function() {
        return this._popup && (this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        }), this._popupHandlersAdded = !1, this._popup = null), this;
      },
      // @method openPopup(latlng?: LatLng): this
      // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
      openPopup: function(t) {
        return this._popup && (this instanceof kt || (this._popup._source = this), this._popup._prepareOpen(t || this._latlng) && this._popup.openOn(this._map)), this;
      },
      // @method closePopup(): this
      // Closes the popup bound to this layer if it is open.
      closePopup: function() {
        return this._popup && this._popup.close(), this;
      },
      // @method togglePopup(): this
      // Opens or closes the popup bound to this layer depending on its current state.
      togglePopup: function() {
        return this._popup && this._popup.toggle(this), this;
      },
      // @method isPopupOpen(): boolean
      // Returns `true` if the popup bound to this layer is currently open.
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : !1;
      },
      // @method setPopupContent(content: String|HTMLElement|Popup): this
      // Sets the content of the popup bound to this layer.
      setPopupContent: function(t) {
        return this._popup && this._popup.setContent(t), this;
      },
      // @method getPopup(): Popup
      // Returns the popup bound to this layer.
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(t) {
        if (!(!this._popup || !this._map)) {
          Yt(t);
          var e = t.layer || t.target;
          if (this._popup._source === e && !(e instanceof Ht)) {
            this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng);
            return;
          }
          this._popup._source = e, this.openPopup(t.latlng);
        }
      },
      _movePopup: function(t) {
        this._popup.setLatLng(t.latlng);
      },
      _onKeyPress: function(t) {
        t.originalEvent.keyCode === 13 && this._openPopup(t);
      }
    });
    var Ve = Tt.extend({
      // @section
      // @aka Tooltip options
      options: {
        // @option pane: String = 'tooltipPane'
        // `Map pane` where the tooltip will be added.
        pane: "tooltipPane",
        // @option offset: Point = Point(0, 0)
        // Optional offset of the tooltip position.
        offset: [0, 0],
        // @option direction: String = 'auto'
        // Direction where to open the tooltip. Possible values are: `right`, `left`,
        // `top`, `bottom`, `center`, `auto`.
        // `auto` will dynamically switch between `right` and `left` according to the tooltip
        // position on the map.
        direction: "auto",
        // @option permanent: Boolean = false
        // Whether to open the tooltip permanently or only on mouseover.
        permanent: !1,
        // @option sticky: Boolean = false
        // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
        sticky: !1,
        // @option opacity: Number = 0.9
        // Tooltip container opacity.
        opacity: 0.9
      },
      onAdd: function(t) {
        Tt.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
      },
      onRemove: function(t) {
        Tt.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
      },
      getEvents: function() {
        var t = Tt.prototype.getEvents.call(this);
        return this.options.permanent || (t.preclick = this.close), t;
      },
      _initLayout: function() {
        var t = "leaflet-tooltip", e = t + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = q("div", e), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + g(this));
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(t) {
        var e, i, n = this._map, s = this._container, c = n.latLngToContainerPoint(n.getCenter()), f = n.layerPointToContainerPoint(t), m = this.options.direction, v = s.offsetWidth, b = s.offsetHeight, A = I(this.options.offset), M = this._getAnchor();
        m === "top" ? (e = v / 2, i = b) : m === "bottom" ? (e = v / 2, i = 0) : m === "center" ? (e = v / 2, i = b / 2) : m === "right" ? (e = 0, i = b / 2) : m === "left" ? (e = v, i = b / 2) : f.x < c.x ? (m = "right", e = 0, i = b / 2) : (m = "left", e = v + (A.x + M.x) * 2, i = b / 2), t = t.subtract(I(e, i, !0)).add(A).add(M), nt(s, "leaflet-tooltip-right"), nt(s, "leaflet-tooltip-left"), nt(s, "leaflet-tooltip-top"), nt(s, "leaflet-tooltip-bottom"), D(s, "leaflet-tooltip-" + m), at(s, t);
      },
      _updatePosition: function() {
        var t = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(t);
      },
      setOpacity: function(t) {
        this.options.opacity = t, this._container && _t(this._container, t);
      },
      _animateZoom: function(t) {
        var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
        this._setPosition(e);
      },
      _getAnchor: function() {
        return I(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    }), ms = function(t, e) {
      return new Ve(t, e);
    };
    j.include({
      // @method openTooltip(tooltip: Tooltip): this
      // Opens the specified tooltip.
      // @alternative
      // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
      // Creates a tooltip with the specified content and options and open it.
      openTooltip: function(t, e, i) {
        return this._initOverlay(Ve, t, e, i).openOn(this), this;
      },
      // @method closeTooltip(tooltip: Tooltip): this
      // Closes the tooltip given as parameter.
      closeTooltip: function(t) {
        return t.close(), this;
      }
    }), Ct.include({
      // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
      // Binds a tooltip to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindTooltip: function(t, e) {
        return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ve, this._tooltip, t, e), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
      },
      // @method unbindTooltip(): this
      // Removes the tooltip previously bound with `bindTooltip`.
      unbindTooltip: function() {
        return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
      },
      _initTooltipInteractions: function(t) {
        if (!(!t && this._tooltipHandlersAdded)) {
          var e = t ? "off" : "on", i = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip, i.mouseout = this.closeTooltip, i.click = this._openTooltip, this._map ? this._addFocusListeners() : i.add = this._addFocusListeners), this._tooltip.options.sticky && (i.mousemove = this._moveTooltip), this[e](i), this._tooltipHandlersAdded = !t;
        }
      },
      // @method openTooltip(latlng?: LatLng): this
      // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
      openTooltip: function(t) {
        return this._tooltip && (this instanceof kt || (this._tooltip._source = this), this._tooltip._prepareOpen(t) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
      },
      // @method closeTooltip(): this
      // Closes the tooltip bound to this layer if it is open.
      closeTooltip: function() {
        if (this._tooltip)
          return this._tooltip.close();
      },
      // @method toggleTooltip(): this
      // Opens or closes the tooltip bound to this layer depending on its current state.
      toggleTooltip: function() {
        return this._tooltip && this._tooltip.toggle(this), this;
      },
      // @method isTooltipOpen(): boolean
      // Returns `true` if the tooltip bound to this layer is currently open.
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
      // Sets the content of the tooltip bound to this layer.
      setTooltipContent: function(t) {
        return this._tooltip && this._tooltip.setContent(t), this;
      },
      // @method getTooltip(): Tooltip
      // Returns the tooltip bound to this layer.
      getTooltip: function() {
        return this._tooltip;
      },
      _addFocusListeners: function() {
        this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
      },
      _addFocusListenersOnLayer: function(t) {
        var e = typeof t.getElement == "function" && t.getElement();
        e && (z(e, "focus", function() {
          this._tooltip._source = t, this.openTooltip();
        }, this), z(e, "blur", this.closeTooltip, this));
      },
      _setAriaDescribedByOnLayer: function(t) {
        var e = typeof t.getElement == "function" && t.getElement();
        e && e.setAttribute("aria-describedby", this._tooltip._container.id);
      },
      _openTooltip: function(t) {
        if (!(!this._tooltip || !this._map)) {
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = !0;
            var e = this;
            this._map.once("moveend", function() {
              e._openOnceFlag = !1, e._openTooltip(t);
            });
            return;
          }
          this._tooltip._source = t.layer || t.target, this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0);
        }
      },
      _moveTooltip: function(t) {
        var e = t.latlng, i, n;
        this._tooltip.options.sticky && t.originalEvent && (i = this._map.mouseEventToContainerPoint(t.originalEvent), n = this._map.containerPointToLayerPoint(i), e = this._map.layerPointToLatLng(n)), this._tooltip.setLatLng(e);
      }
    });
    var po = se.extend({
      options: {
        // @section
        // @aka DivIcon options
        iconSize: [12, 12],
        // also can be set through CSS
        // iconAnchor: (Point),
        // popupAnchor: (Point),
        // @option html: String|HTMLElement = ''
        // Custom HTML code to put inside the div element, empty by default. Alternatively,
        // an instance of `HTMLElement`.
        html: !1,
        // @option bgPos: Point = [0, 0]
        // Optional relative position of the background, in pixels
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(t) {
        var e = t && t.tagName === "DIV" ? t : document.createElement("div"), i = this.options;
        if (i.html instanceof Element ? (Re(e), e.appendChild(i.html)) : e.innerHTML = i.html !== !1 ? i.html : "", i.bgPos) {
          var n = I(i.bgPos);
          e.style.backgroundPosition = -n.x + "px " + -n.y + "px";
        }
        return this._setIconStyles(e, "icon"), e;
      },
      createShadow: function() {
        return null;
      }
    });
    function gs(t) {
      return new po(t);
    }
    se.Default = xe;
    var Ce = Ct.extend({
      // @section
      // @aka GridLayer options
      options: {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize: 256,
        // @option opacity: Number = 1.0
        // Opacity of the tiles. Can be used in the `createTile()` function.
        opacity: 1,
        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle: T.mobile,
        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming: !0,
        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval: 200,
        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex: 1,
        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds: null,
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: void 0,
        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom: void 0,
        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom: void 0,
        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap: !1,
        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane: "tilePane",
        // @option className: String = ''
        // A custom class name to assign to the tile layer. Empty by default.
        className: "",
        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer: 2
      },
      initialize: function(t) {
        x(this, t);
      },
      onAdd: function() {
        this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
      },
      beforeAdd: function(t) {
        t._addZoomLimit(this);
      },
      onRemove: function(t) {
        this._removeAllTiles(), et(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
      },
      // @method bringToFront: this
      // Brings the tile layer to the top of all tile layers.
      bringToFront: function() {
        return this._map && (ne(this._container), this._setAutoZIndex(Math.max)), this;
      },
      // @method bringToBack: this
      // Brings the tile layer to the bottom of all tile layers.
      bringToBack: function() {
        return this._map && (oe(this._container), this._setAutoZIndex(Math.min)), this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the tiles for this layer.
      getContainer: function() {
        return this._container;
      },
      // @method setOpacity(opacity: Number): this
      // Changes the [opacity](#gridlayer-opacity) of the grid layer.
      setOpacity: function(t) {
        return this.options.opacity = t, this._updateOpacity(), this;
      },
      // @method setZIndex(zIndex: Number): this
      // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
      setZIndex: function(t) {
        return this.options.zIndex = t, this._updateZIndex(), this;
      },
      // @method isLoading: Boolean
      // Returns `true` if any tile in the grid layer has not finished loading.
      isLoading: function() {
        return this._loading;
      },
      // @method redraw: this
      // Causes the layer to clear all the tiles and request them again.
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          var t = this._clampZoom(this._map.getZoom());
          t !== this._tileZoom && (this._tileZoom = t, this._updateLevels()), this._update();
        }
        return this;
      },
      getEvents: function() {
        var t = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        return this.options.updateWhenIdle || (this._onMove || (this._onMove = _(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
      },
      // @section Extension methods
      // Layers extending `GridLayer` shall reimplement the following method.
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, must be overridden by classes extending `GridLayer`.
      // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
      // is specified, it must be called when the tile has finished loading and drawing.
      createTile: function() {
        return document.createElement("div");
      },
      // @section
      // @method getTileSize: Point
      // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
      getTileSize: function() {
        var t = this.options.tileSize;
        return t instanceof O ? t : new O(t, t);
      },
      _updateZIndex: function() {
        this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
      },
      _setAutoZIndex: function(t) {
        for (var e = this.getPane().children, i = -t(-1 / 0, 1 / 0), n = 0, s = e.length, c; n < s; n++)
          c = e[n].style.zIndex, e[n] !== this._container && c && (i = t(i, +c));
        isFinite(i) && (this.options.zIndex = i + t(-1, 1), this._updateZIndex());
      },
      _updateOpacity: function() {
        if (this._map && !T.ielt9) {
          _t(this._container, this.options.opacity);
          var t = +/* @__PURE__ */ new Date(), e = !1, i = !1;
          for (var n in this._tiles) {
            var s = this._tiles[n];
            if (!(!s.current || !s.loaded)) {
              var c = Math.min(1, (t - s.loaded) / 200);
              _t(s.el, c), c < 1 ? e = !0 : (s.active ? i = !0 : this._onOpaqueTile(s), s.active = !0);
            }
          }
          i && !this._noPrune && this._pruneTiles(), e && (it(this._fadeFrame), this._fadeFrame = Q(this._updateOpacity, this));
        }
      },
      _onOpaqueTile: w,
      _initContainer: function() {
        this._container || (this._container = q("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
      },
      _updateLevels: function() {
        var t = this._tileZoom, e = this.options.maxZoom;
        if (t !== void 0) {
          for (var i in this._levels)
            i = Number(i), this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i), this._onUpdateLevel(i)) : (et(this._levels[i].el), this._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this._levels[i]);
          var n = this._levels[t], s = this._map;
          return n || (n = this._levels[t] = {}, n.el = q("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n.el.style.zIndex = e, n.origin = s.project(s.unproject(s.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, s.getCenter(), s.getZoom()), w(n.el.offsetWidth), this._onCreateLevel(n)), this._level = n, n;
        }
      },
      _onUpdateLevel: w,
      _onRemoveLevel: w,
      _onCreateLevel: w,
      _pruneTiles: function() {
        if (this._map) {
          var t, e, i = this._map.getZoom();
          if (i > this.options.maxZoom || i < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (t in this._tiles)
            e = this._tiles[t], e.retain = e.current;
          for (t in this._tiles)
            if (e = this._tiles[t], e.current && !e.active) {
              var n = e.coords;
              this._retainParent(n.x, n.y, n.z, n.z - 5) || this._retainChildren(n.x, n.y, n.z, n.z + 2);
            }
          for (t in this._tiles)
            this._tiles[t].retain || this._removeTile(t);
        }
      },
      _removeTilesAtZoom: function(t) {
        for (var e in this._tiles)
          this._tiles[e].coords.z === t && this._removeTile(e);
      },
      _removeAllTiles: function() {
        for (var t in this._tiles)
          this._removeTile(t);
      },
      _invalidateAll: function() {
        for (var t in this._levels)
          et(this._levels[t].el), this._onRemoveLevel(Number(t)), delete this._levels[t];
        this._removeAllTiles(), this._tileZoom = void 0;
      },
      _retainParent: function(t, e, i, n) {
        var s = Math.floor(t / 2), c = Math.floor(e / 2), f = i - 1, m = new O(+s, +c);
        m.z = +f;
        var v = this._tileCoordsToKey(m), b = this._tiles[v];
        return b && b.active ? (b.retain = !0, !0) : (b && b.loaded && (b.retain = !0), f > n ? this._retainParent(s, c, f, n) : !1);
      },
      _retainChildren: function(t, e, i, n) {
        for (var s = 2 * t; s < 2 * t + 2; s++)
          for (var c = 2 * e; c < 2 * e + 2; c++) {
            var f = new O(s, c);
            f.z = i + 1;
            var m = this._tileCoordsToKey(f), v = this._tiles[m];
            if (v && v.active) {
              v.retain = !0;
              continue;
            } else
              v && v.loaded && (v.retain = !0);
            i + 1 < n && this._retainChildren(s, c, i + 1, n);
          }
      },
      _resetView: function(t) {
        var e = t && (t.pinch || t.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), e, e);
      },
      _animateZoom: function(t) {
        this._setView(t.center, t.zoom, !0, t.noUpdate);
      },
      _clampZoom: function(t) {
        var e = this.options;
        return e.minNativeZoom !== void 0 && t < e.minNativeZoom ? e.minNativeZoom : e.maxNativeZoom !== void 0 && e.maxNativeZoom < t ? e.maxNativeZoom : t;
      },
      _setView: function(t, e, i, n) {
        var s = Math.round(e);
        this.options.maxZoom !== void 0 && s > this.options.maxZoom || this.options.minZoom !== void 0 && s < this.options.minZoom ? s = void 0 : s = this._clampZoom(s);
        var c = this.options.updateWhenZooming && s !== this._tileZoom;
        (!n || c) && (this._tileZoom = s, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), s !== void 0 && this._update(t), i || this._pruneTiles(), this._noPrune = !!i), this._setZoomTransforms(t, e);
      },
      _setZoomTransforms: function(t, e) {
        for (var i in this._levels)
          this._setZoomTransform(this._levels[i], t, e);
      },
      _setZoomTransform: function(t, e, i) {
        var n = this._map.getZoomScale(i, t.zoom), s = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round();
        T.any3d ? jt(t.el, s, n) : at(t.el, s);
      },
      _resetGrid: function() {
        var t = this._map, e = t.options.crs, i = this._tileSize = this.getTileSize(), n = this._tileZoom, s = this._map.getPixelWorldBounds(this._tileZoom);
        s && (this._globalTileRange = this._pxBoundsToTileRange(s)), this._wrapX = e.wrapLng && !this.options.noWrap && [
          Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x),
          Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)
        ], this._wrapY = e.wrapLat && !this.options.noWrap && [
          Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x),
          Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)
        ];
      },
      _onMoveEnd: function() {
        !this._map || this._map._animatingZoom || this._update();
      },
      _getTiledPixelBounds: function(t) {
        var e = this._map, i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(), n = e.getZoomScale(i, this._tileZoom), s = e.project(t, this._tileZoom).floor(), c = e.getSize().divideBy(n * 2);
        return new tt(s.subtract(c), s.add(c));
      },
      // Private method to load tiles in the grid's active zoom level according to map bounds
      _update: function(t) {
        var e = this._map;
        if (e) {
          var i = this._clampZoom(e.getZoom());
          if (t === void 0 && (t = e.getCenter()), this._tileZoom !== void 0) {
            var n = this._getTiledPixelBounds(t), s = this._pxBoundsToTileRange(n), c = s.getCenter(), f = [], m = this.options.keepBuffer, v = new tt(
              s.getBottomLeft().subtract([m, -m]),
              s.getTopRight().add([m, -m])
            );
            if (!(isFinite(s.min.x) && isFinite(s.min.y) && isFinite(s.max.x) && isFinite(s.max.y)))
              throw new Error("Attempted to load an infinite number of tiles");
            for (var b in this._tiles) {
              var A = this._tiles[b].coords;
              (A.z !== this._tileZoom || !v.contains(new O(A.x, A.y))) && (this._tiles[b].current = !1);
            }
            if (Math.abs(i - this._tileZoom) > 1) {
              this._setView(t, i);
              return;
            }
            for (var M = s.min.y; M <= s.max.y; M++)
              for (var N = s.min.x; N <= s.max.x; N++) {
                var ft = new O(N, M);
                if (ft.z = this._tileZoom, !!this._isValidTile(ft)) {
                  var ct = this._tiles[this._tileCoordsToKey(ft)];
                  ct ? ct.current = !0 : f.push(ft);
                }
              }
            if (f.sort(function(gt, ce) {
              return gt.distanceTo(c) - ce.distanceTo(c);
            }), f.length !== 0) {
              this._loading || (this._loading = !0, this.fire("loading"));
              var wt = document.createDocumentFragment();
              for (N = 0; N < f.length; N++)
                this._addTile(f[N], wt);
              this._level.el.appendChild(wt);
            }
          }
        }
      },
      _isValidTile: function(t) {
        var e = this._map.options.crs;
        if (!e.infinite) {
          var i = this._globalTileRange;
          if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y))
            return !1;
        }
        if (!this.options.bounds)
          return !0;
        var n = this._tileCoordsToBounds(t);
        return st(this.options.bounds).overlaps(n);
      },
      _keyToBounds: function(t) {
        return this._tileCoordsToBounds(this._keyToTileCoords(t));
      },
      _tileCoordsToNwSe: function(t) {
        var e = this._map, i = this.getTileSize(), n = t.scaleBy(i), s = n.add(i), c = e.unproject(n, t.z), f = e.unproject(s, t.z);
        return [c, f];
      },
      // converts tile coordinates to its geographical bounds
      _tileCoordsToBounds: function(t) {
        var e = this._tileCoordsToNwSe(t), i = new mt(e[0], e[1]);
        return this.options.noWrap || (i = this._map.wrapLatLngBounds(i)), i;
      },
      // converts tile coordinates to key for the tile cache
      _tileCoordsToKey: function(t) {
        return t.x + ":" + t.y + ":" + t.z;
      },
      // converts tile cache key to coordinates
      _keyToTileCoords: function(t) {
        var e = t.split(":"), i = new O(+e[0], +e[1]);
        return i.z = +e[2], i;
      },
      _removeTile: function(t) {
        var e = this._tiles[t];
        e && (et(e.el), delete this._tiles[t], this.fire("tileunload", {
          tile: e.el,
          coords: this._keyToTileCoords(t)
        }));
      },
      _initTile: function(t) {
        D(t, "leaflet-tile");
        var e = this.getTileSize();
        t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = w, t.onmousemove = w, T.ielt9 && this.options.opacity < 1 && _t(t, this.options.opacity);
      },
      _addTile: function(t, e) {
        var i = this._getTilePos(t), n = this._tileCoordsToKey(t), s = this.createTile(this._wrapCoords(t), u(this._tileReady, this, t));
        this._initTile(s), this.createTile.length < 2 && Q(u(this._tileReady, this, t, null, s)), at(s, i), this._tiles[n] = {
          el: s,
          coords: t,
          current: !0
        }, e.appendChild(s), this.fire("tileloadstart", {
          tile: s,
          coords: t
        });
      },
      _tileReady: function(t, e, i) {
        e && this.fire("tileerror", {
          error: e,
          tile: i,
          coords: t
        });
        var n = this._tileCoordsToKey(t);
        i = this._tiles[n], i && (i.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (_t(i.el, 0), it(this._fadeFrame), this._fadeFrame = Q(this._updateOpacity, this)) : (i.active = !0, this._pruneTiles()), e || (D(i.el, "leaflet-tile-loaded"), this.fire("tileload", {
          tile: i.el,
          coords: t
        })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), T.ielt9 || !this._map._fadeAnimated ? Q(this._pruneTiles, this) : setTimeout(u(this._pruneTiles, this), 250)));
      },
      _getTilePos: function(t) {
        return t.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(t) {
        var e = new O(
          this._wrapX ? y(t.x, this._wrapX) : t.x,
          this._wrapY ? y(t.y, this._wrapY) : t.y
        );
        return e.z = t.z, e;
      },
      _pxBoundsToTileRange: function(t) {
        var e = this.getTileSize();
        return new tt(
          t.min.unscaleBy(e).floor(),
          t.max.unscaleBy(e).ceil().subtract([1, 1])
        );
      },
      _noTilesToLoad: function() {
        for (var t in this._tiles)
          if (!this._tiles[t].loaded)
            return !1;
        return !0;
      }
    });
    function vs(t) {
      return new Ce(t);
    }
    var le = Ce.extend({
      // @section
      // @aka TileLayer options
      options: {
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = 18
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: 18,
        // @option subdomains: String|String[] = 'abc'
        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
        subdomains: "abc",
        // @option errorTileUrl: String = ''
        // URL to the tile image to show in place of the tile that failed to load.
        errorTileUrl: "",
        // @option zoomOffset: Number = 0
        // The zoom number used in tile URLs will be offset with this value.
        zoomOffset: 0,
        // @option tms: Boolean = false
        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
        tms: !1,
        // @option zoomReverse: Boolean = false
        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
        zoomReverse: !1,
        // @option detectRetina: Boolean = false
        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
        detectRetina: !1,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: !1,
        // @option referrerPolicy: Boolean|String = false
        // Whether the referrerPolicy attribute will be added to the tiles.
        // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
        // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
        // (e.g. to validate an API token).
        // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
        referrerPolicy: !1
      },
      initialize: function(t, e) {
        this._url = t, e = x(this, e), e.detectRetina && T.retina && e.maxZoom > 0 ? (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom = Math.min(e.maxZoom, e.minZoom + 1)) : (e.zoomOffset++, e.maxZoom = Math.max(e.minZoom, e.maxZoom - 1)), e.minZoom = Math.max(0, e.minZoom)) : e.zoomReverse ? e.minZoom = Math.min(e.maxZoom, e.minZoom) : e.maxZoom = Math.max(e.minZoom, e.maxZoom), typeof e.subdomains == "string" && (e.subdomains = e.subdomains.split("")), this.on("tileunload", this._onTileRemove);
      },
      // @method setUrl(url: String, noRedraw?: Boolean): this
      // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
      // If the URL does not change, the layer will not be redrawn unless
      // the noRedraw parameter is set to false.
      setUrl: function(t, e) {
        return this._url === t && e === void 0 && (e = !0), this._url = t, e || this.redraw(), this;
      },
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
      // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
      // callback is called when the tile has been loaded.
      createTile: function(t, e) {
        var i = document.createElement("img");
        return z(i, "load", u(this._tileOnLoad, this, e, i)), z(i, "error", u(this._tileOnError, this, e, i)), (this.options.crossOrigin || this.options.crossOrigin === "") && (i.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (i.referrerPolicy = this.options.referrerPolicy), i.alt = "", i.src = this.getTileUrl(t), i;
      },
      // @section Extension methods
      // @uninheritable
      // Layers extending `TileLayer` might reimplement the following method.
      // @method getTileUrl(coords: Object): String
      // Called only internally, returns the URL for a tile given its coordinates.
      // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
      getTileUrl: function(t) {
        var e = {
          r: T.retina ? "@2x" : "",
          s: this._getSubdomain(t),
          x: t.x,
          y: t.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var i = this._globalTileRange.max.y - t.y;
          this.options.tms && (e.y = i), e["-y"] = i;
        }
        return S(this._url, l(e, this.options));
      },
      _tileOnLoad: function(t, e) {
        T.ielt9 ? setTimeout(u(t, this, null, e), 0) : t(null, e);
      },
      _tileOnError: function(t, e, i) {
        var n = this.options.errorTileUrl;
        n && e.getAttribute("src") !== n && (e.src = n), t(i, e);
      },
      _onTileRemove: function(t) {
        t.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var t = this._tileZoom, e = this.options.maxZoom, i = this.options.zoomReverse, n = this.options.zoomOffset;
        return i && (t = e - t), t + n;
      },
      _getSubdomain: function(t) {
        var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
        return this.options.subdomains[e];
      },
      // stops loading all tiles in the background layer
      _abortLoading: function() {
        var t, e;
        for (t in this._tiles)
          if (this._tiles[t].coords.z !== this._tileZoom && (e = this._tiles[t].el, e.onload = w, e.onerror = w, !e.complete)) {
            e.src = F;
            var i = this._tiles[t].coords;
            et(e), delete this._tiles[t], this.fire("tileabort", {
              tile: e,
              coords: i
            });
          }
      },
      _removeTile: function(t) {
        var e = this._tiles[t];
        if (e)
          return e.el.setAttribute("src", F), Ce.prototype._removeTile.call(this, t);
      },
      _tileReady: function(t, e, i) {
        if (!(!this._map || i && i.getAttribute("src") === F))
          return Ce.prototype._tileReady.call(this, t, e, i);
      }
    });
    function mo(t, e) {
      return new le(t, e);
    }
    var go = le.extend({
      // @section
      // @aka TileLayer.WMS options
      // If any custom options not documented here are used, they will be sent to the
      // WMS server as extra parameters in each request URL. This can be useful for
      // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        // @option layers: String = ''
        // **(required)** Comma-separated list of WMS layers to show.
        layers: "",
        // @option styles: String = ''
        // Comma-separated list of WMS styles.
        styles: "",
        // @option format: String = 'image/jpeg'
        // WMS image format (use `'image/png'` for layers with transparency).
        format: "image/jpeg",
        // @option transparent: Boolean = false
        // If `true`, the WMS service will return images with transparency.
        transparent: !1,
        // @option version: String = '1.1.1'
        // Version of the WMS service to use
        version: "1.1.1"
      },
      options: {
        // @option crs: CRS = null
        // Coordinate Reference System to use for the WMS requests, defaults to
        // map CRS. Don't change this if you're not sure what it means.
        crs: null,
        // @option uppercase: Boolean = false
        // If `true`, WMS request parameter keys will be uppercase.
        uppercase: !1
      },
      initialize: function(t, e) {
        this._url = t;
        var i = l({}, this.defaultWmsParams);
        for (var n in e)
          n in this.options || (i[n] = e[n]);
        e = x(this, e);
        var s = e.detectRetina && T.retina ? 2 : 1, c = this.getTileSize();
        i.width = c.x * s, i.height = c.y * s, this.wmsParams = i;
      },
      onAdd: function(t) {
        this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
        var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[e] = this._crs.code, le.prototype.onAdd.call(this, t);
      },
      getTileUrl: function(t) {
        var e = this._tileCoordsToNwSe(t), i = this._crs, n = pt(i.project(e[0]), i.project(e[1])), s = n.min, c = n.max, f = (this._wmsVersion >= 1.3 && this._crs === ao ? [s.y, s.x, c.y, c.x] : [s.x, s.y, c.x, c.y]).join(","), m = le.prototype.getTileUrl.call(this, t);
        return m + R(this.wmsParams, m, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + f;
      },
      // @method setParams(params: Object, noRedraw?: Boolean): this
      // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
      setParams: function(t, e) {
        return l(this.wmsParams, t), e || this.redraw(), this;
      }
    });
    function ys(t, e) {
      return new go(t, e);
    }
    le.WMS = go, mo.wms = ys;
    var Ot = Ct.extend({
      // @section
      // @aka Renderer options
      options: {
        // @option padding: Number = 0.1
        // How much to extend the clip area around the map view (relative to its size)
        // e.g. 0.1 would be 10% of map view in each direction
        padding: 0.1
      },
      initialize: function(t) {
        x(this, t), g(this), this._layers = this._layers || {};
      },
      onAdd: function() {
        this._container || (this._initContainer(), D(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this), this._destroyContainer();
      },
      getEvents: function() {
        var t = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t;
      },
      _onAnimZoom: function(t) {
        this._updateTransform(t.center, t.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(t, e) {
        var i = this._map.getZoomScale(e, this._zoom), n = this._map.getSize().multiplyBy(0.5 + this.options.padding), s = this._map.project(this._center, e), c = n.multiplyBy(-i).add(s).subtract(this._map._getNewPixelOrigin(t, e));
        T.any3d ? jt(this._container, c, i) : at(this._container, c);
      },
      _reset: function() {
        this._update(), this._updateTransform(this._center, this._zoom);
        for (var t in this._layers)
          this._layers[t]._reset();
      },
      _onZoomEnd: function() {
        for (var t in this._layers)
          this._layers[t]._project();
      },
      _updatePaths: function() {
        for (var t in this._layers)
          this._layers[t]._update();
      },
      _update: function() {
        var t = this.options.padding, e = this._map.getSize(), i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();
        this._bounds = new tt(i, i.add(e.multiplyBy(1 + t * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
      }
    }), vo = Ot.extend({
      // @section
      // @aka Canvas options
      options: {
        // @option tolerance: Number = 0
        // How much to extend the click tolerance around a path/object on the map.
        tolerance: 0
      },
      getEvents: function() {
        var t = Ot.prototype.getEvents.call(this);
        return t.viewprereset = this._onViewPreReset, t;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = !0;
      },
      onAdd: function() {
        Ot.prototype.onAdd.call(this), this._draw();
      },
      _initContainer: function() {
        var t = this._container = document.createElement("canvas");
        z(t, "mousemove", this._onMouseMove, this), z(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), z(t, "mouseout", this._handleMouseOut, this), t._leaflet_disable_events = !0, this._ctx = t.getContext("2d");
      },
      _destroyContainer: function() {
        it(this._redrawRequest), delete this._ctx, et(this._container), X(this._container), delete this._container;
      },
      _updatePaths: function() {
        if (!this._postponeUpdatePaths) {
          var t;
          this._redrawBounds = null;
          for (var e in this._layers)
            t = this._layers[e], t._update();
          this._redraw();
        }
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          Ot.prototype._update.call(this);
          var t = this._bounds, e = this._container, i = t.getSize(), n = T.retina ? 2 : 1;
          at(e, t.min), e.width = n * i.x, e.height = n * i.y, e.style.width = i.x + "px", e.style.height = i.y + "px", T.retina && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update");
        }
      },
      _reset: function() {
        Ot.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
      },
      _initPath: function(t) {
        this._updateDashArray(t), this._layers[g(t)] = t;
        var e = t._order = {
          layer: t,
          prev: this._drawLast,
          next: null
        };
        this._drawLast && (this._drawLast.next = e), this._drawLast = e, this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(t) {
        this._requestRedraw(t);
      },
      _removePath: function(t) {
        var e = t._order, i = e.next, n = e.prev;
        i ? i.prev = n : this._drawLast = n, n ? n.next = i : this._drawFirst = i, delete t._order, delete this._layers[g(t)], this._requestRedraw(t);
      },
      _updatePath: function(t) {
        this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t);
      },
      _updateStyle: function(t) {
        this._updateDashArray(t), this._requestRedraw(t);
      },
      _updateDashArray: function(t) {
        if (typeof t.options.dashArray == "string") {
          var e = t.options.dashArray.split(/[, ]+/), i = [], n, s;
          for (s = 0; s < e.length; s++) {
            if (n = Number(e[s]), isNaN(n))
              return;
            i.push(n);
          }
          t.options._dashArray = i;
        } else
          t.options._dashArray = t.options.dashArray;
      },
      _requestRedraw: function(t) {
        this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || Q(this._redraw, this));
      },
      _extendRedrawBounds: function(t) {
        if (t._pxBounds) {
          var e = (t.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new tt(), this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
      },
      _clear: function() {
        var t = this._redrawBounds;
        if (t) {
          var e = t.getSize();
          this._ctx.clearRect(t.min.x, t.min.y, e.x, e.y);
        } else
          this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
      },
      _draw: function() {
        var t, e = this._redrawBounds;
        if (this._ctx.save(), e) {
          var i = e.getSize();
          this._ctx.beginPath(), this._ctx.rect(e.min.x, e.min.y, i.x, i.y), this._ctx.clip();
        }
        this._drawing = !0;
        for (var n = this._drawFirst; n; n = n.next)
          t = n.layer, (!e || t._pxBounds && t._pxBounds.intersects(e)) && t._updatePath();
        this._drawing = !1, this._ctx.restore();
      },
      _updatePoly: function(t, e) {
        if (this._drawing) {
          var i, n, s, c, f = t._parts, m = f.length, v = this._ctx;
          if (m) {
            for (v.beginPath(), i = 0; i < m; i++) {
              for (n = 0, s = f[i].length; n < s; n++)
                c = f[i][n], v[n ? "lineTo" : "moveTo"](c.x, c.y);
              e && v.closePath();
            }
            this._fillStroke(v, t);
          }
        }
      },
      _updateCircle: function(t) {
        if (!(!this._drawing || t._empty())) {
          var e = t._point, i = this._ctx, n = Math.max(Math.round(t._radius), 1), s = (Math.max(Math.round(t._radiusY), 1) || n) / n;
          s !== 1 && (i.save(), i.scale(1, s)), i.beginPath(), i.arc(e.x, e.y / s, n, 0, Math.PI * 2, !1), s !== 1 && i.restore(), this._fillStroke(i, t);
        }
      },
      _fillStroke: function(t, e) {
        var i = e.options;
        i.fill && (t.globalAlpha = i.fillOpacity, t.fillStyle = i.fillColor || i.color, t.fill(i.fillRule || "evenodd")), i.stroke && i.weight !== 0 && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = i.opacity, t.lineWidth = i.weight, t.strokeStyle = i.color, t.lineCap = i.lineCap, t.lineJoin = i.lineJoin, t.stroke());
      },
      // Canvas obviously doesn't have mouse events for individual drawn objects,
      // so we emulate that by calculating what's under the mouse on mousemove/click manually
      _onClick: function(t) {
        for (var e = this._map.mouseEventToLayerPoint(t), i, n, s = this._drawFirst; s; s = s.next)
          i = s.layer, i.options.interactive && i._containsPoint(e) && (!(t.type === "click" || t.type === "preclick") || !this._map._draggableMoved(i)) && (n = i);
        this._fireEvent(n ? [n] : !1, t);
      },
      _onMouseMove: function(t) {
        if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
          var e = this._map.mouseEventToLayerPoint(t);
          this._handleMouseHover(t, e);
        }
      },
      _handleMouseOut: function(t) {
        var e = this._hoveredLayer;
        e && (nt(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
      },
      _handleMouseHover: function(t, e) {
        if (!this._mouseHoverThrottled) {
          for (var i, n, s = this._drawFirst; s; s = s.next)
            i = s.layer, i.options.interactive && i._containsPoint(e) && (n = i);
          n !== this._hoveredLayer && (this._handleMouseOut(t), n && (D(this._container, "leaflet-interactive"), this._fireEvent([n], t, "mouseover"), this._hoveredLayer = n)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, t), this._mouseHoverThrottled = !0, setTimeout(u(function() {
            this._mouseHoverThrottled = !1;
          }, this), 32);
        }
      },
      _fireEvent: function(t, e, i) {
        this._map._fireDOMEvent(e, i || e.type, t);
      },
      _bringToFront: function(t) {
        var e = t._order;
        if (e) {
          var i = e.next, n = e.prev;
          if (i)
            i.prev = n;
          else
            return;
          n ? n.next = i : i && (this._drawFirst = i), e.prev = this._drawLast, this._drawLast.next = e, e.next = null, this._drawLast = e, this._requestRedraw(t);
        }
      },
      _bringToBack: function(t) {
        var e = t._order;
        if (e) {
          var i = e.next, n = e.prev;
          if (n)
            n.next = i;
          else
            return;
          i ? i.prev = n : n && (this._drawLast = n), e.prev = null, e.next = this._drawFirst, this._drawFirst.prev = e, this._drawFirst = e, this._requestRedraw(t);
        }
      }
    });
    function yo(t) {
      return T.canvas ? new vo(t) : null;
    }
    var Ae = function() {
      try {
        return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(t) {
          return document.createElement("<lvml:" + t + ' class="lvml">');
        };
      } catch {
      }
      return function(t) {
        return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }(), _s = {
      _initContainer: function() {
        this._container = q("div", "leaflet-vml-container");
      },
      _update: function() {
        this._map._animatingZoom || (Ot.prototype._update.call(this), this.fire("update"));
      },
      _initPath: function(t) {
        var e = t._container = Ae("shape");
        D(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = Ae("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[g(t)] = t;
      },
      _addPath: function(t) {
        var e = t._container;
        this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e);
      },
      _removePath: function(t) {
        var e = t._container;
        et(e), t.removeInteractiveTarget(e), delete this._layers[g(t)];
      },
      _updateStyle: function(t) {
        var e = t._stroke, i = t._fill, n = t.options, s = t._container;
        s.stroked = !!n.stroke, s.filled = !!n.fill, n.stroke ? (e || (e = t._stroke = Ae("stroke")), s.appendChild(e), e.weight = n.weight + "px", e.color = n.color, e.opacity = n.opacity, n.dashArray ? e.dashStyle = B(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = n.lineCap.replace("butt", "flat"), e.joinstyle = n.lineJoin) : e && (s.removeChild(e), t._stroke = null), n.fill ? (i || (i = t._fill = Ae("fill")), s.appendChild(i), i.color = n.fillColor || n.color, i.opacity = n.fillOpacity) : i && (s.removeChild(i), t._fill = null);
      },
      _updateCircle: function(t) {
        var e = t._point.round(), i = Math.round(t._radius), n = Math.round(t._radiusY || i);
        this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + i + "," + n + " 0," + 65535 * 360);
      },
      _setPath: function(t, e) {
        t._path.v = e;
      },
      _bringToFront: function(t) {
        ne(t._container);
      },
      _bringToBack: function(t) {
        oe(t._container);
      }
    }, Ye = T.vml ? Ae : wn, Ee = Ot.extend({
      _initContainer: function() {
        this._container = Ye("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = Ye("g"), this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        et(this._container), X(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
      },
      _update: function() {
        if (!(this._map._animatingZoom && this._bounds)) {
          Ot.prototype._update.call(this);
          var t = this._bounds, e = t.getSize(), i = this._container;
          (!this._svgSize || !this._svgSize.equals(e)) && (this._svgSize = e, i.setAttribute("width", e.x), i.setAttribute("height", e.y)), at(i, t.min), i.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update");
        }
      },
      // methods below are called by vector layers implementations
      _initPath: function(t) {
        var e = t._path = Ye("path");
        t.options.className && D(e, t.options.className), t.options.interactive && D(e, "leaflet-interactive"), this._updateStyle(t), this._layers[g(t)] = t;
      },
      _addPath: function(t) {
        this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path);
      },
      _removePath: function(t) {
        et(t._path), t.removeInteractiveTarget(t._path), delete this._layers[g(t)];
      },
      _updatePath: function(t) {
        t._project(), t._update();
      },
      _updateStyle: function(t) {
        var e = t._path, i = t.options;
        e && (i.stroke ? (e.setAttribute("stroke", i.color), e.setAttribute("stroke-opacity", i.opacity), e.setAttribute("stroke-width", i.weight), e.setAttribute("stroke-linecap", i.lineCap), e.setAttribute("stroke-linejoin", i.lineJoin), i.dashArray ? e.setAttribute("stroke-dasharray", i.dashArray) : e.removeAttribute("stroke-dasharray"), i.dashOffset ? e.setAttribute("stroke-dashoffset", i.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), i.fill ? (e.setAttribute("fill", i.fillColor || i.color), e.setAttribute("fill-opacity", i.fillOpacity), e.setAttribute("fill-rule", i.fillRule || "evenodd")) : e.setAttribute("fill", "none"));
      },
      _updatePoly: function(t, e) {
        this._setPath(t, xn(t._parts, e));
      },
      _updateCircle: function(t) {
        var e = t._point, i = Math.max(Math.round(t._radius), 1), n = Math.max(Math.round(t._radiusY), 1) || i, s = "a" + i + "," + n + " 0 1,0 ", c = t._empty() ? "M0 0" : "M" + (e.x - i) + "," + e.y + s + i * 2 + ",0 " + s + -i * 2 + ",0 ";
        this._setPath(t, c);
      },
      _setPath: function(t, e) {
        t._path.setAttribute("d", e);
      },
      // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
      _bringToFront: function(t) {
        ne(t._path);
      },
      _bringToBack: function(t) {
        oe(t._path);
      }
    });
    T.vml && Ee.include(_s);
    function _o(t) {
      return T.svg || T.vml ? new Ee(t) : null;
    }
    j.include({
      // @namespace Map; @method getRenderer(layer: Path): Renderer
      // Returns the instance of `Renderer` that should be used to render the given
      // `Path`. It will ensure that the `renderer` options of the map and paths
      // are respected, and that the renderers do exist on the map.
      getRenderer: function(t) {
        var e = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;
        return e || (e = this._renderer = this._createRenderer()), this.hasLayer(e) || this.addLayer(e), e;
      },
      _getPaneRenderer: function(t) {
        if (t === "overlayPane" || t === void 0)
          return !1;
        var e = this._paneRenderers[t];
        return e === void 0 && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e;
      },
      _createRenderer: function(t) {
        return this.options.preferCanvas && yo(t) || _o(t);
      }
    });
    var bo = ae.extend({
      initialize: function(t, e) {
        ae.prototype.initialize.call(this, this._boundsToLatLngs(t), e);
      },
      // @method setBounds(latLngBounds: LatLngBounds): this
      // Redraws the rectangle with the passed bounds.
      setBounds: function(t) {
        return this.setLatLngs(this._boundsToLatLngs(t));
      },
      _boundsToLatLngs: function(t) {
        return t = st(t), [
          t.getSouthWest(),
          t.getNorthWest(),
          t.getNorthEast(),
          t.getSouthEast()
        ];
      }
    });
    function bs(t, e) {
      return new bo(t, e);
    }
    Ee.create = Ye, Ee.pointsToPath = xn, It.geometryToLayer = He, It.coordsToLatLng = Hi, It.coordsToLatLngs = Ze, It.latLngToCoords = Zi, It.latLngsToCoords = Fe, It.getFeature = he, It.asFeature = Ue, j.mergeOptions({
      // @option boxZoom: Boolean = true
      // Whether the map can be zoomed to a rectangular area specified by
      // dragging the mouse while pressing the shift key.
      boxZoom: !0
    });
    var wo = Lt.extend({
      initialize: function(t) {
        this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this);
      },
      addHooks: function() {
        z(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        X(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        et(this._pane), delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0, this._moved = !1;
      },
      _clearDeferredResetState: function() {
        this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
      },
      _onMouseDown: function(t) {
        if (!t.shiftKey || t.which !== 1 && t.button !== 1)
          return !1;
        this._clearDeferredResetState(), this._resetState(), ge(), xi(), this._startPoint = this._map.mouseEventToContainerPoint(t), z(document, {
          contextmenu: Yt,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(t) {
        this._moved || (this._moved = !0, this._box = q("div", "leaflet-zoom-box", this._container), D(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t);
        var e = new tt(this._point, this._startPoint), i = e.getSize();
        at(this._box, e.min), this._box.style.width = i.x + "px", this._box.style.height = i.y + "px";
      },
      _finish: function() {
        this._moved && (et(this._box), nt(this._container, "leaflet-crosshair")), ve(), Ci(), X(document, {
          contextmenu: Yt,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(t) {
        if (!(t.which !== 1 && t.button !== 1) && (this._finish(), !!this._moved)) {
          this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(u(this._resetState, this), 0);
          var e = new mt(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(e).fire("boxzoomend", { boxZoomBounds: e });
        }
      },
      _onKeyDown: function(t) {
        t.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
      }
    });
    j.addInitHook("addHandler", "boxZoom", wo), j.mergeOptions({
      // @option doubleClickZoom: Boolean|String = true
      // Whether the map can be zoomed in by double clicking on it and
      // zoomed out by double clicking while holding shift. If passed
      // `'center'`, double-click zoom will zoom to the center of the
      //  view regardless of where the mouse was.
      doubleClickZoom: !0
    });
    var xo = Lt.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(t) {
        var e = this._map, i = e.getZoom(), n = e.options.zoomDelta, s = t.originalEvent.shiftKey ? i - n : i + n;
        e.options.doubleClickZoom === "center" ? e.setZoom(s) : e.setZoomAround(t.containerPoint, s);
      }
    });
    j.addInitHook("addHandler", "doubleClickZoom", xo), j.mergeOptions({
      // @option dragging: Boolean = true
      // Whether the map is draggable with mouse/touch or not.
      dragging: !0,
      // @section Panning Inertia Options
      // @option inertia: Boolean = *
      // If enabled, panning of the map will have an inertia effect where
      // the map builds momentum while dragging and continues moving in
      // the same direction for some time. Feels especially nice on touch
      // devices. Enabled by default.
      inertia: !0,
      // @option inertiaDeceleration: Number = 3000
      // The rate with which the inertial movement slows down, in pixels/second.
      inertiaDeceleration: 3400,
      // px/s^2
      // @option inertiaMaxSpeed: Number = Infinity
      // Max speed of the inertial movement, in pixels/second.
      inertiaMaxSpeed: 1 / 0,
      // px/s
      // @option easeLinearity: Number = 0.2
      easeLinearity: 0.2,
      // TODO refactor, move to CRS
      // @option worldCopyJump: Boolean = false
      // With this option enabled, the map tracks when you pan to another "copy"
      // of the world and seamlessly jumps to the original one so that all overlays
      // like markers and vector layers are still visible.
      worldCopyJump: !1,
      // @option maxBoundsViscosity: Number = 0.0
      // If `maxBounds` is set, this option will control how solid the bounds
      // are when dragging the map around. The default value of `0.0` allows the
      // user to drag outside the bounds at normal speed, higher values will
      // slow down map dragging outside bounds, and `1.0` makes the bounds fully
      // solid, preventing the user from dragging outside the bounds.
      maxBoundsViscosity: 0
    });
    var Co = Lt.extend({
      addHooks: function() {
        if (!this._draggable) {
          var t = this._map;
          this._draggable = new Nt(t._mapPane, t._container), this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this));
        }
        D(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
      },
      removeHooks: function() {
        nt(this._map._container, "leaflet-grab"), nt(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var t = this._map;
        if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var e = st(this._map.options.maxBounds);
          this._offsetLimit = pt(
            this._map.latLngToContainerPoint(e.getNorthWest()).multiplyBy(-1),
            this._map.latLngToContainerPoint(e.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
          ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else
          this._offsetLimit = null;
        t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = []);
      },
      _onDrag: function(t) {
        if (this._map.options.inertia) {
          var e = this._lastTime = +/* @__PURE__ */ new Date(), i = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(i), this._times.push(e), this._prunePositions(e);
        }
        this._map.fire("move", t).fire("drag", t);
      },
      _prunePositions: function(t) {
        for (; this._positions.length > 1 && t - this._times[0] > 50; )
          this._positions.shift(), this._times.shift();
      },
      _onZoomEnd: function() {
        var t = this._map.getSize().divideBy(2), e = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(t, e) {
        return t - (t - e) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!(!this._viscosity || !this._offsetLimit)) {
          var t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit;
          t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t);
        }
      },
      _onPreDragWrap: function() {
        var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, s = (n - e + i) % t + e - i, c = (n + e + i) % t - e - i, f = Math.abs(s + i) < Math.abs(c + i) ? s : c;
        this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = f;
      },
      _onDragEnd: function(t) {
        var e = this._map, i = e.options, n = !i.inertia || t.noInertia || this._times.length < 2;
        if (e.fire("dragend", t), n)
          e.fire("moveend");
        else {
          this._prunePositions(+/* @__PURE__ */ new Date());
          var s = this._lastPos.subtract(this._positions[0]), c = (this._lastTime - this._times[0]) / 1e3, f = i.easeLinearity, m = s.multiplyBy(f / c), v = m.distanceTo([0, 0]), b = Math.min(i.inertiaMaxSpeed, v), A = m.multiplyBy(b / v), M = b / (i.inertiaDeceleration * f), N = A.multiplyBy(-M / 2).round();
          !N.x && !N.y ? e.fire("moveend") : (N = e._limitOffset(N, e.options.maxBounds), Q(function() {
            e.panBy(N, {
              duration: M,
              easeLinearity: f,
              noMoveStart: !0,
              animate: !0
            });
          }));
        }
      }
    });
    j.addInitHook("addHandler", "dragging", Co), j.mergeOptions({
      // @option keyboard: Boolean = true
      // Makes the map focusable and allows users to navigate the map with keyboard
      // arrows and `+`/`-` keys.
      keyboard: !0,
      // @option keyboardPanDelta: Number = 80
      // Amount of pixels to pan when pressing an arrow key.
      keyboardPanDelta: 80
    });
    var Ao = Lt.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(t) {
        this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta);
      },
      addHooks: function() {
        var t = this._map._container;
        t.tabIndex <= 0 && (t.tabIndex = "0"), z(t, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks(), X(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this), this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (!this._focused) {
          var t = document.body, e = document.documentElement, i = t.scrollTop || e.scrollTop, n = t.scrollLeft || e.scrollLeft;
          this._map._container.focus(), window.scrollTo(n, i);
        }
      },
      _onFocus: function() {
        this._focused = !0, this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = !1, this._map.fire("blur");
      },
      _setPanDelta: function(t) {
        var e = this._panKeys = {}, i = this.keyCodes, n, s;
        for (n = 0, s = i.left.length; n < s; n++)
          e[i.left[n]] = [-1 * t, 0];
        for (n = 0, s = i.right.length; n < s; n++)
          e[i.right[n]] = [t, 0];
        for (n = 0, s = i.down.length; n < s; n++)
          e[i.down[n]] = [0, t];
        for (n = 0, s = i.up.length; n < s; n++)
          e[i.up[n]] = [0, -1 * t];
      },
      _setZoomDelta: function(t) {
        var e = this._zoomKeys = {}, i = this.keyCodes, n, s;
        for (n = 0, s = i.zoomIn.length; n < s; n++)
          e[i.zoomIn[n]] = t;
        for (n = 0, s = i.zoomOut.length; n < s; n++)
          e[i.zoomOut[n]] = -t;
      },
      _addHooks: function() {
        z(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        X(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(t) {
        if (!(t.altKey || t.ctrlKey || t.metaKey)) {
          var e = t.keyCode, i = this._map, n;
          if (e in this._panKeys) {
            if (!i._panAnim || !i._panAnim._inProgress)
              if (n = this._panKeys[e], t.shiftKey && (n = I(n).multiplyBy(3)), i.options.maxBounds && (n = i._limitOffset(I(n), i.options.maxBounds)), i.options.worldCopyJump) {
                var s = i.wrapLatLng(i.unproject(i.project(i.getCenter()).add(n)));
                i.panTo(s);
              } else
                i.panBy(n);
          } else if (e in this._zoomKeys)
            i.setZoom(i.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[e]);
          else if (e === 27 && i._popup && i._popup.options.closeOnEscapeKey)
            i.closePopup();
          else
            return;
          Yt(t);
        }
      }
    });
    j.addInitHook("addHandler", "keyboard", Ao), j.mergeOptions({
      // @section Mouse wheel options
      // @option scrollWheelZoom: Boolean|String = true
      // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
      // it will zoom to the center of the view regardless of where the mouse was.
      scrollWheelZoom: !0,
      // @option wheelDebounceTime: Number = 40
      // Limits the rate at which a wheel can fire (in milliseconds). By default
      // user can't zoom via wheel more often than once per 40 ms.
      wheelDebounceTime: 40,
      // @option wheelPxPerZoomLevel: Number = 60
      // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
      // mean a change of one full zoom level. Smaller values will make wheel-zooming
      // faster (and vice versa).
      wheelPxPerZoomLevel: 60
    });
    var Eo = Lt.extend({
      addHooks: function() {
        z(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
      },
      removeHooks: function() {
        X(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(t) {
        var e = Gn(t), i = this._map.options.wheelDebounceTime;
        this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
        var n = Math.max(i - (+/* @__PURE__ */ new Date() - this._startTime), 0);
        clearTimeout(this._timer), this._timer = setTimeout(u(this._performZoom, this), n), Yt(t);
      },
      _performZoom: function() {
        var t = this._map, e = t.getZoom(), i = this._map.options.zoomSnap || 0;
        t._stop();
        var n = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), s = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2, c = i ? Math.ceil(s / i) * i : s, f = t._limitZoom(e + (this._delta > 0 ? c : -c)) - e;
        this._delta = 0, this._startTime = null, f && (t.options.scrollWheelZoom === "center" ? t.setZoom(e + f) : t.setZoomAround(this._lastMousePos, e + f));
      }
    });
    j.addInitHook("addHandler", "scrollWheelZoom", Eo);
    var ws = 600;
    j.mergeOptions({
      // @section Touch interaction options
      // @option tapHold: Boolean
      // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
      tapHold: T.touchNative && T.safari && T.mobile,
      // @option tapTolerance: Number = 15
      // The max number of pixels a user can shift his finger during touch
      // for it to be considered a valid tap.
      tapTolerance: 15
    });
    var Po = Lt.extend({
      addHooks: function() {
        z(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        X(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(t) {
        if (clearTimeout(this._holdTimeout), t.touches.length === 1) {
          var e = t.touches[0];
          this._startPos = this._newPos = new O(e.clientX, e.clientY), this._holdTimeout = setTimeout(u(function() {
            this._cancel(), this._isTapValid() && (z(document, "touchend", ut), z(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", e));
          }, this), ws), z(document, "touchend touchcancel contextmenu", this._cancel, this), z(document, "touchmove", this._onMove, this);
        }
      },
      _cancelClickPrevent: function t() {
        X(document, "touchend", ut), X(document, "touchend touchcancel", t);
      },
      _cancel: function() {
        clearTimeout(this._holdTimeout), X(document, "touchend touchcancel contextmenu", this._cancel, this), X(document, "touchmove", this._onMove, this);
      },
      _onMove: function(t) {
        var e = t.touches[0];
        this._newPos = new O(e.clientX, e.clientY);
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _simulateEvent: function(t, e) {
        var i = new MouseEvent(t, {
          bubbles: !0,
          cancelable: !0,
          view: window,
          // detail: 1,
          screenX: e.screenX,
          screenY: e.screenY,
          clientX: e.clientX,
          clientY: e.clientY
          // button: 2,
          // buttons: 2
        });
        i._simulated = !0, e.target.dispatchEvent(i);
      }
    });
    j.addInitHook("addHandler", "tapHold", Po), j.mergeOptions({
      // @section Touch interaction options
      // @option touchZoom: Boolean|String = *
      // Whether the map can be zoomed by touch-dragging with two fingers. If
      // passed `'center'`, it will zoom to the center of the view regardless of
      // where the touch events (fingers) were. Enabled for touch-capable web
      // browsers.
      touchZoom: T.touch,
      // @option bounceAtZoomLimits: Boolean = true
      // Set it to false if you don't want the map to zoom beyond min/max zoom
      // and then bounce back when pinch-zooming.
      bounceAtZoomLimits: !0
    });
    var Lo = Lt.extend({
      addHooks: function() {
        D(this._map._container, "leaflet-touch-zoom"), z(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        nt(this._map._container, "leaflet-touch-zoom"), X(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(t) {
        var e = this._map;
        if (!(!t.touches || t.touches.length !== 2 || e._animatingZoom || this._zooming)) {
          var i = e.mouseEventToContainerPoint(t.touches[0]), n = e.mouseEventToContainerPoint(t.touches[1]);
          this._centerPoint = e.getSize()._divideBy(2), this._startLatLng = e.containerPointToLatLng(this._centerPoint), e.options.touchZoom !== "center" && (this._pinchStartLatLng = e.containerPointToLatLng(i.add(n)._divideBy(2))), this._startDist = i.distanceTo(n), this._startZoom = e.getZoom(), this._moved = !1, this._zooming = !0, e._stop(), z(document, "touchmove", this._onTouchMove, this), z(document, "touchend touchcancel", this._onTouchEnd, this), ut(t);
        }
      },
      _onTouchMove: function(t) {
        if (!(!t.touches || t.touches.length !== 2 || !this._zooming)) {
          var e = this._map, i = e.mouseEventToContainerPoint(t.touches[0]), n = e.mouseEventToContainerPoint(t.touches[1]), s = i.distanceTo(n) / this._startDist;
          if (this._zoom = e.getScaleZoom(s, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && s < 1 || this._zoom > e.getMaxZoom() && s > 1) && (this._zoom = e._limitZoom(this._zoom)), e.options.touchZoom === "center") {
            if (this._center = this._startLatLng, s === 1)
              return;
          } else {
            var c = i._add(n)._divideBy(2)._subtract(this._centerPoint);
            if (s === 1 && c.x === 0 && c.y === 0)
              return;
            this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(c), this._zoom);
          }
          this._moved || (e._moveStart(!0, !1), this._moved = !0), it(this._animRequest);
          var f = u(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
          this._animRequest = Q(f, this, !0), ut(t);
        }
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = !1;
          return;
        }
        this._zooming = !1, it(this._animRequest), X(document, "touchmove", this._onTouchMove, this), X(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    });
    j.addInitHook("addHandler", "touchZoom", Lo), j.BoxZoom = wo, j.DoubleClickZoom = xo, j.Drag = Co, j.Keyboard = Ao, j.ScrollWheelZoom = Eo, j.TapHold = Po, j.TouchZoom = Lo, o.Bounds = tt, o.Browser = T, o.CRS = Rt, o.Canvas = vo, o.Circle = Ni, o.CircleMarker = Ne, o.Class = J, o.Control = xt, o.DivIcon = po, o.DivOverlay = Tt, o.DomEvent = Hr, o.DomUtil = Dr, o.Draggable = Nt, o.Evented = Ut, o.FeatureGroup = kt, o.GeoJSON = It, o.GridLayer = Ce, o.Handler = Lt, o.Icon = se, o.ImageOverlay = je, o.LatLng = W, o.LatLngBounds = mt, o.Layer = Ct, o.LayerGroup = re, o.LineUtil = Jr, o.Map = j, o.Marker = De, o.Mixin = Yr, o.Path = Ht, o.Point = O, o.PolyUtil = Wr, o.Polygon = ae, o.Polyline = Bt, o.Popup = qe, o.PosAnimation = Xn, o.Projection = $r, o.Rectangle = bo, o.Renderer = Ot, o.SVG = Ee, o.SVGOverlay = fo, o.TileLayer = le, o.Tooltip = Ve, o.Transformation = ci, o.Util = lt, o.VideoOverlay = uo, o.bind = u, o.bounds = pt, o.canvas = yo, o.circle = as, o.circleMarker = ss, o.control = be, o.divIcon = gs, o.extend = l, o.featureGroup = ns, o.geoJSON = co, o.geoJson = cs, o.gridLayer = vs, o.icon = os, o.imageOverlay = us, o.latLng = U, o.latLngBounds = st, o.layerGroup = is, o.map = Zr, o.marker = rs, o.point = I, o.polygon = ls, o.polyline = hs, o.popup = ps, o.rectangle = bs, o.setOptions = x, o.stamp = g, o.svg = _o, o.svgOverlay = fs, o.tileLayer = mo, o.tooltip = ms, o.transformation = de, o.version = h, o.videoOverlay = ds;
    var xs = window.L;
    o.noConflict = function() {
      return window.L = xs, this;
    }, window.L = o;
  });
})($i, $i.exports);
var At = $i.exports;
const ei = /* @__PURE__ */ Fo(At), Ko = /* @__PURE__ */ Bs({
  __proto__: null,
  default: ei
}, [At]);
function Jt() {
  return Jt = Object.assign ? Object.assign.bind() : function(a) {
    for (var r = 1; r < arguments.length; r++) {
      var o = arguments[r];
      for (var h in o)
        Object.prototype.hasOwnProperty.call(o, h) && (a[h] = o[h]);
    }
    return a;
  }, Jt.apply(this, arguments);
}
function ba(a, r) {
  a.prototype = Object.create(r.prototype), a.prototype.constructor = a, tn(a, r);
}
function tn(a, r) {
  return tn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, h) {
    return o.__proto__ = h, o;
  }, tn(a, r);
}
function zt(a, r, o, h) {
  r === void 0 && (r = ""), h === void 0 && (h = {});
  var l = document.createElement(a);
  return r && (l.className = r), Object.keys(h).forEach(function(d) {
    if (typeof h[d] == "function") {
      var u = d.indexOf("on") === 0 ? d.substr(2).toLowerCase() : d;
      l.addEventListener(u, h[d]);
    } else
      d === "html" ? l.innerHTML = h[d] : d === "text" ? l.innerText = h[d] : l.setAttribute(d, h[d]);
  }), o && o.appendChild(l), l;
}
function Pe(a) {
  a.preventDefault(), a.stopPropagation();
}
var ii = function() {
  return [].slice.call(arguments).filter(Boolean).join(" ").trim();
};
function $t(a, r) {
  a && a.classList && (Array.isArray(r) ? r : [r]).forEach(function(o) {
    a.classList.contains(o) || a.classList.add(o);
  });
}
function Mt(a, r) {
  a && a.classList && (Array.isArray(r) ? r : [r]).forEach(function(o) {
    a.classList.contains(o) && a.classList.remove(o);
  });
}
var en, ni = 13, nn = 40, Jo = 38, wa = [ni, 27, nn, Jo, 37, 39], xa = /* @__PURE__ */ function() {
  function a(o) {
    var h = this, l = o.handleSubmit, d = o.searchLabel, u = o.classNames, p = u === void 0 ? {} : u;
    this.container = void 0, this.form = void 0, this.input = void 0, this.handleSubmit = void 0, this.hasError = !1, this.container = zt("div", ii("geosearch", p.container)), this.form = zt("form", ["", p.form].join(" "), this.container, { autocomplete: "none", onClick: Pe, onDblClick: Pe, touchStart: Pe, touchEnd: Pe }), this.input = zt("input", ["glass", p.input].join(" "), this.form, { type: "text", placeholder: d || "search", onInput: this.onInput, onKeyUp: function(g) {
      return h.onKeyUp(g);
    }, onKeyPress: function(g) {
      return h.onKeyPress(g);
    }, onFocus: this.onFocus, onBlur: this.onBlur, onClick: function() {
      h.input.focus(), h.input.dispatchEvent(new Event("focus"));
    } }), this.handleSubmit = l;
  }
  var r = a.prototype;
  return r.onFocus = function() {
    $t(this.form, "active");
  }, r.onBlur = function() {
    Mt(this.form, "active");
  }, r.onSubmit = function(o) {
    try {
      var h = this;
      return Pe(o), Mt(l = h.container, "error"), $t(l, "pending"), Promise.resolve(h.handleSubmit({ query: h.input.value })).then(function() {
        Mt(h.container, "pending");
      });
    } catch (d) {
      return Promise.reject(d);
    }
    var l;
  }, r.onInput = function() {
    this.hasError && (Mt(this.container, "error"), this.hasError = !1);
  }, r.onKeyUp = function(o) {
    o.keyCode === 27 && (Mt(this.container, ["pending", "active"]), this.input.value = "", document.body.focus(), document.body.blur());
  }, r.onKeyPress = function(o) {
    o.keyCode === ni && this.onSubmit(o);
  }, r.setQuery = function(o) {
    this.input.value = o;
  }, a;
}(), Ca = /* @__PURE__ */ function() {
  function a(o) {
    var h = this, l = o.handleClick, d = o.classNames, u = d === void 0 ? {} : d, p = o.notFoundMessage;
    this.handleClick = void 0, this.selected = -1, this.results = [], this.container = void 0, this.resultItem = void 0, this.notFoundMessage = void 0, this.onClick = function(g) {
      if (typeof h.handleClick == "function") {
        var _ = g.target;
        if (_ && h.container.contains(_) && _.hasAttribute("data-key")) {
          var y = Number(_.getAttribute("data-key"));
          h.handleClick({ result: h.results[y] });
        }
      }
    }, this.handleClick = l, this.notFoundMessage = p ? zt("div", ii(u.notfound), void 0, { html: p }) : void 0, this.container = zt("div", ii("results", u.resultlist)), this.container.addEventListener("click", this.onClick, !0), this.resultItem = zt("div", ii(u.item));
  }
  var r = a.prototype;
  return r.render = function(o, h) {
    var l = this;
    o === void 0 && (o = []), this.clear(), o.forEach(function(d, u) {
      var p = l.resultItem.cloneNode(!0);
      p.setAttribute("data-key", "" + u), p.innerHTML = h({ result: d }), l.container.appendChild(p);
    }), o.length > 0 ? ($t(this.container.parentElement, "open"), $t(this.container, "active")) : this.notFoundMessage && (this.container.appendChild(this.notFoundMessage), $t(this.container.parentElement, "open")), this.results = o;
  }, r.select = function(o) {
    return Array.from(this.container.children).forEach(function(h, l) {
      return l === o ? $t(h, "active") : Mt(h, "active");
    }), this.selected = o, this.results[o];
  }, r.count = function() {
    return this.results ? this.results.length : 0;
  }, r.clear = function() {
    for (this.selected = -1; this.container.lastChild; )
      this.container.removeChild(this.container.lastChild);
    Mt(this.container.parentElement, "open"), Mt(this.container, "active");
  }, a;
}(), Wi = { position: "topleft", style: "button", showMarker: !0, showPopup: !1, popupFormat: function(a) {
  return "" + a.result.label;
}, resultFormat: function(a) {
  return "" + a.result.label;
}, marker: { icon: Ko && At.Icon ? new At.Icon.Default() : void 0, draggable: !1 }, maxMarkers: 1, maxSuggestions: 5, retainZoomLevel: !1, animateZoom: !0, searchLabel: "Enter address", clearSearchLabel: "Clear search", notFoundMessage: "", messageHideDelay: 3e3, zoomLevel: 18, classNames: { container: "leaflet-bar leaflet-control leaflet-control-geosearch", button: "leaflet-bar-part leaflet-bar-part-single", resetButton: "reset", msgbox: "leaflet-bar message", form: "", input: "", resultlist: "", item: "", notfound: "leaflet-bar-notfound" }, autoComplete: !0, autoCompleteDelay: 250, autoClose: !1, keepResult: !1, updateMap: !0 }, Aa = "Leaflet must be loaded before instantiating the GeoSearch control";
Jt({}, Wi), Jt({}, Wi.classNames);
(function(a) {
  a[a.SEARCH = 0] = "SEARCH", a[a.REVERSE = 1] = "REVERSE";
})(en || (en = {}));
var Ea = /* @__PURE__ */ function() {
  function a(o) {
    o === void 0 && (o = {}), this.options = void 0, this.options = o;
  }
  var r = a.prototype;
  return r.getParamString = function(o) {
    o === void 0 && (o = {});
    var h = Jt({}, this.options.params, o);
    return Object.keys(h).map(function(l) {
      return encodeURIComponent(l) + "=" + encodeURIComponent(h[l]);
    }).join("&");
  }, r.getUrl = function(o, h) {
    return o + "?" + this.getParamString(h);
  }, r.search = function(o) {
    try {
      var h = this, l = h.endpoint({ query: o.query, type: en.SEARCH });
      return Promise.resolve(fetch(l)).then(function(d) {
        return Promise.resolve(d.json()).then(function(u) {
          return h.parse({ data: u });
        });
      });
    } catch (d) {
      return Promise.reject(d);
    }
  }, a;
}();
function Pa(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var ue, La = /* @__PURE__ */ Pa(function a(r, o) {
  if (r === o)
    return !0;
  if (r && o && typeof r == "object" && typeof o == "object") {
    if (r.constructor !== o.constructor)
      return !1;
    var h, l, d;
    if (Array.isArray(r)) {
      if ((h = r.length) != o.length)
        return !1;
      for (l = h; l-- != 0; )
        if (!a(r[l], o[l]))
          return !1;
      return !0;
    }
    if (r.constructor === RegExp)
      return r.source === o.source && r.flags === o.flags;
    if (r.valueOf !== Object.prototype.valueOf)
      return r.valueOf() === o.valueOf();
    if (r.toString !== Object.prototype.toString)
      return r.toString() === o.toString();
    if ((h = (d = Object.keys(r)).length) !== Object.keys(o).length)
      return !1;
    for (l = h; l-- != 0; )
      if (!Object.prototype.hasOwnProperty.call(o, d[l]))
        return !1;
    for (l = h; l-- != 0; ) {
      var u = d[l];
      if (!a(r[u], o[u]))
        return !1;
    }
    return !0;
  }
  return r != r && o != o;
});
(function(a) {
  a[a.INITIALIZED = 0] = "INITIALIZED", a[a.LOADING = 1] = "LOADING", a[a.SUCCESS = 2] = "SUCCESS", a[a.FAILURE = 3] = "FAILURE";
})(ue || (ue = {}));
class Qt {
  constructor({ apiKey: r, authReferrerPolicy: o, channel: h, client: l, id: d = "__googleMapsScriptId", language: u, libraries: p = [], mapIds: g, nonce: _, region: y, retries: w = 3, url: P = "https://maps.googleapis.com/maps/api/js", version: E }) {
    if (this.callbacks = [], this.done = !1, this.loading = !1, this.errors = [], this.apiKey = r, this.authReferrerPolicy = o, this.channel = h, this.client = l, this.id = d || "__googleMapsScriptId", this.language = u, this.libraries = p, this.mapIds = g, this.nonce = _, this.region = y, this.retries = w, this.url = P, this.version = E, Qt.instance) {
      if (!La(this.options, Qt.instance.options))
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Qt.instance.options)}`);
      return Qt.instance;
    }
    Qt.instance = this;
  }
  get options() {
    return { version: this.version, apiKey: this.apiKey, channel: this.channel, client: this.client, id: this.id, libraries: this.libraries, language: this.language, region: this.region, mapIds: this.mapIds, nonce: this.nonce, url: this.url, authReferrerPolicy: this.authReferrerPolicy };
  }
  get status() {
    return this.errors.length ? ue.FAILURE : this.done ? ue.SUCCESS : this.loading ? ue.LOADING : ue.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  createUrl() {
    let r = this.url;
    return r += "?callback=__googleMapsCallback&loading=async", this.apiKey && (r += `&key=${this.apiKey}`), this.channel && (r += `&channel=${this.channel}`), this.client && (r += `&client=${this.client}`), this.libraries.length > 0 && (r += `&libraries=${this.libraries.join(",")}`), this.language && (r += `&language=${this.language}`), this.region && (r += `&region=${this.region}`), this.version && (r += `&v=${this.version}`), this.mapIds && (r += `&map_ids=${this.mapIds.join(",")}`), this.authReferrerPolicy && (r += `&auth_referrer_policy=${this.authReferrerPolicy}`), r;
  }
  deleteScript() {
    const r = document.getElementById(this.id);
    r && r.remove();
  }
  load() {
    return this.loadPromise();
  }
  loadPromise() {
    return new Promise((r, o) => {
      this.loadCallback((h) => {
        h ? o(h.error) : r(window.google);
      });
    });
  }
  importLibrary(r) {
    return this.execute(), google.maps.importLibrary(r);
  }
  loadCallback(r) {
    this.callbacks.push(r), this.execute();
  }
  setScript() {
    var r, o;
    if (document.getElementById(this.id))
      return void this.callback();
    const h = { key: this.apiKey, channel: this.channel, client: this.client, libraries: this.libraries.length && this.libraries, v: this.version, mapIds: this.mapIds, language: this.language, region: this.region, authReferrerPolicy: this.authReferrerPolicy };
    Object.keys(h).forEach((d) => !h[d] && delete h[d]), !((o = (r = window == null ? void 0 : window.google) === null || r === void 0 ? void 0 : r.maps) === null || o === void 0) && o.importLibrary || ((d) => {
      let u, p, g, _ = "The Google Maps JavaScript API", y = "google", w = "importLibrary", P = "__ib__", E = document, C = window;
      C = C[y] || (C[y] = {});
      const x = C.maps || (C.maps = {}), R = /* @__PURE__ */ new Set(), Z = new URLSearchParams(), S = () => u || (u = new Promise((B, G) => {
        return F = this, rt = function* () {
          var Y;
          for (g in yield p = E.createElement("script"), p.id = this.id, Z.set("libraries", [...R] + ""), d)
            Z.set(g.replace(/[A-Z]/g, (K) => "_" + K[0].toLowerCase()), d[g]);
          Z.set("callback", y + ".maps." + P), p.src = this.url + "?" + Z, x[P] = B, p.onerror = () => u = G(Error(_ + " could not load.")), p.nonce = this.nonce || ((Y = E.querySelector("script[nonce]")) === null || Y === void 0 ? void 0 : Y.nonce) || "", E.head.append(p);
        }, new ((V = void 0) || (V = Promise))(function(Y, K) {
          function vt(lt) {
            try {
              it(rt.next(lt));
            } catch (J) {
              K(J);
            }
          }
          function Q(lt) {
            try {
              it(rt.throw(lt));
            } catch (J) {
              K(J);
            }
          }
          function it(lt) {
            var J;
            lt.done ? Y(lt.value) : (J = lt.value, J instanceof V ? J : new V(function(ee) {
              ee(J);
            })).then(vt, Q);
          }
          it((rt = rt.apply(F, [])).next());
        });
        var F, V, rt;
      }));
      x[w] ? console.warn(_ + " only loads once. Ignoring:", d) : x[w] = (B, ...G) => R.add(B) && S().then(() => x[w](B, ...G));
    })(h);
    const l = this.libraries.map((d) => this.importLibrary(d));
    l.length || l.push(this.importLibrary("core")), Promise.all(l).then(() => this.callback(), (d) => {
      const u = new ErrorEvent("error", { error: d });
      this.loadErrorCallback(u);
    });
  }
  reset() {
    this.deleteScript(), this.done = !1, this.loading = !1, this.errors = [], this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    this.failed && this.reset();
  }
  loadErrorCallback(r) {
    if (this.errors.push(r), this.errors.length <= this.retries) {
      const o = this.errors.length * Math.pow(2, this.errors.length);
      console.error(`Failed to load Google Maps script, retrying in ${o} ms.`), setTimeout(() => {
        this.deleteScript(), this.setScript();
      }, o);
    } else
      this.onerrorEvent = r, this.callback();
  }
  callback() {
    this.done = !0, this.loading = !1, this.callbacks.forEach((r) => {
      r(this.onerrorEvent);
    }), this.callbacks = [];
  }
  execute() {
    if (this.resetIfRetryingFailed(), this.done)
      this.callback();
    else {
      if (window.google && window.google.maps && window.google.maps.version)
        return console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match."), void this.callback();
      this.loading || (this.loading = !0, this.setScript());
    }
  }
}
var Ta = /* @__PURE__ */ function(a) {
  function r(h) {
    var l;
    return (l = a.call(this, h) || this).loader = null, l.geocoder = null, typeof window < "u" && (l.loader = new Qt(h).load().then(function(d) {
      var u = new d.maps.Geocoder();
      return l.geocoder = u, u;
    })), l;
  }
  ba(r, a);
  var o = r.prototype;
  return o.endpoint = function(h) {
    throw new Error("Method not implemented.");
  }, o.parse = function(h) {
    return h.data.results.map(function(l) {
      var d = l.geometry.location.toJSON(), u = d.lat, p = d.lng, g = l.geometry.viewport.toJSON();
      return { x: p, y: u, label: l.formatted_address, bounds: [[g.south, g.west], [g.north, g.east]], raw: l };
    });
  }, o.search = function(h) {
    try {
      var l = function(p) {
        if (!p)
          throw new Error("GoogleMaps GeoCoder is not loaded. Are you trying to run this server side?");
        return Promise.resolve(p.geocode({ address: h.query }, function(g) {
          return { results: g };
        }).catch(function(g) {
          return g.code !== "ZERO_RESULTS" && console.error(g.code + ": " + g.message), { results: [] };
        })).then(function(g) {
          return d.parse({ data: g });
        });
      }, d = this, u = d.geocoder;
      return Promise.resolve(u ? l(u) : Promise.resolve(d.loader).then(l));
    } catch (p) {
      return Promise.reject(p);
    }
  }, r;
}(Ea);
class Sa {
  constructor() {
    k(this, "botHost", "endpoint-prod-chatgpt.mibot.cl:8080");
    k(this, "ssl", !0);
    // gpt_url = "https://endpoint-prod-chatgpt.mibot.cl:8080";
    k(this, "storage_url", "https://helpers.mibot.cl:444");
    k(this, "messageHistoryId", "");
    k(this, "chatflowID", "");
    k(this, "welcomeMessage", "Hola! En qu puedo ayudarte hoy?");
    k(this, "chathubChannelId", "");
    k(this, "projectPath", "/");
    k(this, "showThoughts", !0);
    k(this, "callbacks", {});
    k(this, "googleApikey", "");
  }
}
const H = new Sa();
class hi extends yt {
  constructor(r) {
    var h, l, d, u;
    super(), this.setStyles({
      display: "inline-block",
      boxSizing: "border-box",
      width: "100%",
      textAlign: "center",
      position: "relative",
      fontFamily: ot.typography.primary,
      overflow: "hidden",
      fontSize: "14px",
      color: "white",
      padding: "8px 0",
      zIndex: 2,
      borderRadius: "6px",
      marginTop: "16px"
    }), this.classList.add("addressActionButton");
    const o = new te();
    o.classList.add("bg-semi-transp"), this.innerText = (l = (h = H.callbacks) == null ? void 0 : h.addressButton) == null ? void 0 : l.text, this.appendChild(o), (u = (d = H.callbacks) == null ? void 0 : d.addressButton) != null && u.action && (this.onclick = (p) => {
      var g, _;
      return (_ = (g = H.callbacks) == null ? void 0 : g.addressButton) == null ? void 0 : _.action(r, p);
    });
  }
}
const on = "onbotgo-raisedbutton";
hi.tag = on;
const Ma = (a) => ({
  [`${on} .bg-semi-transp`]: {
    position: "absolute",
    width: "100%",
    height: "100%",
    opacity: "1",
    top: 0,
    "z-index": "-1",
    left: 0,
    "background-color": a.colors.primary
  },
  [`${on}:hover .bg-semi-transp`]: {
    position: "absolute",
    width: "100%",
    height: "100%",
    opacity: ".9",
    top: 0,
    "z-index": "-1",
    left: 0,
    "background-color": a.colors.primary
  }
});
class fn extends yt {
  constructor({ type: o, id: h, name: l, address: d, image_url: u, country: p, location: g, data: _ }) {
    super();
    k(this, "map");
    this.setStyles({
      boxShadow: "0 4px 8px 0 rgba(0,0,0,0.2)",
      transition: "0.3s",
      width: "72%",
      height: "30dvh",
      position: "relative"
    });
    const y = Math.floor(Math.random() * 1e4), w = document.createElement("div");
    w.id = y, w.style.width = "100%", w.style.height = "100%", w.id = `onbotgo-mapContainer-${y}`, this.appendChild(w);
    const P = this;
    new MutationObserver(function(C, x) {
      document.getElementById(
        `onbotgo-mapContainer-${y}`
      ) && (new Ta({
        apiKey: H.googleApikey
      }).search({ query: d }).then(([S]) => {
        var B, G, F, V;
        P.map = ei.map(w).setView(
          [
            (S == null ? void 0 : S.y) || -12.046064944817124,
            (S == null ? void 0 : S.x) || -77.04547005862791
          ],
          17
        ), ei.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(P.map), ei.marker([
          (S == null ? void 0 : S.y) || -12.046064944817124,
          (S == null ? void 0 : S.x) || -77.04547005862791
        ]).addTo(P.map), (["function"].includes(
          typeof ((G = (B = H.callbacks) == null ? void 0 : B.addressButton) == null ? void 0 : G.action)
        ) || ((V = (F = H.callbacks) == null ? void 0 : F.addressButton) == null ? void 0 : V.action) instanceof Promise) && P.appendChild(
          new hi({
            id: h,
            name: l,
            address: d,
            image_url: u,
            country: p,
            location: g || {
              lat: (S == null ? void 0 : S.y) || -12.046064944817124,
              lng: (S == null ? void 0 : S.x) || -77.04547005862791
            },
            data: _
          })
        );
      }), x.disconnect());
    }).observe(document, {
      childList: !0,
      subtree: !0
    });
  }
}
const $o = "onbotgo-card";
fn.tag = $o;
const Ra = (a) => ({
  [`${$o}:hover`]: {
    "box-shadow": "0 8px 16px 0 rgba(0,0,0,0.2)"
  }
}), Gt = "onbotgo-chatmessage";
class pn extends yt {
  constructor(o, h = !1) {
    super();
    k(this, "wavesurfer");
    k(this, "message");
    if (this.message = o, this.setStyles({
      width: "100%",
      display: "flex",
      minHeight: "max(45px, fit-content)",
      justifyContent: o.type === "userMessage" ? "flex-end" : "flex-start",
      alignItems: "center"
    }), this.innerHTML = this.renderHTML(sa, {
      type: o.type,
      fileType: o.fileType,
      file: o.file,
      message: o.message,
      iconPlayPause: Ji,
      render_map: o.render_map,
      isPlaying: !1
    }).replaceAll(`
`, " ").replace(/\n/g, " "), o.fileType === "audio") {
      let l;
      typeof o.file == "string" ? l = o.file : l = URL.createObjectURL(o.file), this.wavesurfer = ai.create({
        barHeight: 12,
        height: 24,
        barWidth: 1,
        container: this.querySelector("#waveform"),
        waveColor: "rgba(255, 255, 255, 0.6)",
        progressColor: "white",
        url: l
      }), this.handlePlayPause();
    } else if (o.fileType === "image") {
      const l = document.createElement("img");
      let d = typeof o.file == "string" ? o.file : URL.createObjectURL(o.file);
      l.src = d, l.style.objectFit = "cover", l.style.minHeight = "100px", l.style.minWidth = "100px", l.style.maxHeight = "80%", l.style.maxWidth = "80%", this.querySelector(".onbotgo-message").appendChild(l);
    } else if (!o.fileType && o.type === "userMessage") {
      const l = this.querySelector(".onbotgo-message");
      this.appendChild(this.getAvatarMessage("userMessage")), l.innerText += o.message;
    } else if (!o.fileType && o.type === "apiMessage") {
      const l = this.querySelector(".onbotgo-message");
      this.insertBefore(
        this.getAvatarMessage("apiMessage", h),
        l
      ), l.innerHTML += o.message;
    } else if (!o.fileType && o.type === "address" && o.render_map === "modal") {
      this.appendChild(this.getAvatarMessage("apiMessage"));
      const l = new fn(o);
      this.appendChild(l);
    } else if (!o.fileType && o.type === "address" && o.render_map === "background") {
      const l = this.querySelector(".onbotgo-message");
      l.innerHTML += `<span>${o.name}
                                        <ul>
                                          <li>Proyecto: ${o.data.proyecto}</li>
                                          <li>Precio: ${o.data.precio}</li>
                                          <li>Cuartos: ${o.data.cuartos}</li>
                                        </ul>
                                        </span>`, l.appendChild(new hi(o)), this.insertBefore(this.getAvatarMessage("apiMessage"), l);
    } else
      !o.fileType && o.type === "address" && o.render_map;
    o.type === "LoadingMessage" && this.setLoadingAnimation();
  }
  handlePlayPause() {
    this.querySelector("#onbotgo-playAudioMessage").onclick = () => {
      this.wavesurfer.play();
    }, this.wavesurfer.on("play", () => {
      this.querySelector("#onbotgo-playAudioMessage").onclick = () => {
        this.wavesurfer.pause();
      }, this.querySelector("#onbotgo-playAudioMessage").innerHTML = va;
    }), this.wavesurfer.on("pause", () => {
      this.querySelector("#onbotgo-playAudioMessage").onclick = () => {
        this.wavesurfer.play();
      }, this.querySelector("#onbotgo-playAudioMessage").innerHTML = Ji;
    });
  }
  setLoadingAnimation() {
    this.querySelectorAll(".dot").forEach(
      (o, h) => o.animate([{ transform: "translateY(-5px)", opacity: 0.2 }], {
        direction: "alternate",
        delay: h * 200,
        duration: 500,
        iterations: 1 / 0
      })
    );
  }
  getAvatarMessage(o = "api", h = !1) {
    const l = new te();
    let d;
    return o === "apiMessage" && !h ? d = Qo : o === "userMessage" ? d = _a : h && (d = ya), l.innerHTML = `<img src=${d} width="25" height="25" />`, l.setStyles({
      padding: "5px",
      marginRight: "10px",
      backgroundColor: ot.colors.primary,
      borderRadius: "100px",
      width: "35px !important",
      height: "25px",
      display: "grid",
      placeItems: "center"
    }), l;
  }
}
pn.tag = Gt;
const ka = (a) => ({
  [`${Gt} .onbotgo-message`]: {
    width: "fit-content !important",
    height: "fit-content",
    "border-radius": "6px",
    "align-items": "center",
    padding: "15px 15px",
    color: "white",
    "font-size": "14px"
  },
  [`${Gt} > .from-chatbot`]: {
    width: "100%",
    overflow: "hidden",
    position: "relative",
    color: "black",
    "max-width": "65%",
    "z-index": 1
  },
  [`${Gt} .bg-semi-transp`]: {
    position: "absolute",
    width: "100%",
    height: "100%",
    opacity: ".1",
    top: 0,
    "z-index": "-1",
    left: 0,
    "background-color": a.colors.primary
  },
  [`${Gt} > .from-user`]: {
    "margin-right": "15px",
    "max-width": "65%",
    "background-color": a.colors.primary
  },
  [`${Gt} .loading-api-message`]: {
    position: "relative",
    "z-index": 1,
    overflow: "hidden",
    "align-items": "center",
    display: "flex !important",
    "flex-direction": "row",
    height: "17px",
    width: "40px !important",
    gap: "5px"
  },
  [`${Gt} .dot`]: {
    transform: "translateY(2px)",
    "border-radius": "50px",
    height: "10px",
    "background-color": a.colors.primary,
    "vertical-align": "middle",
    width: "10px !important",
    display: "inline-block"
  }
}), zo = async (a) => {
  const r = `${H.ssl ? "https" : "http"}://${H.botHost}`;
  return (await fetch(`${r}${H.projectPath}chat`, {
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST",
    body: JSON.stringify(a)
  })).json();
}, Ba = async (a) => {
  const r = `${H.ssl ? "https" : "http"}://${H.botHost}`;
  return (await fetch(`${r}/messages/send`, {
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST",
    body: JSON.stringify(a)
  })).json();
}, Ia = `<input\r
  style="max-width: calc(100vw - 129px); font-size: 14px"\r
  type="text"\r
  autofocus\r
  placeholder="Escribe un mensaje"\r
/>\r
<onbotgo-box style="width: 100%; display: inline-block" class="send-icon-box">\r
  {{it.sendIcon | safe}}</onbotgo-box\r
>\r
`, tr = `  <svg\r
    xmlns="http://www.w3.org/2000/svg"\r
    viewBox="0 0 512 512"\r
    width="19px"\r
    class="send-icon flex"\r
    fill="currentColor"\r
  >\r
    <path\r
      d="M476.59 227.05l-.16-.07L49.35 49.84A23.56 23.56 0 0027.14 52 24.65 24.65 0 0016 72.59v113.29a24 24 0 0019.52 23.57l232.93 43.07a4 4 0 010 7.86L35.53 303.45A24 24 0 0016 327v113.31A23.57 23.57 0 0026.59 460a23.94 23.94 0 0013.22 4 24.55 24.55 0 009.52-1.93L476.4 285.94l.19-.09a32 32 0 000-58.8z"\r
    ></path>\r
  </svg>`, rn = "onbotgo-chatinput";
class mn extends yt {
  constructor() {
    super();
    k(this, "defaultStyles", {
      height: "50px",
      display: "grid",
      gridTemplateColumns: "10fr 1fr",
      alignItems: "center",
      borderRadius: "8px",
      boxShadow: "0 2px 6px -1px rgba(0,0,0,.1)"
    });
    k(this, "input");
    this.innerHTML = this.renderHTML(Ia, { sendIcon: tr }), this.input = this.querySelector("input"), this.sendIcon = this.querySelector(te.tag), this.input.style.fontFamily = ot.typography.primary, this.input.style.color = "black", this.setStyles(this.defaultStyles);
  }
  onSubmit(o) {
    this.sendIcon.onclick = () => o(this.input.value), this.input.onkeydown = (h) => {
      ["13", "Enter"].includes(h.key) && (o(this.input.value), this.input.value = "");
    };
  }
}
mn.tag = rn;
const Oa = (a) => ({
  [`${rn} > input`]: {
    "border-radius": "6px",
    outline: "none",
    border: "none",
    height: "100%",
    padding: "0 10px"
  },
  [`${rn} svg`]: {
    cursor: "pointer",
    fill: a.colors.primary
  }
});
class gn extends HTMLElement {
  constructor(o) {
    super();
    k(this, "container");
  }
  connectedCallback() {
    this.attachShadow({ mode: "open" }), this.targetElId = this.dataset.targetId, this.trackColor = this.dataset.trackColor || "#f2f2f2", this.trackWidth = this.dataset.trackWidth || "6px", this.thumbColor = this.dataset.thumbColor || "#c1c1c1", this.targetEl = document.querySelector("#onbotgo-messageContainer");
    const o = document.createElement("style");
    if (o.textContent = `
        .custom-scrollbar {
          width: ${this.trackWidth};
          height: 100%;
          position: absolute;
          top: 0;
          right: 0;
        }
  
        .custom-scrollbar__track {
          width: 100%;
          height: 100%;
          background-color: ${this.trackColor};
        }
  
        .custom-scrollbar__thumb {
          width: 100%;
          background-color: ${this.thumbColor};
          border-radius: ${this.trackWidth};
          position: absolute;
          top: 0;
          animation: top 0.25s ease-in;
  
        }
  
        .custom-scrollbar__thumb:hover {
          background-color: red;
        }
      `, this.shadowRoot.appendChild(o), !this.targetEl) {
      console.warn(
        `CustomScrollBar: target element with id "${this.targetElId}" not found`,
        this,
        this.dataset.targetId
      );
      return;
    }
    new IntersectionObserver((l) => {
      l.forEach((d) => {
        d.isIntersecting && (this.setTargetElCSS(), this.setScrollThumbHeight());
      });
    }).observe(this.targetEl), this.shadowRoot.innerHTML += `
        <div class="custom-scrollbar">
          <div class="custom-scrollbar__track">
            <div class="custom-scrollbar__thumb"></div>
          </div>
        </div>
      `, this.targetEl.addEventListener("scroll", () => {
      this.moveScrollThumb();
    });
  }
  moveScrollThumb() {
    const o = this.shadowRoot.querySelector(
      ".custom-scrollbar__thumb"
    ), h = this.shadowRoot.querySelector(
      ".custom-scrollbar__track"
    ).offsetHeight, l = this.targetEl.scrollTop / this.targetEl.scrollHeight * h;
    o.style.top = `${l}px`;
  }
  setTargetElCSS() {
    this.targetEl.style.overflowY = "scroll", this.targetEl.style.position = "relative", this.targetEl.style["-ms-overflow-style"] = "none", this.targetEl.style.scrollbarWidth = "none";
  }
  setScrollThumbHeight() {
    const o = this.shadowRoot.querySelector(
      ".custom-scrollbar__track"
    ), h = this.shadowRoot.querySelector(
      ".custom-scrollbar__thumb"
    ), l = o.offsetHeight, d = this.targetEl.offsetHeight, u = this.targetEl.scrollHeight, p = d / u * l;
    h.style.height = `${p}px`;
    let g = !1, _;
    h.addEventListener("mousedown", (y) => {
      g = !0, _ = y.clientY, this.preventContentHighlight("remove");
    }), document.addEventListener("mouseup", () => {
      g = !1, this.preventContentHighlight("add");
    }), document.addEventListener("mousemove", (y) => {
      if (!g)
        return;
      const w = y.clientY - _;
      _ = y.clientY, this.targetEl.scrollTop += w * (u / l);
    });
  }
  preventContentHighlight(o) {
    o ? this.targetEl.classList.add("prevent-scroll") : this.targetEl.classList.add("prevent-scroll");
  }
}
gn.tag = "onbotgo-customscrollbar";
const za = `<onbotgo-box\r
  style="\r
    padding: 20px;\r
    max-width: calc(100% - 40px);\r
    border-radius: 8px 8px 0 0;\r
    width: 100% !important;\r
  "\r
  id="onbotgo-chatheader"\r
>\r
</onbotgo-box>\r
<onbotgo-box\r
  style="\r
    height: 85%;\r
    padding: 0;\r
    position: relative;\r
    overflow: hidden;\r
    margin-bottom: 15px;\r
  "\r
>\r
  <onbotgo-customscrollbar\r
    style="visibility: hidden"\r
    data-target-id="scrollableElement"\r
  >\r
  </onbotgo-customscrollbar>\r
  <onbotgo-box\r
    id="onbotgo-messageContainer"\r
    style="\r
      height: calc(100% - 1.5rem);\r
      position: relative;\r
      display: flex;\r
      flex-direction: column;\r
      gap: 15px;\r
      position: relative;\r
      padding: 1rem 0.5rem;\r
      width: 100%;\r
    "\r
  >\r
  </onbotgo-box>\r
</onbotgo-box>\r
<onbotgo-box\r
  style="\r
    display: flex;\r
    gap: 10px;\r
    align-items: center;\r
    height: 48px;\r
    padding: 0 10px;\r
  "\r
>\r
  <onbotgo-box id="onbotgo-attachFileTemplateContainer"> </onbotgo-box>\r
  <onbotgo-chatinput\r
    id="onbotgo-chatinput"\r
    style="width: 100%"\r
  ></onbotgo-chatinput>\r
  <!-- <onbotgo-micrecord\r
    id="onbotgo-micrecord"\r
    style="width: 100%; display: flex; align-items: center; gap: 10px"\r
  ></onbotgo-micrecord> -->\r
  <!-- <onbotgo-iconbutton\r
    id="onbotgo-btnrecordSend"\r
    color="primary"\r
    size="36px"\r
    style="margin-top: 7px"\r
  >\r
    {{it.sendIcon | safe}}\r
  </onbotgo-iconbutton> -->\r
  <!-- <onbotgo-iconbutton\r
    id="onbotgo-btnrecord"\r
    color="primary"\r
    size="36px"\r
    style="margin-top: 7px"\r
  >\r
    {{it.micIcon | safe}}\r
  </onbotgo-iconbutton> -->\r
</onbotgo-box>\r
<onbotgo-box\r
  class="onbotgo-chat-footer"\r
  style="color: #a1a1a1; font-size: 10px; padding: 0 10px"\r
>\r
  Powered by ONBOTGO LLC. {{it.logo | safe}}\r
</onbotgo-box>\r
`, Da = `<onbotgo-dropdown>\r
  <input id="onbotgoAttachFileInput" type="file" style="display: none" />\r
  {{@if (it.attachedFiles.length > 0)}}\r
  <onbotgo-iconbutton\r
    color="primary"\r
    size="36px"\r
    style="margin-top: 7px"\r
    id="btnOnbotgoAttachInputMenu"\r
  >\r
    {{it.paperclipIcon | safe}}\r
    <onbotgo-box\r
      style="\r
        position: absolute;\r
        top: -3px;\r
        right: -3px;\r
        border-radius: 100px;\r
        z-index: 1;\r
        background-color: rgb(255, 43, 43);\r
        color: white;\r
        font-size: 12px;\r
        width: 16px;\r
        height: 16px;\r
        display: grid;\r
        place-items: center;\r
        opacity: 1;\r
      "\r
      >{{it.attachedFiles.length}}\r
    </onbotgo-box>\r
  </onbotgo-iconbutton>\r
  {{#else}}\r
  <onbotgo-iconbutton\r
    id="btnOnbotgoAttachInput"\r
    color="primary"\r
    size="36px"\r
    style="margin-top: 7px"\r
  >\r
    {{it.paperclipIcon | safe}}\r
  </onbotgo-iconbutton>\r
  {{ /if}}\r
  <onbotgo-box class="onbotgo-dropdown-content">\r
    {{@each(it.attachedFiles) => file}}\r
    <onbotgo-box\r
      class="onbotgo-attachedFile"\r
      style="\r
        display: flex !important;\r
        justify-content: space-between;\r
        gap: 14px;\r
      "\r
    >\r
      <span class="onbotgo-attachedFile-name">{{ file.name }}</span>\r
      <i style="width: 19px; color: red; cursor: pointer"\r
        >{{it.trashIcon | safe}}</i\r
      >\r
    </onbotgo-box>\r
    {{/each}}\r
    <onbotgo-box\r
      style="margin-top: 4px; display: flex !important; justify-content: center"\r
    >\r
      <onbotgo-fabbutton\r
        id="onbotgo-btnattachNewFile"\r
        style="margin: 0 auto"\r
        color="primary"\r
        size="20px"\r
      >\r
        {{it.iconPlus | safe}}\r
      </onbotgo-fabbutton>\r
    </onbotgo-box>\r
  </onbotgo-box>\r
</onbotgo-dropdown>\r
`, Na = `<svg\r
  version="1.1"\r
  id="Layer_1"\r
  xmlns="http://www.w3.org/2000/svg"\r
  xmlns:xlink="http://www.w3.org/1999/xlink"\r
  x="0px"\r
  y="0px"\r
  width="18px"\r
  viewBox="0 0 750 750"\r
  enable-background="new 0 0 750 750"\r
  xml:space="preserve"\r
>\r
  <path\r
    fill="#FFFFFF"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M1.000000,275.000000 \r
C1.000000,183.333328 1.000000,92.166664 1.000000,1.000000 \r
C251.000000,1.000000 501.000000,1.000000 751.000000,1.000000 \r
C751.000000,251.000000 751.000000,501.000000 751.000000,751.000000 \r
C501.000000,751.000000 251.000000,751.000000 1.000000,751.000000 \r
C1.000000,592.500000 1.000000,434.000000 1.000000,275.000000 \r
M88.022148,235.872009 \r
C88.066109,239.261810 88.110069,242.651611 88.010864,246.963760 \r
C88.007248,274.215515 87.981773,301.467316 88.006454,328.719025 \r
C88.028870,353.474365 88.105843,378.229645 88.028114,403.912079 \r
C88.070885,432.614319 88.113655,461.316589 88.011223,490.948303 \r
C88.011223,564.164307 88.011223,637.380310 88.011223,711.000000 \r
C89.651970,711.000000 90.946762,711.000000 92.241562,711.000000 \r
C173.328812,711.000000 254.416046,711.000671 335.503296,710.993347 \r
C336.664856,710.993225 337.826447,710.893311 339.740173,710.968079 \r
C340.498138,710.925598 341.256073,710.883179 342.939209,710.988770 \r
C448.829376,710.988770 554.719543,710.988770 661.000000,710.988770 \r
C661.000000,709.161926 661.000000,707.700012 661.000000,706.238037 \r
C661.000000,561.823059 661.000488,417.408081 660.993164,272.993103 \r
C660.993103,271.664703 660.890808,270.336334 660.976501,268.101013 \r
C660.929810,264.731171 660.883118,261.361298 660.988464,257.066162 \r
C660.988464,186.513000 660.988464,115.959831 660.988464,45.000008 \r
C659.334412,45.000008 658.048523,45.000008 656.762573,45.000008 \r
C567.016052,45.000011 477.269562,44.999424 387.523041,45.006451 \r
C386.361267,45.006542 385.199463,45.103436 383.107513,45.021538 \r
C376.391418,45.065651 369.675323,45.109764 362.033478,45.011021 \r
C270.770203,45.011021 179.506958,45.011021 88.000000,45.011021 \r
C88.000000,47.350853 88.000000,49.160931 88.000000,50.971008 \r
C88.000000,91.469856 87.983521,131.968719 88.006821,172.467545 \r
C88.018806,193.296692 88.101700,214.125809 88.022148,235.872009 \r
z"\r
  />\r
  <path\r
    fill="transparent"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M660.836304,269.007935 \r
C660.890808,270.336334 660.993103,271.664703 660.993164,272.993103 \r
C661.000488,417.408081 661.000000,561.823059 661.000000,706.238037 \r
C661.000000,707.700012 661.000000,709.161926 661.000000,710.988770 \r
C554.719543,710.988770 448.829376,710.988770 342.612183,710.600342 \r
C354.813660,702.671997 367.340149,695.128784 379.871277,687.593262 \r
C390.738831,681.058228 402.032745,675.130554 412.377930,667.853577 \r
C425.991974,658.277344 439.099365,647.933533 451.991119,637.389771 \r
C467.877472,624.396851 483.724030,611.299011 498.799652,597.392151 \r
C507.963715,588.938477 515.775452,578.988770 523.954712,569.504150 \r
C538.439514,552.707520 549.785095,533.937195 558.161499,513.409363 \r
C560.808716,506.921967 563.006042,500.251038 565.713440,492.830322 \r
C556.753967,498.322632 548.986145,503.390747 540.936951,507.963837 \r
C511.514709,524.679871 481.934021,541.117432 452.543457,557.888550 \r
C436.166565,567.233704 420.254089,577.406982 403.731659,586.477234 \r
C394.373016,591.614685 384.348755,596.810242 373.319977,595.728638 \r
C365.408691,594.952881 356.994965,593.025513 350.102051,589.246704 \r
C323.014618,574.396667 296.494812,558.514954 269.658997,543.200806 \r
C248.319962,531.023499 226.986938,518.818237 205.347137,507.191376 \r
C191.095123,499.533875 178.414276,489.886475 166.639206,479.022278 \r
C149.525314,463.232361 134.769669,445.530640 123.372070,425.029327 \r
C113.442574,407.168762 105.556778,388.526306 100.080093,368.907410 \r
C96.082901,354.588440 92.839447,340.059082 89.000000,324.574951 \r
C89.000000,327.191010 89.000000,328.779877 89.000000,330.368774 \r
C89.000000,352.867493 89.018204,375.366241 88.963676,397.864838 \r
C88.959534,399.572174 88.439163,401.278290 88.158752,402.984955 \r
C88.105843,378.229645 88.028870,353.474365 88.006454,328.719025 \r
C87.981773,301.467316 88.007248,274.215515 88.402878,246.753250 \r
C89.190285,249.641891 89.560684,252.744476 89.985207,255.839630 \r
C92.304466,272.749176 94.629791,289.657898 96.966827,306.565002 \r
C100.002563,328.526855 105.070808,350.047485 111.661903,371.181824 \r
C119.692017,396.930420 131.382629,420.953156 147.431259,442.692841 \r
C152.159348,449.097565 157.750427,454.865234 162.945999,460.924896 \r
C163.378723,460.675903 163.811462,460.426880 164.244186,460.177887 \r
C163.830154,457.137238 163.031525,454.092285 163.065216,451.056580 \r
C163.266144,432.947205 163.947632,414.839478 163.917236,396.732117 \r
C163.875946,372.123840 163.126129,347.516754 163.085403,322.908478 \r
C163.054611,304.302246 163.645523,285.694733 163.983414,267.088226 \r
C164.307480,249.242798 173.291382,236.313034 188.046371,227.585220 \r
C212.086807,213.364914 236.586807,199.923599 260.815887,186.019424 \r
C275.913269,177.355576 290.971710,168.614731 305.864838,159.606247 \r
C329.485443,145.318710 352.925720,130.947113 380.074188,123.713074 \r
C395.855530,119.507935 411.742645,116.007782 427.918396,115.276680 \r
C442.240356,114.629356 456.707184,115.866493 471.039856,117.092422 \r
C491.545654,118.846367 511.293640,124.429520 530.901733,130.443481 \r
C536.441589,132.142609 541.998474,133.786224 547.547546,135.455292 \r
C533.264282,126.341766 518.703918,118.120102 504.289001,109.650887 \r
C485.174622,98.420616 466.232117,86.897644 447.108307,75.683662 \r
C426.904327,63.836277 407.162476,50.987228 384.037689,45.155148 \r
C385.199463,45.103436 386.361267,45.006542 387.523041,45.006451 \r
C477.269562,44.999424 567.016052,45.000011 656.762573,45.000008 \r
C658.048523,45.000008 659.334412,45.000008 660.988464,45.000008 \r
C660.988464,115.959831 660.988464,186.513000 660.571899,257.272827 \r
C659.436462,247.123749 659.333679,236.679214 657.857422,226.432556 \r
C655.518433,210.197495 647.470215,196.708603 634.747131,186.461273 \r
C621.546448,175.829224 606.450439,168.101990 590.601685,162.458054 \r
C562.868164,152.581802 534.968567,143.071335 506.774200,134.623734 \r
C486.656555,128.596085 465.835846,125.333893 444.634064,126.005096 \r
C435.036224,126.308945 425.402802,126.258766 415.855072,127.130760 \r
C408.192749,127.830551 400.635345,129.678665 393.031372,131.017212 \r
C393.009155,131.450546 392.986938,131.883881 392.964722,132.317230 \r
C395.387238,133.431351 397.912415,134.366653 400.215668,135.688614 \r
C415.218597,144.299500 430.162628,153.012970 445.146393,161.657379 \r
C469.041748,175.443008 492.978973,189.156326 516.848450,202.986588 \r
C532.235535,211.902039 547.656616,220.770020 562.826843,230.044632 \r
C572.702698,236.082397 579.474243,244.993774 581.815308,256.380554 \r
C583.589539,265.010529 584.539185,273.903809 584.850159,282.715363 \r
C585.182129,292.123596 584.142395,301.571320 584.033936,311.005615 \r
C583.617065,347.260956 583.476990,383.520020 582.925842,419.773010 \r
C582.720032,433.310852 582.098938,446.874725 580.874756,460.354767 \r
C579.842102,471.726074 578.132507,483.087952 575.875610,494.283264 \r
C572.868408,509.200439 567.639160,523.533936 560.394043,536.875549 \r
C552.190308,551.982361 542.795227,566.437073 530.660217,578.808472 \r
C518.547241,591.157471 506.144348,603.222229 494.044006,615.583374 \r
C490.815613,618.881287 488.229584,622.807983 485.348663,626.446045 \r
C491.547546,621.735901 498.563354,617.728394 505.598969,613.756104 \r
C529.489624,600.267334 553.431519,586.868713 577.266846,573.283081 \r
C593.570557,563.990295 609.949951,554.798584 625.882996,544.897827 \r
C638.626770,536.978821 649.122620,526.673767 654.473633,512.071960 \r
C658.715393,500.497162 659.443359,488.313690 659.812927,476.268036 \r
C660.265198,461.528809 659.140503,446.748413 659.044739,431.983582 \r
C658.884705,407.300842 658.873840,382.615417 659.040283,357.932770 \r
C659.166809,339.169373 659.719177,320.409210 659.977661,301.646179 \r
C660.106140,292.317657 659.961853,282.985565 660.037415,273.655884 \r
C660.050049,272.104523 660.557556,270.557159 660.836304,269.007935 \r
M339.001434,209.498001 \r
C332.685333,213.152039 326.330139,216.740326 320.060333,220.472153 \r
C299.299225,232.829269 278.578827,245.254822 257.823700,257.622040 \r
C240.037231,268.220337 230.149826,283.648712 230.059875,304.524628 \r
C229.865326,349.677246 230.046677,394.831390 229.906082,439.984375 \r
C229.895508,443.378235 230.973923,445.314972 233.739502,446.991974 \r
C251.767258,457.923615 269.707184,469.000000 287.726074,479.946381 \r
C320.565491,499.896088 353.432709,519.800232 386.308350,539.690186 \r
C390.617188,542.297058 395.044006,544.708923 400.000000,547.545227 \r
C400.000000,534.663208 399.855957,522.836243 400.138153,511.019440 \r
C400.186646,508.988983 401.519684,506.082153 403.157440,505.138031 \r
C418.337189,496.387085 433.702057,487.956421 449.036469,479.474884 \r
C468.059143,468.953369 487.075012,458.418854 506.161682,448.014435 \r
C510.338379,445.737701 512.194275,443.093658 512.164490,437.858551 \r
C511.886688,389.041107 512.138977,340.220764 511.902710,291.402863 \r
C511.843323,279.133850 506.774170,268.528107 498.766693,259.164154 \r
C490.816589,249.867325 479.774414,245.478973 469.485229,239.949310 \r
C444.881744,226.726791 420.104919,213.826996 395.409485,200.775330 \r
C389.522583,197.664078 383.451447,194.816299 377.910095,191.170822 \r
C374.946442,189.221176 372.921173,189.248917 370.123901,190.941299 \r
C360.003204,197.064438 349.788422,203.032059 339.001434,209.498001 \r
z"\r
  />\r
  <path\r
    fill="#3B88F4"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M88.093430,403.448517 \r
C88.439163,401.278290 88.959534,399.572174 88.963676,397.864838 \r
C89.018204,375.366241 89.000000,352.867493 89.000000,330.368774 \r
C89.000000,328.779877 89.000000,327.191010 89.000000,324.574951 \r
C92.839447,340.059082 96.082901,354.588440 100.080093,368.907410 \r
C105.556778,388.526306 113.442574,407.168762 123.372070,425.029327 \r
C134.769669,445.530640 149.525314,463.232361 166.639206,479.022278 \r
C178.414276,489.886475 191.095123,499.533875 205.347137,507.191376 \r
C226.986938,518.818237 248.319962,531.023499 269.658997,543.200806 \r
C296.494812,558.514954 323.014618,574.396667 350.102051,589.246704 \r
C356.994965,593.025513 365.408691,594.952881 373.319977,595.728638 \r
C384.348755,596.810242 394.373016,591.614685 403.731659,586.477234 \r
C420.254089,577.406982 436.166565,567.233704 452.543457,557.888550 \r
C481.934021,541.117432 511.514709,524.679871 540.936951,507.963837 \r
C548.986145,503.390747 556.753967,498.322632 565.713440,492.830322 \r
C563.006042,500.251038 560.808716,506.921967 558.161499,513.409363 \r
C549.785095,533.937195 538.439514,552.707520 523.954712,569.504150 \r
C515.775452,578.988770 507.963715,588.938477 498.799652,597.392151 \r
C483.724030,611.299011 467.877472,624.396851 451.991119,637.389771 \r
C439.099365,647.933533 425.991974,658.277344 412.377930,667.853577 \r
C402.032745,675.130554 390.738831,681.058228 379.871277,687.593262 \r
C367.340149,695.128784 354.813660,702.671997 342.149597,710.526245 \r
C341.256073,710.883179 340.498138,710.925598 339.368835,710.446899 \r
C338.998291,698.265625 338.881378,686.603638 339.071228,674.946533 \r
C339.128754,671.413513 338.390930,669.317444 334.764679,667.820618 \r
C329.523590,665.657288 324.549042,662.771912 319.643890,659.883667 \r
C294.297424,644.958618 269.131317,629.723389 243.666870,615.003662 \r
C217.624802,599.949890 191.421112,585.166382 165.076874,570.647888 \r
C146.690262,560.514832 128.040314,550.794678 111.546669,537.709595 \r
C102.050766,530.176147 94.851891,520.595764 92.008911,508.416321 \r
C90.585037,502.316437 89.431969,496.153351 88.156425,490.018829 \r
C88.113655,461.316589 88.070885,432.614319 88.093430,403.448517 \r
z"\r
  />\r
  <path\r
    fill="#32A850"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M383.572601,45.088341 \r
C407.162476,50.987228 426.904327,63.836277 447.108307,75.683662 \r
C466.232117,86.897644 485.174622,98.420616 504.289001,109.650887 \r
C518.703918,118.120102 533.264282,126.341766 547.547546,135.455292 \r
C541.998474,133.786224 536.441589,132.142609 530.901733,130.443481 \r
C511.293640,124.429520 491.545654,118.846367 471.039856,117.092422 \r
C456.707184,115.866493 442.240356,114.629356 427.918396,115.276680 \r
C411.742645,116.007782 395.855530,119.507935 380.074188,123.713074 \r
C352.925720,130.947113 329.485443,145.318710 305.864838,159.606247 \r
C290.971710,168.614731 275.913269,177.355576 260.815887,186.019424 \r
C236.586807,199.923599 212.086807,213.364914 188.046371,227.585220 \r
C173.291382,236.313034 164.307480,249.242798 163.983414,267.088226 \r
C163.645523,285.694733 163.054611,304.302246 163.085403,322.908478 \r
C163.126129,347.516754 163.875946,372.123840 163.917236,396.732117 \r
C163.947632,414.839478 163.266144,432.947205 163.065216,451.056580 \r
C163.031525,454.092285 163.830154,457.137238 164.244186,460.177887 \r
C163.811462,460.426880 163.378723,460.675903 162.945999,460.924896 \r
C157.750427,454.865234 152.159348,449.097565 147.431259,442.692841 \r
C131.382629,420.953156 119.692017,396.930420 111.661903,371.181824 \r
C105.070808,350.047485 100.002563,328.526855 96.966827,306.565002 \r
C94.629791,289.657898 92.304466,272.749176 89.985207,255.839630 \r
C89.560684,252.744476 89.190285,249.641891 88.474457,246.292084 \r
C88.110069,242.651611 88.066109,239.261810 88.408829,235.161133 \r
C89.653336,211.424240 99.461922,193.358643 119.043915,181.049942 \r
C132.237259,172.756958 145.615982,164.737106 159.150604,157.013580 \r
C183.551834,143.089035 208.243027,129.671341 232.604355,115.678505 \r
C254.099243,103.332130 275.279449,90.439117 296.653839,77.881470 \r
C317.957275,65.365509 338.669800,51.629372 362.959229,45.153877 \r
C369.675323,45.109764 376.391418,45.065651 383.572601,45.088341 \r
z"\r
  />\r
  <path\r
    fill="#EA4033"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M660.906372,268.554474 \r
C660.557556,270.557159 660.050049,272.104523 660.037415,273.655884 \r
C659.961853,282.985565 660.106140,292.317657 659.977661,301.646179 \r
C659.719177,320.409210 659.166809,339.169373 659.040283,357.932770 \r
C658.873840,382.615417 658.884705,407.300842 659.044739,431.983582 \r
C659.140503,446.748413 660.265198,461.528809 659.812927,476.268036 \r
C659.443359,488.313690 658.715393,500.497162 654.473633,512.071960 \r
C649.122620,526.673767 638.626770,536.978821 625.882996,544.897827 \r
C609.949951,554.798584 593.570557,563.990295 577.266846,573.283081 \r
C553.431519,586.868713 529.489624,600.267334 505.598969,613.756104 \r
C498.563354,617.728394 491.547546,621.735901 485.348663,626.446045 \r
C488.229584,622.807983 490.815613,618.881287 494.044006,615.583374 \r
C506.144348,603.222229 518.547241,591.157471 530.660217,578.808472 \r
C542.795227,566.437073 552.190308,551.982361 560.394043,536.875549 \r
C567.639160,523.533936 572.868408,509.200439 575.875610,494.283264 \r
C578.132507,483.087952 579.842102,471.726074 580.874756,460.354767 \r
C582.098938,446.874725 582.720032,433.310852 582.925842,419.773010 \r
C583.476990,383.520020 583.617065,347.260956 584.033936,311.005615 \r
C584.142395,301.571320 585.182129,292.123596 584.850159,282.715363 \r
C584.539185,273.903809 583.589539,265.010529 581.815308,256.380554 \r
C579.474243,244.993774 572.702698,236.082397 562.826843,230.044632 \r
C547.656616,220.770020 532.235535,211.902039 516.848450,202.986588 \r
C492.978973,189.156326 469.041748,175.443008 445.146393,161.657379 \r
C430.162628,153.012970 415.218597,144.299500 400.215668,135.688614 \r
C397.912415,134.366653 395.387238,133.431351 392.964722,132.317230 \r
C392.986938,131.883881 393.009155,131.450546 393.031372,131.017212 \r
C400.635345,129.678665 408.192749,127.830551 415.855072,127.130760 \r
C425.402802,126.258766 435.036224,126.308945 444.634064,126.005096 \r
C465.835846,125.333893 486.656555,128.596085 506.774200,134.623734 \r
C534.968567,143.071335 562.868164,152.581802 590.601685,162.458054 \r
C606.450439,168.101990 621.546448,175.829224 634.747131,186.461273 \r
C647.470215,196.708603 655.518433,210.197495 657.857422,226.432556 \r
C659.333679,236.679214 659.436462,247.123749 660.495850,257.735474 \r
C660.883118,261.361298 660.929810,264.731171 660.906372,268.554474 \r
z"\r
  />\r
  <path\r
    fill="transparent"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M88.083824,490.483582 \r
C89.431969,496.153351 90.585037,502.316437 92.008911,508.416321 \r
C94.851891,520.595764 102.050766,530.176147 111.546669,537.709595 \r
C128.040314,550.794678 146.690262,560.514832 165.076874,570.647888 \r
C191.421112,585.166382 217.624802,599.949890 243.666870,615.003662 \r
C269.131317,629.723389 294.297424,644.958618 319.643890,659.883667 \r
C324.549042,662.771912 329.523590,665.657288 334.764679,667.820618 \r
C338.390930,669.317444 339.128754,671.413513 339.071228,674.946533 \r
C338.881378,686.603638 338.998291,698.265625 338.992737,710.382935 \r
C337.826447,710.893311 336.664856,710.993225 335.503296,710.993347 \r
C254.416046,711.000671 173.328812,711.000000 92.241562,711.000000 \r
C90.946762,711.000000 89.651970,711.000000 88.011223,711.000000 \r
C88.011223,637.380310 88.011223,564.164307 88.083824,490.483582 \r
z"\r
  />\r
  <path\r
    fill="transparent"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M362.496338,45.082451 \r
C338.669800,51.629372 317.957275,65.365509 296.653839,77.881470 \r
C275.279449,90.439117 254.099243,103.332130 232.604355,115.678505 \r
C208.243027,129.671341 183.551834,143.089035 159.150604,157.013580 \r
C145.615982,164.737106 132.237259,172.756958 119.043915,181.049942 \r
C99.461922,193.358643 89.653336,211.424240 88.474030,234.702606 \r
C88.101700,214.125809 88.018806,193.296692 88.006821,172.467545 \r
C87.983521,131.968719 88.000000,91.469856 88.000000,50.971008 \r
C88.000000,49.160931 88.000000,47.350853 88.000000,45.011021 \r
C179.506958,45.011021 270.770203,45.011021 362.496338,45.082451 \r
z"\r
  />\r
  <path\r
    fill="#F8BF00"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M339.305298,209.278198 \r
C349.788422,203.032059 360.003204,197.064438 370.123901,190.941299 \r
C372.921173,189.248917 374.946442,189.221176 377.910095,191.170822 \r
C383.451447,194.816299 389.522583,197.664078 395.409485,200.775330 \r
C420.104919,213.826996 444.881744,226.726791 469.485229,239.949310 \r
C479.774414,245.478973 490.816589,249.867325 498.766693,259.164154 \r
C506.774170,268.528107 511.843323,279.133850 511.902710,291.402863 \r
C512.138977,340.220764 511.886688,389.041107 512.164490,437.858551 \r
C512.194275,443.093658 510.338379,445.737701 506.161682,448.014435 \r
C487.075012,458.418854 468.059143,468.953369 449.036469,479.474884 \r
C433.702057,487.956421 418.337189,496.387085 403.157440,505.138031 \r
C401.519684,506.082153 400.186646,508.988983 400.138153,511.019440 \r
C399.855957,522.836243 400.000000,534.663208 400.000000,547.545227 \r
C395.044006,544.708923 390.617188,542.297058 386.308350,539.690186 \r
C353.432709,519.800232 320.565491,499.896088 287.726074,479.946381 \r
C269.707184,469.000000 251.767258,457.923615 233.739502,446.991974 \r
C230.973923,445.314972 229.895508,443.378235 229.906082,439.984375 \r
C230.046677,394.831390 229.865326,349.677246 230.059875,304.524628 \r
C230.149826,283.648712 240.037231,268.220337 257.823700,257.622040 \r
C278.578827,245.254822 299.299225,232.829269 320.060333,220.472153 \r
C326.330139,216.740326 332.685333,213.152039 339.305298,209.278198 \r
M434.683777,322.998627 \r
C433.432404,323.315918 432.196838,323.732269 430.927155,323.934601 \r
C421.965851,325.362366 418.105682,335.934540 419.074524,341.828735 \r
C420.433807,350.098267 429.368927,358.023254 436.553192,356.885986 \r
C446.404022,355.326660 453.002350,349.320312 452.819550,339.182343 \r
C452.661957,330.440094 447.804291,323.684448 434.683777,322.998627 \r
M327.955780,343.822937 \r
C327.779602,340.539917 328.292847,337.029419 327.298553,334.016357 \r
C324.265228,324.824219 313.268433,320.300476 304.278931,324.335938 \r
C296.468933,327.841919 291.660919,337.514313 296.220612,347.394775 \r
C299.365784,354.209961 307.299225,357.696686 314.529236,356.081970 \r
C321.055634,354.624481 325.089722,350.462372 327.955780,343.822937 \r
z"\r
  />\r
  <path\r
    fill="#FFFFFF"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M435.116150,322.998901 \r
C447.804291,323.684448 452.661957,330.440094 452.819550,339.182343 \r
C453.002350,349.320312 446.404022,355.326660 436.553192,356.885986 \r
C429.368927,358.023254 420.433807,350.098267 419.074524,341.828735 \r
C418.105682,335.934540 421.965851,325.362366 430.927155,323.934601 \r
C432.196838,323.732269 433.432404,323.315918 435.116150,322.998901 \r
z"\r
  />\r
  <path\r
    fill="#FFFFFE"\r
    opacity="1.000000"\r
    stroke="none"\r
    d="\r
M327.856506,344.228943 \r
C325.089722,350.462372 321.055634,354.624481 314.529236,356.081970 \r
C307.299225,357.696686 299.365784,354.209961 296.220612,347.394775 \r
C291.660919,337.514313 296.468933,327.841919 304.278931,324.335938 \r
C313.268433,320.300476 324.265228,324.824219 327.298553,334.016357 \r
C328.292847,337.029419 327.779602,340.539917 327.856506,344.228943 \r
z"\r
  />\r
</svg>\r
`, Ha = ` <svg\r
    xmlns="http://www.w3.org/2000/svg"\r
    xmlns:xlink="http://www.w3.org/1999/xlink"\r
    version="1.1"\r
    viewBox="0 0 256 256"\r
    xml:space="preserve"\r
  >\r
    <defs></defs>\r
    <g\r
      style="\r
        stroke: none;\r
        stroke-width: 0;\r
        stroke-dasharray: none;\r
        stroke-linecap: butt;\r
        stroke-linejoin: miter;\r
        stroke-miterlimit: 10;\r
        fill: none;\r
        fill-rule: nonzero;\r
        opacity: 1;\r
      "\r
      transform="translate(1.4065934065934016 1.4065934065934016) scale(2.81 2.81)"\r
    >\r
      <path\r
        d="M 45 70.968 c -16.013 0 -29.042 -13.028 -29.042 -29.042 c 0 -1.712 1.388 -3.099 3.099 -3.099 c 1.712 0 3.099 1.388 3.099 3.099 C 22.157 54.522 32.404 64.77 45 64.77 c 12.595 0 22.843 -10.248 22.843 -22.843 c 0 -1.712 1.387 -3.099 3.099 -3.099 s 3.099 1.388 3.099 3.099 C 74.042 57.94 61.013 70.968 45 70.968 z"\r
        style="\r
          stroke: none;\r
          stroke-width: 1;\r
          stroke-dasharray: none;\r
          stroke-linecap: butt;\r
          stroke-linejoin: miter;\r
          stroke-miterlimit: 10;\r
          fill: currentColor;\r
          fill-rule: nonzero;\r
          opacity: 1;\r
        "\r
        transform=" matrix(1 0 0 1 0 0) "\r
        stroke-linecap="round"\r
      />\r
      <path\r
        d="M 45 60.738 L 45 60.738 c -10.285 0 -18.7 -8.415 -18.7 -18.7 V 18.7 C 26.3 8.415 34.715 0 45 0 h 0 c 10.285 0 18.7 8.415 18.7 18.7 v 23.337 C 63.7 52.322 55.285 60.738 45 60.738 z"\r
        style="\r
          stroke: none;\r
          stroke-width: 1;\r
          stroke-dasharray: none;\r
          stroke-linecap: butt;\r
          stroke-linejoin: miter;\r
          stroke-miterlimit: 10;\r
          fill: currentColor;\r
          fill-rule: nonzero;\r
          opacity: 1;\r
        "\r
        transform=" matrix(1 0 0 1 0 0) "\r
        stroke-linecap="round"\r
      />\r
      <path\r
        d="M 45 89.213 c -1.712 0 -3.099 -1.387 -3.099 -3.099 V 68.655 c 0 -1.712 1.388 -3.099 3.099 -3.099 c 1.712 0 3.099 1.387 3.099 3.099 v 17.459 C 48.099 87.826 46.712 89.213 45 89.213 z"\r
        style="\r
          stroke: none;\r
          stroke-width: 1;\r
          stroke-dasharray: none;\r
          stroke-linecap: butt;\r
          stroke-linejoin: miter;\r
          stroke-miterlimit: 10;\r
          fill: currentColor;\r
          fill-rule: nonzero;\r
          opacity: 1;\r
        "\r
        transform=" matrix(1 0 0 1 0 0) "\r
        stroke-linecap="round"\r
      />\r
      <path\r
        d="M 55.451 90 H 34.549 c -1.712 0 -3.099 -1.387 -3.099 -3.099 s 1.388 -3.099 3.099 -3.099 h 20.901 c 1.712 0 3.099 1.387 3.099 3.099 S 57.163 90 55.451 90 z"\r
        style="\r
          stroke: none;\r
          stroke-width: 1;\r
          stroke-dasharray: none;\r
          stroke-linecap: butt;\r
          stroke-linejoin: miter;\r
          stroke-miterlimit: 10;\r
          fill: currentColor;\r
          fill-rule: nonzero;\r
          opacity: 1;\r
        "\r
        transform=" matrix(1 0 0 1 0 0) "\r
        stroke-linecap="round"\r
      />\r
    </g>\r
  </svg>`, Do = ` <svg\r
      xmlns="http://www.w3.org/2000/svg"\r
      viewBox="0 0 256 256"\r
      style="vertical-align: middle"\r
      stroke="currentColor"\r
    >\r
      <rect fill="none"></rect>\r
      <path\r
        fill="none"\r
        stroke-linecap="round"\r
        stroke-linejoin="round"\r
        stroke-width="16"\r
        d="M159.99414,79.99512,76.68629,164.68629a16,16,0,0,0,22.62742,22.62742L198.62156,86.62253A32,32,0,1,0,153.36672,41.3677L54.05887,142.05887a48,48,0,0,0,67.88226,67.88226l82.053-81.946"\r
      ></path>\r
    </svg>`, sn = `<svg viewBox="-3 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\r
    \r
    <defs>\r
\r
</defs>\r
    <g id="Page-1" stroke="none" stroke-width="1" fill="none">\r
        <g id="Icon-Set"  transform="translate(-259.000000, -203.000000)" fill="currentColor">\r
            <path d="M282,211 L262,211 C261.448,211 261,210.553 261,210 C261,209.448 261.448,209 262,209 L282,209 C282.552,209 283,209.448 283,210 C283,210.553 282.552,211 282,211 L282,211 Z M281,231 C281,232.104 280.104,233 279,233 L265,233 C263.896,233 263,232.104 263,231 L263,213 L281,213 L281,231 L281,231 Z M269,206 C269,205.447 269.448,205 270,205 L274,205 C274.552,205 275,205.447 275,206 L275,207 L269,207 L269,206 L269,206 Z M283,207 L277,207 L277,205 C277,203.896 276.104,203 275,203 L269,203 C267.896,203 267,203.896 267,205 L267,207 L261,207 C259.896,207 259,207.896 259,209 L259,211 C259,212.104 259.896,213 261,213 L261,231 C261,233.209 262.791,235 265,235 L279,235 C281.209,235 283,233.209 283,231 L283,213 C284.104,213 285,212.104 285,211 L285,209 C285,207.896 284.104,207 283,207 L283,207 Z M272,231 C272.552,231 273,230.553 273,230 L273,218 C273,217.448 272.552,217 272,217 C271.448,217 271,217.448 271,218 L271,230 C271,230.553 271.448,231 272,231 L272,231 Z M267,231 C267.552,231 268,230.553 268,230 L268,218 C268,217.448 267.552,217 267,217 C266.448,217 266,217.448 266,218 L266,230 C266,230.553 266.448,231 267,231 L267,231 Z M277,231 C277.552,231 278,230.553 278,230 L278,218 C278,217.448 277.552,217 277,217 C276.448,217 276,217.448 276,218 L276,230 C276,230.553 276.448,231 277,231 L277,231 Z" id="trash" sketch:type="MSShapeGroup">\r
\r
</path>\r
        </g>\r
    </g>\r
</svg>`, No = '<svg  style="enable-background:new 0 0 32 32;" version="1.1" viewBox="0 0 32 32" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28,14H18V4c0-1.104-0.896-2-2-2s-2,0.896-2,2v10H4c-1.104,0-2,0.896-2,2s0.896,2,2,2h10v10c0,1.104,0.896,2,2,2  s2-0.896,2-2V18h10c1.104,0,2-0.896,2-2S29.104,14,28,14z"/></svg>';
class an {
}
k(an, "messageHistoryId", {
  get: () => sessionStorage.getItem("onbotgo-messageHistory-id"),
  set: (r) => sessionStorage.setItem("onbotgo-messageHistory-id", r),
  remove: () => sessionStorage.removeItem("onbotgo-messageHistory-id")
}), k(an, "messagesHistory", {
  get: () => JSON.parse(sessionStorage.getItem("onbotgo-messageHistory") ?? "[]"),
  add: (r) => {
    const o = JSON.parse(
      sessionStorage.getItem("onbotgo-messageHistory") ?? "[]"
    );
    sessionStorage.setItem(
      "onbotgo-messageHistory",
      JSON.stringify([...o, ...r])
    );
  },
  remove: () => sessionStorage.removeItem("onbotgo-messageHistory")
});
const Za = async (a) => await fetch(`${H.storage_url}/storage/upload`, {
  headers: {
    "Content-Type": "application/json"
  },
  method: "POST",
  body: JSON.stringify(a)
}).then((r) => r.json());
var er = { exports: {} };
/*!
 * Toastify js 1.12.0
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */
(function(a) {
  (function(r, o) {
    a.exports ? a.exports = o() : r.Toastify = o();
  })(Zo, function(r) {
    var o = function(u) {
      return new o.lib.init(u);
    }, h = "1.12.0";
    o.defaults = {
      oldestFirst: !0,
      text: "Toastify is awesome!",
      node: void 0,
      duration: 3e3,
      selector: void 0,
      callback: function() {
      },
      destination: void 0,
      newWindow: !1,
      close: !1,
      gravity: "toastify-top",
      positionLeft: !1,
      position: "",
      backgroundColor: "",
      avatar: "",
      className: "",
      stopOnFocus: !0,
      onClick: function() {
      },
      offset: { x: 0, y: 0 },
      escapeMarkup: !0,
      ariaLive: "polite",
      style: { background: "" }
    }, o.lib = o.prototype = {
      toastify: h,
      constructor: o,
      // Initializing the object with required parameters
      init: function(u) {
        return u || (u = {}), this.options = {}, this.toastElement = null, this.options.text = u.text || o.defaults.text, this.options.node = u.node || o.defaults.node, this.options.duration = u.duration === 0 ? 0 : u.duration || o.defaults.duration, this.options.selector = u.selector || o.defaults.selector, this.options.callback = u.callback || o.defaults.callback, this.options.destination = u.destination || o.defaults.destination, this.options.newWindow = u.newWindow || o.defaults.newWindow, this.options.close = u.close || o.defaults.close, this.options.gravity = u.gravity === "bottom" ? "toastify-bottom" : o.defaults.gravity, this.options.positionLeft = u.positionLeft || o.defaults.positionLeft, this.options.position = u.position || o.defaults.position, this.options.backgroundColor = u.backgroundColor || o.defaults.backgroundColor, this.options.avatar = u.avatar || o.defaults.avatar, this.options.className = u.className || o.defaults.className, this.options.stopOnFocus = u.stopOnFocus === void 0 ? o.defaults.stopOnFocus : u.stopOnFocus, this.options.onClick = u.onClick || o.defaults.onClick, this.options.offset = u.offset || o.defaults.offset, this.options.escapeMarkup = u.escapeMarkup !== void 0 ? u.escapeMarkup : o.defaults.escapeMarkup, this.options.ariaLive = u.ariaLive || o.defaults.ariaLive, this.options.style = u.style || o.defaults.style, u.backgroundColor && (this.options.style.background = u.backgroundColor), this;
      },
      // Building the DOM element
      buildToast: function() {
        if (!this.options)
          throw "Toastify is not initialized";
        var u = document.createElement("div");
        u.className = "toastify on " + this.options.className, this.options.position ? u.className += " toastify-" + this.options.position : this.options.positionLeft === !0 ? (u.className += " toastify-left", console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.")) : u.className += " toastify-right", u.className += " " + this.options.gravity, this.options.backgroundColor && console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
        for (var p in this.options.style)
          u.style[p] = this.options.style[p];
        if (this.options.ariaLive && u.setAttribute("aria-live", this.options.ariaLive), this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE)
          u.appendChild(this.options.node);
        else if (this.options.escapeMarkup ? u.innerText = this.options.text : u.innerHTML = this.options.text, this.options.avatar !== "") {
          var g = document.createElement("img");
          g.src = this.options.avatar, g.className = "toastify-avatar", this.options.position == "left" || this.options.positionLeft === !0 ? u.appendChild(g) : u.insertAdjacentElement("afterbegin", g);
        }
        if (this.options.close === !0) {
          var _ = document.createElement("button");
          _.type = "button", _.setAttribute("aria-label", "Close"), _.className = "toast-close", _.innerHTML = "&#10006;", _.addEventListener(
            "click",
            (function(R) {
              R.stopPropagation(), this.removeElement(this.toastElement), window.clearTimeout(this.toastElement.timeOutValue);
            }).bind(this)
          );
          var y = window.innerWidth > 0 ? window.innerWidth : screen.width;
          (this.options.position == "left" || this.options.positionLeft === !0) && y > 360 ? u.insertAdjacentElement("afterbegin", _) : u.appendChild(_);
        }
        if (this.options.stopOnFocus && this.options.duration > 0) {
          var w = this;
          u.addEventListener(
            "mouseover",
            function(R) {
              window.clearTimeout(u.timeOutValue);
            }
          ), u.addEventListener(
            "mouseleave",
            function() {
              u.timeOutValue = window.setTimeout(
                function() {
                  w.removeElement(u);
                },
                w.options.duration
              );
            }
          );
        }
        if (typeof this.options.destination < "u" && u.addEventListener(
          "click",
          (function(R) {
            R.stopPropagation(), this.options.newWindow === !0 ? window.open(this.options.destination, "_blank") : window.location = this.options.destination;
          }).bind(this)
        ), typeof this.options.onClick == "function" && typeof this.options.destination > "u" && u.addEventListener(
          "click",
          (function(R) {
            R.stopPropagation(), this.options.onClick();
          }).bind(this)
        ), typeof this.options.offset == "object") {
          var P = l("x", this.options), E = l("y", this.options), C = this.options.position == "left" ? P : "-" + P, x = this.options.gravity == "toastify-top" ? E : "-" + E;
          u.style.transform = "translate(" + C + "," + x + ")";
        }
        return u;
      },
      // Displaying the toast
      showToast: function() {
        this.toastElement = this.buildToast();
        var u;
        if (typeof this.options.selector == "string" ? u = document.getElementById(this.options.selector) : this.options.selector instanceof HTMLElement || typeof ShadowRoot < "u" && this.options.selector instanceof ShadowRoot ? u = this.options.selector : u = document.body, !u)
          throw "Root element is not defined";
        var p = o.defaults.oldestFirst ? u.firstChild : u.lastChild;
        return u.insertBefore(this.toastElement, p), o.reposition(), this.options.duration > 0 && (this.toastElement.timeOutValue = window.setTimeout(
          (function() {
            this.removeElement(this.toastElement);
          }).bind(this),
          this.options.duration
        )), this;
      },
      hideToast: function() {
        this.toastElement.timeOutValue && clearTimeout(this.toastElement.timeOutValue), this.removeElement(this.toastElement);
      },
      // Removing the element from the DOM
      removeElement: function(u) {
        u.className = u.className.replace(" on", ""), window.setTimeout(
          (function() {
            this.options.node && this.options.node.parentNode && this.options.node.parentNode.removeChild(this.options.node), u.parentNode && u.parentNode.removeChild(u), this.options.callback.call(u), o.reposition();
          }).bind(this),
          400
        );
      }
    }, o.reposition = function() {
      for (var u = {
        top: 15,
        bottom: 15
      }, p = {
        top: 15,
        bottom: 15
      }, g = {
        top: 15,
        bottom: 15
      }, _ = document.getElementsByClassName("toastify"), y, w = 0; w < _.length; w++) {
        d(_[w], "toastify-top") === !0 ? y = "toastify-top" : y = "toastify-bottom";
        var P = _[w].offsetHeight;
        y = y.substr(9, y.length - 1);
        var E = 15, C = window.innerWidth > 0 ? window.innerWidth : screen.width;
        C <= 360 ? (_[w].style[y] = g[y] + "px", g[y] += P + E) : d(_[w], "toastify-left") === !0 ? (_[w].style[y] = u[y] + "px", u[y] += P + E) : (_[w].style[y] = p[y] + "px", p[y] += P + E);
      }
      return this;
    };
    function l(u, p) {
      return p.offset[u] ? isNaN(p.offset[u]) ? p.offset[u] : p.offset[u] + "px" : "0px";
    }
    function d(u, p) {
      return !u || typeof p != "string" ? !1 : !!(u.className && u.className.trim().split(/\s+/gi).indexOf(p) > -1);
    }
    return o.lib.init.prototype = o.lib, o;
  });
})(er);
var Fa = er.exports;
const Ua = /* @__PURE__ */ Fo(Fa), Le = "onbotgo-chatcontainer";
class vn extends yt {
  constructor() {
    super();
    k(this, "messagesHistory", [
      {
        message: H.welcomeMessage,
        type: "apiMessage"
      },
      ...an.messagesHistory.get() ?? []
    ]);
    k(this, "attachedFiles", []);
    k(this, "attachedRecord");
    k(this, "header");
    k(this, "messagesContainer");
    k(this, "scrollBar");
    k(this, "chatInput");
    k(this, "attachFileInput");
    k(this, "btnOnbotgoAttachInput");
    k(this, "btnattachNewFile");
    k(this, "isRecordSelected", !1);
    k(this, "messagesWebsocket");
    k(this, "chattingWith", "virtual_assistant");
    // virtual_assistnat|human_agent
    k(this, "channelId", "");
    k(this, "defaultStyles", {
      bottom: "60px",
      right: "10px",
      position: "absolute",
      display: "flex",
      boxShadow: "rgba(0, 0, 0, 0.16) 0px 5px 40px",
      flexDirection: "column",
      width: "400px",
      gap: "10px",
      maxWidth: "calc(100vw - 90px)",
      maxHeight: "704px",
      height: "70vh",
      backgroundColor: "white",
      borderRadius: "8px",
      paddingBottom: "10px"
    });
    this.setStyles(this.defaultStyles), this.render(), this.addEventListener("onbotgo-delete-record", () => {
      this.isRecordSelected = !1, this.attachedRecord = null, this.getChild("#onbotgo-chatinput").style.display = "grid", this.getChild("#onbotgo-attachFileTemplateContainer").style.display = "grid", this.updateScrollbar();
    }), this.addEventListener("onbotgo-stop-record", (o) => {
      this.attachedRecord = o.detail;
    });
  }
  initMessagesWebsocket(o) {
    if (this.messagesWebsocket && this.messagesWebsocket.OPEN) {
      console.log("WS MESSAGES IS CONNECTED ", this.messagesWebsocket);
      return;
    }
    const l = `${`${H.ssl ? "wss" : "ws"}://${H.botHost}`}/messages/${o}/ws`;
    this.messagesWebsocket = new WebSocket(l), console.log(this.messagesWebsocket), this.messagesWebsocket.onmessage = (d) => {
      const u = JSON.parse(d.data);
      if (console.log("ON MESSAGE ", u), u.event === "incoming_message") {
        const p = u.data;
        this.addMessages(
          [{ message: p.content, type: "apiMessage" }],
          { updateScrollbar: !0 },
          !0
        );
      }
    }, this.messagesWebsocket.onopen = (d) => {
      console.log("SOCKET CONNECTED ", d), this.messagesWebsocket.send(
        JSON.stringify({ event: "connected", data: null })
      );
    }, this.messagesWebsocket.onerror = (d) => {
      console.log("SOCKET ERRROR ", d);
    }, this.messagesWebsocket.onclose = (d) => {
      console.log("SOCKET Disconnected", d);
    };
  }
  closeMessagesWebsocket() {
    this.messagesWebsocket.send(JSON.stringify({ event: "close", data: null })), this.messagesWebsocket.close();
  }
  onSubmit(o) {
    if (o = (o == null ? void 0 : o.trim()) ?? "", !o && !this.attachedFiles.length && !this.attachedRecord)
      return;
    structuredClone(this.messagesHistory).splice(0, 1);
    const l = {
      channel_id: H.chathubChannelId,
      message: this.attachedFiles.length && !o && !this.attachedRecord ? "Adjunto comprobante de pago" : o,
      url: (this.attachedFiles || []).map(({ url: u }) => u),
      unique_id: H.messageHistoryId
    };
    this.attachedFiles.length && (this.addMessages(
      this.attachedFiles.map((u) => ({
        type: "userMessage",
        file: u,
        fileType: u.type.includes("image") ? "image" : u.type
      }))
    ), this.attachedFiles = [], this.renderAttachTemplate(), this.messagesContainer.querySelectorAll("img").forEach((u) => {
      u.onload = () => this.updateScrollbar();
    })), this.attachedRecord && this.addMessages([
      {
        type: "userMessage",
        file: this.attachedRecord,
        fileType: "audio"
      }
    ]), o && this.addMessages([{ message: o, type: "userMessage" }]), this.renderMessages([{ type: "LoadingMessage" }]), this.updateScrollbar(), this.isRecordSelected = !1, this.attachedRecord = null, this.chatInput.getChild("input").value = "", this.getChild("#onbotgo-chatinput").style.display = "grid", this.getChild("#onbotgo-attachFileTemplateContainer").style.display = "grid", this.updateScrollbar();
    const d = this.getChild("input[type=text]");
    if (d.disabled = !0, this.getChild("#onbotgo-chatinput").style.backgroundColor = "rgba(239,239,239,.6)", this.chattingWith === "human_agent") {
      Ba({
        content: `${l.message}
${l.url}`,
        conversation_id: H.messageHistoryId,
        channel_id: H.chathubChannelId,
        sender: "user"
      }).finally(() => {
        var u;
        this.querySelector("input").focus(), (u = this.messagesContainer.querySelectorAll(".loading-api-message")) == null || u.forEach((p) => p.remove()), d.disabled = !1;
      });
      return;
    }
    l.url.length ? l.url.forEach((u) => {
      zo({
        ...l,
        message: `envio comprobante de pago, esta es la url "${u}"`,
        url: void 0
      }).then((p) => {
        var g, _;
        p != null && p.unique_id && (H.messageHistoryId = p.unique_id, this.initMessagesWebsocket(H.messageHistoryId)), (_ = (g = p == null ? void 0 : p.data) == null ? void 0 : g.process) != null && _.length && p.data.process.forEach((y) => {
          this.addMessages([
            {
              type: y.role,
              name: y.name,
              content: y.content
            }
          ]);
        }), this.addMessages([
          { message: p.response, type: "apiMessage" }
        ]), p.thought && this.showBotThought(p.thought), p.redirect && (this.chattingWith = "human_agent"), p != null && p.cards && this.handleCardMessages(p.cards);
      }).catch((p) => console.log(p)).finally(() => {
        var p;
        (p = this.messagesContainer.querySelectorAll(".loading-api-message")) == null || p.forEach((g) => g.remove()), this.updateScrollbar(), d.disabled = !1, this.getChild("#onbotgo-chatinput").style.backgroundColor = "white", d.focus();
      });
    }) : zo(l).then((u) => {
      var p, g;
      u != null && u.unique_id && (H.messageHistoryId = u.unique_id, this.initMessagesWebsocket(H.messageHistoryId)), (g = (p = u == null ? void 0 : u.data) == null ? void 0 : p.process) != null && g.length && u.data.process.forEach((_) => {
        this.addMessages([
          {
            type: _.role,
            name: _.name,
            content: _.content
          }
        ]);
      }), this.addMessages([
        { message: u.response, type: "apiMessage" }
      ]), u.redirect && (this.chattingWith = "human_agent"), u.thought && this.showBotThought(u.thought), u != null && u.cards && this.handleCardMessages(u.cards);
    }).catch((u) => console.log(u)).finally(() => {
      var u;
      (u = this.messagesContainer.querySelectorAll(".loading-api-message")) == null || u.forEach((p) => p.remove()), d.disabled = !1, this.getChild("#onbotgo-chatinput").style.backgroundColor = "white", d.focus(), this.updateScrollbar();
    });
  }
  handleCardMessages(o) {
    var l, d;
    const h = [];
    o.forEach((u) => {
      var p;
      this.addMessages([u]), (p = H.callbacks) != null && p.address && u.type === "address" && h.push(messageData);
    }), (l = H.callbacks) != null && l.address && ((d = H.callbacks) == null || d.address(h));
  }
  toggle() {
    this.classList.contains("hidden") ? (this.scrollBar.style.visibility = "hidden", this.classList.remove("hidden")) : (this.classList.add("hidden"), this.messagesContainer.scrollTop > 0 && (this.scrollBar.style.visibility = "visible"));
  }
  showBotThought(o) {
    H.showThoughts && Ua({
      text: `<div style="display:flex;align-items:center;gap:10px"><img src="${Qo}" width="30" height="30" /> ${o}</div>`,
      duration: 3e3,
      newWindow: !0,
      gravity: "bottom",
      escapeMarkup: !1,
      position: "center",
      style: {
        background: ot.colors.primary,
        fontFamily: ot.typography.primary,
        cursor: "normal"
      },
      stopOnFocus: !0,
      onClick: function() {
      }
      // Callback after click
    }).showToast();
  }
  async attachFile(o) {
    const h = [
      {
        name: o.target.files[0].name,
        size: o.target.files[0].size,
        type: o.target.files[0].type,
        buffer: Array.from(
          new Uint8Array(await o.target.files[0].arrayBuffer())
        )
      }
    ], l = this.querySelector(
      "onbotgo-dropdown onbotgo-iconbutton"
    );
    try {
      l.querySelector("svg").style.display = "none", l.innerHTML += `<style>.onbotgo-lds-ring {
        display: grid;
        position: relative;
        place-items: center;
        width: 19px;
        height: 19x;
      }
      .onbotgo-lds-ring div {
        box-sizing: border-box;
        display: block;
        position: absolute;
        width: 19px;
        height: 19px;
        border: 2px solid ${ot.colors.primary};
        border-radius: 50%;
        animation: onbotgo-lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        border-color: ${ot.colors.primary} transparent transparent transparent;
      }
      .onbotgo-lds-ring div:nth-child(1) {
        animation-delay: -0.45s;
      }
      .onbotgo-lds-ring div:nth-child(2) {
        animation-delay: -0.3s;
      }
      .onbotgo-lds-ring div:nth-child(3) {
        animation-delay: -0.15s;
      }
      @keyframes onbotgo-lds-ring {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }</style><div class="onbotgo-lds-ring"><div></div><div></div><div></div><div></div></div>`;
      const d = await Za(h);
      this.attachedFiles.push(o.target.files[0]), this.attachedFiles.find(({ name: u }) => u === h[0].name).url = d.data[0].url;
    } catch (d) {
      console.log(d);
    }
    l.querySelector("style").remove(), l.querySelector(".onbotgo-lds-ring").remove(), this.renderAttachTemplate();
  }
  renderMessages(o, h = !1) {
    o.forEach(
      (l) => !["dataMessage"].includes(l.type) && this.messagesContainer.appendChild(new pn(l, h))
    );
  }
  addMessages(o, { updateScrollbar: h } = { updateScrollbar: !1 }, l = !1) {
    this.messagesHistory = this.messagesHistory.concat(o), this.renderMessages(o, l), h && this.updateScrollbar();
  }
  updateScrollbar() {
    this.scrollBar.setScrollThumbHeight(), this.messagesContainer.scrollTo(0, this.messagesContainer.scrollHeight), this.messagesContainer.scrollTop > 0 && this.scrollBar.style.visibility === "hidden" && (this.scrollBar.style.visibility = "visible");
  }
  renderAttachTemplate() {
    this.getChild("#onbotgo-attachFileTemplateContainer").innerHTML = this.renderHTML(Da, {
      attachedFiles: this.attachedFiles,
      paperclipIcon: Do,
      iconPlus: No,
      trashIcon: sn
    }), this.attachFileInput = this.querySelector("#onbotgoAttachFileInput"), this.btnOnbotgoAttachInput = this.querySelector("#btnOnbotgoAttachInput") ?? this.querySelector("#btnOnbotgoAttachInputMenu"), this.btnattachNewFile = this.querySelector("#onbotgo-btnattachNewFile"), this.btnOnbotgoAttachInput.onclick = () => {
      if (!this.attachedFiles.length)
        return this.attachFileInput.click();
    }, this.btnattachNewFile.onclick = () => this.attachFileInput.click(), this.attachFileInput.onchange = (o) => this.attachFile(o), this.querySelectorAll(".onbotgo-attachedFile").forEach((o, h) => {
      o.querySelector("i").onclick = (l) => {
        this.attachedFiles.splice(h, 1), this.renderAttachTemplate(), this.attachedFiles.length && (this.querySelector(".onbotgo-dropdown-content").style.display = "flex"), l.stopPropagation();
      };
    });
  }
  render() {
    this.innerHTML = this.renderHTML(za, {
      logo: Na,
      micIcon: Ha,
      paperclipIcon: Do,
      attachedFiles: this.attachedFiles,
      trashIcon: sn,
      iconPlus: No,
      sendIcon: tr,
      isRecordSelected: this.isRecordSelected
    }), this.renderAttachTemplate();
    const o = this.querySelector("onbotgo-dropdown");
    this.messagesContainer = this.querySelector("#onbotgo-messageContainer"), this.chatInput = this.querySelector(mn.tag), this.scrollBar = this.querySelector(gn.tag), this.header = this.querySelector("#onbotgo-chatheader"), this.header.style.display = "flex", this.header.style.width = "100%", this.header.style.justifyContent = "center", this.header.style.backgroundColor = ot.colors.primary, this.chatInput.onSubmit(this.onSubmit.bind(this)), this.renderMessages(this.messagesHistory), this.isRecordSelected ? (o.style.display = "none", this.chatInput.style.display = "none") : (o.style.display = "grid", this.btnattachNewFile.style.display = "grid", this.chatInput.style.display = "grid");
  }
}
const ja = (a) => ({
  [`${Le}.hidden`]: {
    visibility: "hidden"
  },
  [`${Le} .onbotgo-messageContainer`]: {
    display: "flex !important"
  },
  [`${Le} .onbotgo-chat-footer`]: {
    "font-family": a.typography.primary,
    display: "flex !important",
    "align-items": "center",
    "justify-content": "flex-end",
    gap: "5px"
  },
  [`${Le} .onbotgo-icon-paperclip path`]: {
    stroke: a.colors.primary
  }
});
vn.tag = Le;
const ir = "onbotgo-chatbot";
class hn extends yt {
  constructor() {
    super();
    k(this, "componentStyles", {
      display: "inline-block",
      position: "fixed",
      bottom: "20px",
      right: "20px"
    });
    const o = new un(ot.customIcon), h = new vn();
    o.onclick = () => h.toggle(), this.appendChild(o), this.appendChild(h), this.setStyles(this.componentStyles), St.active && St.position === "br" && this.setStyles({ bottom: "80px" });
  }
}
hn.tag = ir;
const qa = () => ({
  [`${ir} *, ::before, ::after`]: {
    "box-sizing": "content-box !important"
  }
});
function Va({ element: a, styles: r }) {
  const o = r.reduce(
    (d, u) => ({
      ...d,
      ...u
    }),
    {}
  ), h = document.createElement("style"), l = Ga(o);
  h.innerHTML = l, a.prepend(h);
}
function Ya(a, r = {}) {
  const o = Object.keys(r), h = Object.values(r);
  let l = `${a}{`;
  return o.forEach((d, u) => l += `${d}:${h[u]};`), l + "}";
}
function Wa(a, r = {}) {
  const o = Object.keys(r), h = Object.values(r);
  let l = `${a}{`;
  return o.forEach((d, u) => l += `${d}${h[u]};`), l + "}";
}
function Ga(a, r = !1) {
  const o = Object.keys(a);
  let h = "";
  return o.forEach(
    (l) => h += r === "animation" ? Wa(
      l,
      a[l]
    ) : Ya(
      l,
      a[l]
    )
  ), h;
}
const Xa = "onbotgo-iconbutton";
class nr extends yt {
  constructor() {
    super(), this.setStyles({
      display: "grid",
      placeItems: "center",
      verticalAlign: "middle",
      position: "relative",
      cursor: "pointer",
      borderRadius: "200px",
      padding: "2px",
      boxSizing: "border-box"
    });
    const r = this.getAttribute("color"), o = this.getAttribute("size");
    let h = "black";
    r === "primary" && (h = ot.colors.primary), r === "danger" && (h = "red"), o && (this.querySelector("svg").style.width = `calc(${o} - 16px)`, this.querySelector("svg").style.height = `calc(${o} - 16px)`, this.setStyles({ width: o, height: o })), this.setStyles({ color: h });
    const l = new te();
    l.setStyles({
      backgroundColor: h,
      opacity: 0.2,
      position: "absolute",
      width: o ?? "100%",
      borderRadius: "200px",
      height: o ?? "100%",
      zIndex: 0
    }), this.appendChild(l);
  }
}
nr.tag = Xa;
const Qa = "onbotgo-dropdown";
class or extends yt {
  constructor() {
    super(), this.setStyles({ position: "relative" });
    const r = this.querySelector(".onbotgo-dropdown-content"), o = this.querySelectorAll(".onbotgo-attachedFile-name");
    r.style.display = "none", r.style.position = "absolute", r.style.backgroundColor = "white", r.style.minWidth = "170px", r.style.width = "fit-content", r.style.borderRadius = "8px", r.style.bottom = "100%", r.style.left = "50%", r.style.transform = "translateX(-50%)", r.style.boxShadow = "0px 8px 16px 0px rgba(0, 0, 0, 0.2)", r.style.padding = "12px 16px", r.style.zIndex = "1", r.style.gap = "10px", r.style.justifyContent = "space-between", r.style.flexDirection = "column", o.forEach((h) => {
      h.style.maxWidth = "180px", h.style.textOverflow = "ellipsis", h.style.overflow = "hidden", h.style.whiteSpace = "nowrap", h.style.minWidth = "170px";
    }), document.body.onclick = (h) => {
      if (this.contains(h.target))
        return r.contains(h.target) ? void 0 : this.toggle();
      r.style.display = "none";
    };
  }
  toggle() {
    const r = this.querySelector(".onbotgo-dropdown-content");
    r.style.display === "flex" ? r.style.display = "none" : r.style.display = "flex";
  }
}
or.tag = Qa;
const Ka = "onbotgo-fabbutton";
class rr extends yt {
  constructor() {
    super(), this.setStyles({
      display: "inline-block",
      verticalAlign: "middle",
      position: "relative",
      cursor: "pointer",
      borderRadius: "200px",
      padding: "7px",
      color: "white"
    });
    const r = this.getAttribute("color"), o = this.getAttribute("size");
    let h = "black";
    r === "primary" && (h = ot.colors.primary), o && this.setStyles({ width: o, height: o }), this.setStyles({
      backgroundColor: r ? h : "transparent",
      fill: "white"
    });
  }
}
rr.tag = Ka;
const Ja = `<onbotgo-iconbutton color="danger" size="36px" id="onbootgo-delete-record">\r
  <i style="cursor: pointer">{{it.trashIcon | safe}}</i>\r
</onbotgo-iconbutton>\r
\r
<!--PLAY-->\r
<onbotgo-box id="onbotgo-mic-record" style="width: 100%"></onbotgo-box>\r
<onbotgo-iconbutton\r
  id="onbotgo-btn-stop"\r
  color="primary"\r
  size="36px"\r
  style="margin-top: 5px"\r
>\r
  <i style="cursor: pointer">{{it.stopIcon | safe}}</i>\r
</onbotgo-iconbutton>\r
<!-- END PLAY-->\r
\r
<!-- STOP -->\r
<onbotgo-box\r
  id="onbotgo-empty-waveform"\r
  style="width: 100%; padding: 0 8px; padding-top: 1px"\r
>\r
  <onbotgo-box\r
    style="\r
      height: 1px;\r
      width: 100%;\r
      background-color: lightgray;\r
      display: block;\r
    "\r
  ></onbotgo-box>\r
</onbotgo-box>\r
<onbotgo-iconbutton\r
  id="onbotgo-btn-play"\r
  color="primary"\r
  size="36px"\r
  style="margin-top: 7px"\r
>\r
  <i style="cursor: pointer">{{it.playIcon | safe}}</i>\r
</onbotgo-iconbutton>\r
<!-- END STOP-->\r
`, $a = `<svg viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\r
    <defs>\r
</defs>\r
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\r
        <g id="Icon-Set-Filled" sketch:type="MSLayerGroup" transform="translate(-520.000000, -571.000000)" fill="currentColor">\r
            <path d="M546,571 L522,571 C520.896,571 520,571.896 520,573 L520,597 C520,598.104 520.896,599 522,599 L546,599 C547.104,599 548,598.104 548,597 L548,573 C548,571.896 547.104,571 546,571" id="stop" sketch:type="MSShapeGroup">\r
\r
</path>\r
        </g>\r
    </g>\r
</svg>`;
function Ho(a, r, o, h) {
  return new (o || (o = Promise))(function(l, d) {
    function u(_) {
      try {
        g(h.next(_));
      } catch (y) {
        d(y);
      }
    }
    function p(_) {
      try {
        g(h.throw(_));
      } catch (y) {
        d(y);
      }
    }
    function g(_) {
      var y;
      _.done ? l(_.value) : (y = _.value, y instanceof o ? y : new o(function(w) {
        w(y);
      })).then(u, p);
    }
    g((h = h.apply(a, r || [])).next());
  });
}
class th {
  constructor() {
    this.listeners = {};
  }
  on(r, o) {
    return this.listeners[r] || (this.listeners[r] = /* @__PURE__ */ new Set()), this.listeners[r].add(o), () => this.un(r, o);
  }
  once(r, o) {
    const h = this.on(r, o), l = this.on(r, () => {
      h(), l();
    });
    return h;
  }
  un(r, o) {
    this.listeners[r] && (o ? this.listeners[r].delete(o) : delete this.listeners[r]);
  }
  unAll() {
    this.listeners = {};
  }
  emit(r, ...o) {
    this.listeners[r] && this.listeners[r].forEach((h) => h(...o));
  }
}
class eh extends th {
  constructor(r) {
    super(), this.subscriptions = [], this.options = r;
  }
  onInit() {
  }
  init(r) {
    this.wavesurfer = r, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((r) => r());
  }
}
const ih = ["audio/webm", "audio/wav", "audio/mpeg", "audio/mp4", "audio/mp3"];
class yn extends eh {
  constructor(r) {
    var o;
    super(Object.assign(Object.assign({}, r), { audioBitsPerSecond: (o = r.audioBitsPerSecond) !== null && o !== void 0 ? o : 128e3 })), this.stream = null, this.mediaRecorder = null;
  }
  static create(r) {
    return new yn(r || {});
  }
  renderMicStream(r) {
    const o = new AudioContext(), h = o.createMediaStreamSource(r), l = o.createAnalyser();
    h.connect(l);
    const d = l.frequencyBinCount, u = new Float32Array(d), p = d / o.sampleRate;
    let g;
    const _ = () => {
      l.getFloatTimeDomainData(u), this.wavesurfer && (this.wavesurfer.options.cursorWidth = 0, this.wavesurfer.options.interact = !1, this.wavesurfer.load("", [u], p)), g = requestAnimationFrame(_);
    };
    return _(), () => {
      cancelAnimationFrame(g), h == null || h.disconnect(), o == null || o.close();
    };
  }
  startMic() {
    return Ho(this, void 0, void 0, function* () {
      let r;
      try {
        r = yield navigator.mediaDevices.getUserMedia({ audio: !0 });
      } catch (h) {
        throw new Error("Error accessing the microphone: " + h.message);
      }
      const o = this.renderMicStream(r);
      return this.subscriptions.push(this.once("destroy", o)), this.stream = r, r;
    });
  }
  stopMic() {
    this.stream && (this.stream.getTracks().forEach((r) => r.stop()), this.stream = null);
  }
  startRecording() {
    return Ho(this, void 0, void 0, function* () {
      const r = this.stream || (yield this.startMic()), o = this.mediaRecorder || new MediaRecorder(r, { mimeType: this.options.mimeType || ih.find((l) => MediaRecorder.isTypeSupported(l)), audioBitsPerSecond: this.options.audioBitsPerSecond });
      this.mediaRecorder = o, this.stopRecording();
      const h = [];
      o.ondataavailable = (l) => {
        l.data.size > 0 && h.push(l.data);
      }, o.onstop = () => {
        var l;
        const d = new Blob(h, { type: o.mimeType });
        this.emit("record-end", d), this.options.renderRecordedAudio !== !1 && ((l = this.wavesurfer) === null || l === void 0 || l.load(URL.createObjectURL(d)));
      }, o.start(), this.emit("record-start");
    });
  }
  isRecording() {
    var r;
    return ((r = this.mediaRecorder) === null || r === void 0 ? void 0 : r.state) === "recording";
  }
  stopRecording() {
    var r;
    this.isRecording() && ((r = this.mediaRecorder) === null || r === void 0 || r.stop());
  }
  destroy() {
    super.destroy(), this.stopRecording(), this.stopMic();
  }
}
const nh = "onbotgo-micrecord";
class sr extends yt {
  constructor() {
    var o;
    super();
    k(this, "isRecording", !1);
    k(this, "defaultStyles", {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      justifyContent: "center",
      width: "calc(100% - 34px)",
      padding: "10px 0",
      maxWidth: "100%",
      background: "transparent",
      gap: "10px",
      height: "51px"
    });
    k(this, "wavesurfer");
    k(this, "recorder");
    this.render(), this.hideMic(), this.initMic(), this.getChild("#onbootgo-delete-record").onclick = () => {
      let h = new Event("onbotgo-delete-record");
      document.querySelector("onbotgo-chatcontainer").dispatchEvent(h);
    }, (o = this.recorder) == null || o.on("record-end", (h) => {
      let l = new CustomEvent("onbotgo-stop-record", { detail: h });
      document.querySelector("onbotgo-chatcontainer").dispatchEvent(l);
    });
  }
  render() {
    this.innerHTML = this.renderHTML(Ja, {
      isRecording: this.isRecording,
      playIcon: Ji,
      stopIcon: $a,
      trashIcon: sn
    }), this.getChild("#onbotgo-btn-play").onclick = () => {
      this.isRecording = !0, this.displayMic(), this.startRecording();
    }, this.getChild("#onbotgo-btn-stop").onclick = () => {
      this.isRecording = !1, this.hideMic(), this.stopRecording();
    };
  }
  initMic() {
    this.wavesurfer = ai.create({
      container: this.getChild("#onbotgo-mic-record"),
      waveColor: "lightgray",
      barWidth: 1,
      barHeight: 1,
      fillParent: !0
    }), this.recorder = this.wavesurfer.registerPlugin(yn.create());
  }
  startRecording() {
    this.recorder.isRecording() || this.recorder.startRecording();
  }
  stopRecording() {
    this.recorder.isRecording() && this.recorder.stopRecording();
  }
  displayMic() {
    const o = this.getChild("#onbotgo-mic-record");
    this.getChild("#onbotgo-btn-stop").style.display = "grid", [o].forEach((d) => {
      d.style.display = "inline-block";
    });
    const h = this.getChild("#onbotgo-empty-waveform");
    [this.getChild("#onbotgo-btn-play"), h].forEach((d) => {
      d.style.display = "none";
    });
  }
  hideMic() {
    const o = this.getChild("#onbotgo-mic-record"), h = this.getChild("#onbotgo-btn-stop");
    [o, h].forEach((d) => {
      d.style.display = "none";
    });
    const l = this.getChild("#onbotgo-empty-waveform");
    this.getChild("#onbotgo-btn-play").style.display = "grid", [l].forEach((d) => {
      d.style.display = "inline-block";
    });
  }
}
sr.tag = nh;
const oh = `/*!
 * Toastify js 1.12.0
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */.toastify{padding:12px 20px;color:#fff;display:inline-block;box-shadow:0 3px 6px -1px #0000001f,0 10px 36px -4px #4d60e84d;background:-webkit-linear-gradient(315deg,#73a5ff,#5477f5);background:linear-gradient(135deg,#73a5ff,#5477f5);position:fixed;opacity:0;transition:all .4s cubic-bezier(.215,.61,.355,1);border-radius:2px;cursor:pointer;text-decoration:none;max-width:calc(50% - 20px);z-index:2147483647}.toastify.on{opacity:1}.toast-close{background:transparent;border:0;color:#fff;cursor:pointer;font-family:inherit;font-size:1em;opacity:.4;padding:0 5px}.toastify-right{right:15px}.toastify-left{left:15px}.toastify-top{top:-150px}.toastify-bottom{bottom:-150px}.toastify-rounded{border-radius:25px}.toastify-avatar{width:1.5em;height:1.5em;margin:-7px 5px;border-radius:2px}.toastify-center{margin-left:auto;margin-right:auto;left:0;right:0;max-width:fit-content;max-width:-moz-fit-content}@media only screen and (max-width: 360px){.toastify-right,.toastify-left{margin-left:auto;margin-right:auto;left:0;right:0;max-width:fit-content}}
`;
class sh {
  constructor({
    chatflow: r,
    chathubChannelId: o,
    projectPath: h,
    botHost: l,
    ssl: d,
    theme: u,
    welcomeMessage: p,
    whatsappButton: g,
    showThoughts: _,
    callbacks: y,
    googleApikey: w
  }) {
    if (H.chatflowID = r, h && (H.projectPath = h), l && (H.botHost = l), d && (H.ssl = d), p && (H.welcomeMessage = p), y && (H.callbacks = y), w && (H.googleApikey = w), [!1, !0].includes(_) && (H.showThoughts = _), H.chathubChannelId = o, !u)
      return;
    const { typography: P, colors: E, icon: C } = u;
    P && Object.keys(P).forEach(
      (x) => ot.typography[x] = P[x]
    ), E && Object.keys(E).forEach(
      (x) => ot.colors[x] = E[x]
    ), C && (ot.customIcon = C), g != null && g.active && (St.active = !0, St.number = g.number, St.position = g.position.toLowerCase(), St.msg = g.msg);
  }
  init() {
    this.registerComponents(
      hn,
      un,
      vn,
      pn,
      mn,
      te,
      gn,
      nr,
      or,
      rr,
      sr,
      Ki,
      fn,
      hi
    );
    const r = new hn();
    Va({
      element: r,
      styles: [
        ra(ot),
        ka(ot),
        Oa(ot),
        ja(ot),
        na(St),
        qa(),
        Ra(),
        Ma(ot)
      ]
    });
    const o = document.createElement("style");
    if (o.innerHTML = oh, r.prepend(o), document.body.appendChild(r), St.active) {
      const h = new Ki();
      document.body.appendChild(h);
    }
  }
  registerComponents(...r) {
    r.forEach((o) => {
      try {
        if (customElements.get(o.tag))
          return;
        customElements.define(o.tag, o);
      } catch (h) {
        console.log(`error:$ ${h.message}`);
      }
    });
  }
}
export {
  sh as default
};
